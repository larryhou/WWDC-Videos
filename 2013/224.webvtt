WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.506 --> 00:00:09.636 A:middle
[ Silence ]

00:00:10.136 --> 00:00:11.066 A:middle
&gt;&gt; Good morning and welcome.

00:00:11.396 --> 00:00:12.396 A:middle
Thank you.

00:00:12.396 --> 00:00:12.463 A:middle
[ Applause ]

00:00:12.463 --> 00:00:16.536 A:middle
Thank you.

00:00:17.146 --> 00:00:19.736 A:middle
My name is Quinn Taylor, I'm an
Internal Applications Engineer

00:00:19.736 --> 00:00:21.666 A:middle
at Apple, and I'm excited
to be talking today

00:00:21.666 --> 00:00:23.846 A:middle
about Designing Code
for Performance.

00:00:23.916 --> 00:00:26.086 A:middle
It's great to see such a
big crowd here, obviously,

00:00:26.086 --> 00:00:27.156 A:middle
you're all interested
in performance

00:00:27.156 --> 00:00:28.556 A:middle
as well and that's fantastic.

00:00:28.866 --> 00:00:30.706 A:middle
So, to start off, I want
to give you a little bit

00:00:30.706 --> 00:00:31.806 A:middle
of introduction, the motivation

00:00:31.806 --> 00:00:33.876 A:middle
for this talk, why
it came to be.

00:00:33.876 --> 00:00:38.006 A:middle
It's no secret that the raging
success of the App Store has led

00:00:38.006 --> 00:00:40.466 A:middle
to a huge influx of new
developers to the platform.

00:00:41.056 --> 00:00:42.386 A:middle
As you've heard Tim
say on Tues--

00:00:42.386 --> 00:00:46.216 A:middle
on Monday, about two-thirds of
you are here at this conference

00:00:46.216 --> 00:00:47.636 A:middle
for the first time,
that's fantastic.

00:00:47.886 --> 00:00:50.976 A:middle
Many of you are in fact new to
programming in the recent past.

00:00:51.016 --> 00:00:53.556 A:middle
You come from a diverse
array of backgrounds

00:00:53.556 --> 00:00:55.526 A:middle
and experience levels,
and that's great.

00:00:55.526 --> 00:00:58.046 A:middle
You have a lot of different
kinds of wonderful apps

00:00:58.046 --> 00:00:59.286 A:middle
that you can contribute
for our customers

00:00:59.286 --> 00:01:00.236 A:middle
in the App Store that they love.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:59.286 --> 00:01:00.236 A:middle
in the App Store that they love.

00:01:01.206 --> 00:01:03.196 A:middle
However, across all these
domains and different types

00:01:03.196 --> 00:01:05.316 A:middle
of applications, one
thing that's constant is

00:01:05.316 --> 00:01:07.636 A:middle
that everyone uses data
structures and it's common

00:01:07.636 --> 00:01:08.756 A:middle
to have performance issues.

00:01:09.096 --> 00:01:11.166 A:middle
No matter what your app does,
you're going to be using arrays

00:01:11.166 --> 00:01:13.586 A:middle
and dictionaries and so on, and
it's important to understand how

00:01:13.586 --> 00:01:15.086 A:middle
that can affect your
application.

00:01:15.356 --> 00:01:16.496 A:middle
When you have issues like this,

00:01:16.496 --> 00:01:19.716 A:middle
often they're puzzling unless
you have some knowledge

00:01:19.716 --> 00:01:22.396 A:middle
of what's going on under the
hood and what's happening

00:01:22.556 --> 00:01:24.916 A:middle
so you can evaluate
your app and improve.

00:01:25.596 --> 00:01:29.486 A:middle
So, the goal of this session is
really to teach you how to fish.

00:01:29.486 --> 00:01:31.036 A:middle
I'm not here to give
you a one-off tip

00:01:31.036 --> 00:01:33.746 A:middle
about how you can fix a specific
problem, but really to look

00:01:33.746 --> 00:01:36.106 A:middle
at the grand scheme of things,
understand when it comes

00:01:36.106 --> 00:01:38.706 A:middle
to data structures, how can
I make my app perform the

00:01:38.706 --> 00:01:39.406 A:middle
best possible.

00:01:40.186 --> 00:01:42.846 A:middle
So the things we're going
to cover today: first off,

00:01:42.846 --> 00:01:46.726 A:middle
when to focus on performance,
how to evaluate what we call

00:01:46.726 --> 00:01:49.526 A:middle
"computational complexity",
how to choose

00:01:49.526 --> 00:01:52.286 A:middle
and use data structures in
your application, and last,

00:01:52.286 --> 00:01:53.826 A:middle
how to design your
code for performance.

00:01:53.826 --> 00:01:54.956 A:middle
We'll give some concrete
examples.

00:01:55.146 --> 00:01:58.186 A:middle
So to start off, when
to focus on performance.

00:01:58.186 --> 00:01:59.776 A:middle
Now you may think: "This
is a trick question,

00:01:59.776 --> 00:02:01.146 A:middle
the answer is 'always', right?"

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.776 --> 00:02:01.146 A:middle
the answer is 'always', right?"

00:02:01.146 --> 00:02:03.366 A:middle
That's true to a certain extent,

00:02:03.586 --> 00:02:04.906 A:middle
and we'll talk about
that in detail.

00:02:05.036 --> 00:02:06.686 A:middle
To start off with a quote,
I have this on my wall,

00:02:06.686 --> 00:02:09.216 A:middle
this is from Steve Jobs,
"We don't get a chance to do

00:02:09.216 --> 00:02:12.066 A:middle
that many things, and every
one should be really excellent.

00:02:12.416 --> 00:02:14.206 A:middle
We've all chosen to do
this with our lives.

00:02:14.436 --> 00:02:15.786 A:middle
So it better be damn good.

00:02:15.946 --> 00:02:17.016 A:middle
It better be worth it."

00:02:17.576 --> 00:02:19.106 A:middle
I love this quote
because it motivates me

00:02:19.106 --> 00:02:21.596 A:middle
to make my applications the
best that I possibly can,

00:02:21.596 --> 00:02:23.466 A:middle
and try to eke performance
out of every angle.

00:02:24.046 --> 00:02:24.976 A:middle
However, you notice
that he says,

00:02:24.976 --> 00:02:26.596 A:middle
"Every one should be
really excellent,"

00:02:26.806 --> 00:02:28.106 A:middle
that's not necessarily perfect.

00:02:28.106 --> 00:02:30.856 A:middle
We as developers know that
our applications have flaws.

00:02:30.856 --> 00:02:33.566 A:middle
We do the best that we can
to make them as polished

00:02:33.566 --> 00:02:35.096 A:middle
as possible before
we hand them over,

00:02:35.356 --> 00:02:36.846 A:middle
but we have a limited
amount of time.

00:02:37.236 --> 00:02:39.156 A:middle
Steve also said, "You
have to pick carefully.

00:02:39.486 --> 00:02:41.896 A:middle
Innovation is saying
no to 1,000 things."

00:02:41.986 --> 00:02:43.616 A:middle
So how do we strike
the balance here

00:02:43.616 --> 00:02:45.416 A:middle
when it comes to performance?

00:02:45.496 --> 00:02:47.096 A:middle
You may have seen a
quote from Donald Knuth,

00:02:47.096 --> 00:02:49.026 A:middle
a famous computer
scientist, where he says,

00:02:49.026 --> 00:02:51.136 A:middle
"Premature optimization
is the root of all evil."

00:02:51.486 --> 00:02:53.416 A:middle
People tend to throw this
around at developer forums

00:02:53.846 --> 00:02:55.746 A:middle
and some people will use
this almost an excuse to say,

00:02:55.746 --> 00:02:57.686 A:middle
"You don't need to worry about
performance at all, right?

00:02:57.686 --> 00:02:58.786 A:middle
It's not going to
be a big deal."

00:02:59.176 --> 00:03:00.346 A:middle
Sometimes that's the case.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.176 --> 00:03:00.346 A:middle
Sometimes that's the case.

00:03:00.756 --> 00:03:03.236 A:middle
But unfortunately, we usually
only see this middle sentence

00:03:03.236 --> 00:03:03.616 A:middle
of the quote.

00:03:03.826 --> 00:03:05.806 A:middle
But he said a lot more,
he said, "We should forget

00:03:05.806 --> 00:03:09.216 A:middle
about small efficiencies
about 97 percent of the time.

00:03:09.666 --> 00:03:11.976 A:middle
Yet we should not pass
up our opportunities

00:03:11.976 --> 00:03:13.386 A:middle
in that critical 3 percent."

00:03:13.806 --> 00:03:15.296 A:middle
So there comes a
time when focusing

00:03:15.296 --> 00:03:17.656 A:middle
on performance is really
important for your application.

00:03:18.326 --> 00:03:20.776 A:middle
I like to summarize this by
saying, "Optimize performance

00:03:20.956 --> 00:03:22.726 A:middle
when it will make a
meaningful difference."

00:03:22.756 --> 00:03:24.326 A:middle
That's what we're going
to be talking about today,

00:03:24.536 --> 00:03:26.266 A:middle
is how I can choose to see--

00:03:26.266 --> 00:03:28.156 A:middle
is this going to make a
difference for my application?

00:03:28.786 --> 00:03:32.206 A:middle
So, to talk about that, there's
a principle called Amdahl's Law

00:03:32.206 --> 00:03:34.266 A:middle
which is really about
helping you pick your battles

00:03:34.266 --> 00:03:35.296 A:middle
in performance.

00:03:35.436 --> 00:03:38.156 A:middle
So this law was proposed
by Gene Amdahl,

00:03:38.156 --> 00:03:40.626 A:middle
a very famous computer
architect, and basically,

00:03:40.626 --> 00:03:43.116 A:middle
it has to do with predicting
the maximum improvement

00:03:43.116 --> 00:03:45.546 A:middle
that you can expect by speeding
up some portion of your code.

00:03:46.196 --> 00:03:48.336 A:middle
This depends obviously on
what percentage of time

00:03:48.336 --> 00:03:50.916 A:middle
that code is taking to
begin with, to see what kind

00:03:50.916 --> 00:03:51.886 A:middle
of speedup you can achieve.

00:03:52.236 --> 00:03:54.976 A:middle
And the payoff is much larger
for the dominant piece of code,

00:03:54.976 --> 00:03:56.126 A:middle
the thing that's
taking the most time;

00:03:56.486 --> 00:03:57.746 A:middle
these appear fairly obvious.

00:03:58.406 --> 00:04:00.036 A:middle
So the question is,
will the payoff

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:58.406 --> 00:04:00.036 A:middle
So the question is,
will the payoff

00:04:00.236 --> 00:04:01.886 A:middle
of improving the
performance of this piece

00:04:01.936 --> 00:04:03.996 A:middle
of the code be worth the
effort, the time that it's going

00:04:03.996 --> 00:04:04.726 A:middle
to take me to do that?

00:04:04.726 --> 00:04:07.066 A:middle
And this applies
directly to concurrency.

00:04:07.066 --> 00:04:09.726 A:middle
In fact, as this law was
originally stated, it had to do

00:04:09.726 --> 00:04:12.116 A:middle
with multi-core processing
and breaking your code

00:04:12.116 --> 00:04:15.126 A:middle
up into multiple pieces, and
that has great tie-ins as well

00:04:15.126 --> 00:04:17.106 A:middle
to Grand Central
Dispatch and using blocks.

00:04:17.216 --> 00:04:19.625 A:middle
So let me give you an
example of Amdahl's Law.

00:04:19.625 --> 00:04:22.936 A:middle
Say that you have a process
that has two segments, A and B,

00:04:23.106 --> 00:04:25.776 A:middle
and one takes 80 seconds
and one takes 20 seconds.

00:04:26.006 --> 00:04:28.466 A:middle
So we have a certain
amount of time.

00:04:28.496 --> 00:04:32.186 A:middle
Now, if you can spend a
bit of time and optimize

00:04:32.186 --> 00:04:36.136 A:middle
and cut the time spent by
process B-- segment B in half,

00:04:36.136 --> 00:04:36.936 A:middle
then you have a great win.

00:04:36.936 --> 00:04:38.976 A:middle
Now you're at 90 percent of
your previous performance.

00:04:39.276 --> 00:04:41.976 A:middle
However, if you can apply
the same effort to speed

00:04:41.976 --> 00:04:43.776 A:middle
up process A and cut
that time in half,

00:04:43.776 --> 00:04:44.976 A:middle
now you've gone to 60 percent.

00:04:45.256 --> 00:04:47.586 A:middle
This is a much bigger win,
and this is what we talk

00:04:47.586 --> 00:04:49.306 A:middle
about when we say
"identifying bottlenecks",

00:04:49.306 --> 00:04:51.286 A:middle
looking at the actual
problems in your code.

00:04:51.676 --> 00:04:53.646 A:middle
So that's where you really
want to focus on performance.

00:04:53.936 --> 00:04:56.686 A:middle
You know, it's great to have a
performance win in segment B,

00:04:56.926 --> 00:04:58.696 A:middle
but everyone has things that
they have to do, so you've got

00:04:58.696 --> 00:04:59.936 A:middle
to choose wisely
what you work on.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:00.416 --> 00:05:01.756 A:middle
So back to Donald Knuth,

00:05:01.756 --> 00:05:03.406 A:middle
he talked about premature
optimization.

00:05:04.076 --> 00:05:06.796 A:middle
Now, premature optimization
generally leads

00:05:07.096 --> 00:05:09.446 A:middle
to unnecessary complexity
in your code.

00:05:09.736 --> 00:05:11.446 A:middle
You take something
that's simple and to try

00:05:11.446 --> 00:05:14.256 A:middle
to get more performance out of
it, you change and tweak things

00:05:14.256 --> 00:05:15.836 A:middle
and make it more
complex and clever.

00:05:16.166 --> 00:05:17.106 A:middle
Sometimes that's great.

00:05:17.376 --> 00:05:19.156 A:middle
But, "if it ain't
broke, don't fix it".

00:05:19.156 --> 00:05:21.836 A:middle
You don't have to fix something
that's not necessarily a problem

00:05:21.836 --> 00:05:22.366 A:middle
for your code.

00:05:22.606 --> 00:05:24.876 A:middle
You have a ton of features
that you need to implement

00:05:24.876 --> 00:05:27.436 A:middle
for your app, and polishing it
to make it great for your users.

00:05:27.536 --> 00:05:29.716 A:middle
So I'd like to focus
on something I call

00:05:29.716 --> 00:05:32.346 A:middle
"informed design" which leads
to elegant and efficient code.

00:05:32.996 --> 00:05:34.796 A:middle
Informed design is all

00:05:34.796 --> 00:05:36.936 A:middle
about considering your
performance early on,

00:05:37.306 --> 00:05:38.526 A:middle
even during the design phase.

00:05:38.526 --> 00:05:41.086 A:middle
You can do that before you
even write a line of code.

00:05:41.496 --> 00:05:44.096 A:middle
And it helps you to
intelligently avoid problems

00:05:44.096 --> 00:05:45.706 A:middle
that you can actually
face in the real world,

00:05:45.736 --> 00:05:47.216 A:middle
rather than premature
optimization

00:05:47.216 --> 00:05:48.966 A:middle
and fixing a problem
that may not be

00:05:48.966 --> 00:05:50.126 A:middle
such a big problem after all.

00:05:51.156 --> 00:05:53.796 A:middle
And this is useful because it
can help you avoid designing

00:05:53.796 --> 00:05:56.246 A:middle
slowness into your application,
only to fix it later.

00:05:56.586 --> 00:05:58.676 A:middle
So if you can think about
it up front, it's a big win.

00:05:58.676 --> 00:06:01.326 A:middle
OK. So now let's move
to talking about how

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.676 --> 00:06:01.326 A:middle
OK. So now let's move
to talking about how

00:06:01.326 --> 00:06:02.446 A:middle
to design for performance.

00:06:02.666 --> 00:06:04.606 A:middle
If you have a performance
issue that you've identified

00:06:04.606 --> 00:06:07.076 A:middle
in your code, there's
three broad ways

00:06:07.076 --> 00:06:08.436 A:middle
that you can resolve that.

00:06:08.436 --> 00:06:10.176 A:middle
The first is, don't do it.

00:06:10.556 --> 00:06:11.666 A:middle
If there's unnecessary work,

00:06:11.666 --> 00:06:12.706 A:middle
then you can completely
cut it out.

00:06:12.706 --> 00:06:15.946 A:middle
The second is do it as rarely as
possible, and the third is do it

00:06:15.946 --> 00:06:17.126 A:middle
as efficiently as possible.

00:06:17.916 --> 00:06:20.366 A:middle
Now, these are generally in
increasing order of difficulty.

00:06:20.366 --> 00:06:23.046 A:middle
It's very easy to just remove
code that you no longer need,

00:06:23.046 --> 00:06:24.656 A:middle
but getting something to
be more efficient can be

00:06:24.656 --> 00:06:25.356 A:middle
really difficult.

00:06:25.786 --> 00:06:27.316 A:middle
In order to answer these
questions and choose

00:06:27.316 --> 00:06:28.946 A:middle
which approach works
for your scenario,

00:06:29.296 --> 00:06:30.586 A:middle
you really have to
have some context.

00:06:30.866 --> 00:06:31.986 A:middle
Is the work necessary?

00:06:32.046 --> 00:06:33.826 A:middle
If not, I may be
able to remove it.

00:06:34.036 --> 00:06:35.776 A:middle
Is redundant work being done?

00:06:35.876 --> 00:06:37.216 A:middle
Doing the same thing
over and over again,

00:06:37.216 --> 00:06:38.616 A:middle
I may be able to
reuse that work.

00:06:38.926 --> 00:06:40.366 A:middle
Or, is there a more
efficient way?

00:06:40.756 --> 00:06:42.556 A:middle
And that last question is
really the most tricky.

00:06:43.046 --> 00:06:46.166 A:middle
How do I know if I can do better
than what I'm doing right now?

00:06:47.046 --> 00:06:49.606 A:middle
So, to answer that question,
we'll go into the next portion

00:06:49.606 --> 00:06:50.206 A:middle
of the talk, where we talk

00:06:50.206 --> 00:06:52.996 A:middle
about computational
complexity and cost.

00:06:52.996 --> 00:06:55.036 A:middle
Now, these are some big words
so I'll explain out for you

00:06:55.616 --> 00:06:57.406 A:middle
in kind of broad terms.

00:06:57.406 --> 00:06:59.786 A:middle
So we're talking about the
cost of code, and by this,

00:06:59.786 --> 00:07:01.976 A:middle
I don't mean how much you
pay for an app in the store

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:59.786 --> 00:07:01.976 A:middle
I don't mean how much you
pay for an app in the store

00:07:02.216 --> 00:07:05.576 A:middle
or how much it cost you
to have people develop it.

00:07:05.686 --> 00:07:08.476 A:middle
Every piece of code takes
some amount of time to run

00:07:08.476 --> 00:07:10.726 A:middle
because there's work being
done, and it's obvious

00:07:10.726 --> 00:07:12.376 A:middle
that more work takes more time.

00:07:13.166 --> 00:07:14.606 A:middle
However, it's not
necessarily obvious

00:07:14.606 --> 00:07:16.456 A:middle
that sometimes you can
have really short code

00:07:16.456 --> 00:07:19.156 A:middle
that does a lot of work and
it can hide some complexity.

00:07:19.416 --> 00:07:22.136 A:middle
There's a cost associated
with a particular code,

00:07:22.416 --> 00:07:24.636 A:middle
perhaps an API call or so on,
or you're using a library.

00:07:25.176 --> 00:07:29.316 A:middle
Now, the effects of data
growth can vary quite a bit

00:07:29.316 --> 00:07:31.236 A:middle
when you're choosing
an algorithm,

00:07:31.346 --> 00:07:33.486 A:middle
and it can really impact your
performance, particularly

00:07:33.486 --> 00:07:34.746 A:middle
as your data size grows.

00:07:35.346 --> 00:07:37.346 A:middle
It may be disproportional,
in fact, to the number

00:07:37.346 --> 00:07:38.606 A:middle
of objects that you add.

00:07:39.066 --> 00:07:41.036 A:middle
And consequently, small
tests often won't turn

00:07:41.036 --> 00:07:42.096 A:middle
up this kind of problems.

00:07:42.386 --> 00:07:45.226 A:middle
We try to do as much testing as
we can before we send our app

00:07:45.226 --> 00:07:47.566 A:middle
out into the world, but you've
probably all experienced

00:07:47.566 --> 00:07:50.036 A:middle
that your customers will use
your app in new and exciting

00:07:50.036 --> 00:07:52.816 A:middle
and sometimes terrifying ways,
and throw a lot of data at it

00:07:52.816 --> 00:07:54.196 A:middle
in ways that you
didn't anticipate.

00:07:54.546 --> 00:07:56.326 A:middle
And sometimes these
performance issues will crop

00:07:56.326 --> 00:07:59.546 A:middle
up where you least want them to.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:00.266 --> 00:08:02.926 A:middle
Fortunately, this kind of
complexity can often be analyzed

00:08:03.086 --> 00:08:04.106 A:middle
without even running the code,

00:08:04.106 --> 00:08:05.996 A:middle
much like the Xcode
static analyzer can do.

00:08:05.996 --> 00:08:09.086 A:middle
And the key to this is
understanding the complexity

00:08:09.086 --> 00:08:11.076 A:middle
of the code that you're running
and how much work is being done.

00:08:11.356 --> 00:08:14.486 A:middle
Now, Computer Science has
entire semester courses devoted

00:08:14.486 --> 00:08:17.266 A:middle
to this, that leaves sophomore
students really puzzled.

00:08:17.556 --> 00:08:19.556 A:middle
We don't the have time to
get into an entire semester,

00:08:19.556 --> 00:08:21.376 A:middle
but I'm going to give you
kind of a crash course

00:08:21.586 --> 00:08:24.226 A:middle
and help you have a framework
for understanding complexity

00:08:24.386 --> 00:08:25.276 A:middle
and analyzing your code.

00:08:25.276 --> 00:08:27.256 A:middle
So, in Computer Science, we talk

00:08:27.256 --> 00:08:29.166 A:middle
about something called
"Big O" notation.

00:08:29.166 --> 00:08:32.486 A:middle
So this is a way of ranking
algorithms by efficiency,

00:08:32.486 --> 00:08:34.155 A:middle
generally, by their
time efficiency,

00:08:34.155 --> 00:08:35.616 A:middle
or memory efficiency, or so on.

00:08:35.616 --> 00:08:38.645 A:middle
And the letter O stands for
the order, the order of growth

00:08:38.645 --> 00:08:40.046 A:middle
of this, and we'll talk
about this in detail.

00:08:40.596 --> 00:08:43.655 A:middle
And it really relates to how the
performance changes as the scale

00:08:43.856 --> 00:08:46.706 A:middle
of the work that you're doing--
when you increase the number

00:08:46.706 --> 00:08:48.186 A:middle
of objects you're
working with, for example.

00:08:48.736 --> 00:08:53.266 A:middle
So, with Big O notation,
what we're really seeking

00:08:53.266 --> 00:08:55.896 A:middle
to do is approximate the worst
case behavior for an algorithm,

00:08:56.156 --> 00:08:57.976 A:middle
the most work that you
might ever have to do.

00:08:58.226 --> 00:09:00.766 A:middle
Ideally with an algorithm, you
may be able to skip out early

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:58.226 --> 00:09:00.766 A:middle
Ideally with an algorithm, you
may be able to skip out early

00:09:01.026 --> 00:09:03.476 A:middle
and so on if you're doing
searches and that type of thing.

00:09:03.696 --> 00:09:07.036 A:middle
But Big O is concerned with "how
bad could this possibly be"?

00:09:07.036 --> 00:09:09.636 A:middle
So then that's my absolute
worst case of performance.

00:09:09.726 --> 00:09:11.676 A:middle
And in general, we
ignore coefficients

00:09:11.676 --> 00:09:13.636 A:middle
and lower order terms
and logarithmic bases

00:09:13.636 --> 00:09:15.706 A:middle
because what we really
care about is the order,

00:09:15.706 --> 00:09:17.526 A:middle
whether it's N or N squared,

00:09:17.526 --> 00:09:18.776 A:middle
as we'll go into
detail in just a moment.

00:09:19.806 --> 00:09:21.936 A:middle
Now, for any given task,
it's important to realize

00:09:21.936 --> 00:09:23.276 A:middle
that there are inherent limits.

00:09:23.716 --> 00:09:25.336 A:middle
There are some things
that just take time.

00:09:25.336 --> 00:09:26.736 A:middle
We'd like to do everything
instantly

00:09:26.736 --> 00:09:28.076 A:middle
but that's not always possible.

00:09:28.426 --> 00:09:30.186 A:middle
A perfect example of
this, Fred Brooks,

00:09:30.216 --> 00:09:31.566 A:middle
famous software engineer:

00:09:32.026 --> 00:09:34.576 A:middle
"Nine women can't make
a baby in one month."

00:09:34.576 --> 00:09:35.666 A:middle
As many women as
you assign to it,

00:09:35.666 --> 00:09:36.866 A:middle
you'd like to do
it concurrently,

00:09:36.866 --> 00:09:38.286 A:middle
it would be much more
convenient for them,

00:09:38.546 --> 00:09:39.766 A:middle
but it's simply not possible.

00:09:39.766 --> 00:09:41.006 A:middle
There's a hard limit
on this, right?

00:09:41.086 --> 00:09:43.656 A:middle
So we're going to talk
about Big O complexity,

00:09:43.656 --> 00:09:45.446 A:middle
and I want to identify
for you a few key

00:09:45.506 --> 00:09:46.866 A:middle
and common order functions.

00:09:46.866 --> 00:09:49.496 A:middle
So I have a table here, in
the first column, notation,

00:09:49.496 --> 00:09:52.866 A:middle
you'll see how you might see it
written and these are pronounced

00:09:52.866 --> 00:09:54.416 A:middle
"Big O of 1" or "order 1",

00:09:54.606 --> 00:09:57.416 A:middle
"order log N", "order
N", and so on.

00:09:57.496 --> 00:10:00.336 A:middle
You might also hear it referred
to by the name "constant time",

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:57.496 --> 00:10:00.336 A:middle
You might also hear it referred
to by the name "constant time",

00:10:00.336 --> 00:10:02.466 A:middle
"logarithmic time", "linear
time", "quadratic time",

00:10:02.466 --> 00:10:03.976 A:middle
and so on, these
are interchangeable.

00:10:04.306 --> 00:10:06.506 A:middle
And then provided in the
third column some examples

00:10:06.506 --> 00:10:08.636 A:middle
of common algorithms
or tasks that fall

00:10:08.636 --> 00:10:09.756 A:middle
into these different categories.

00:10:10.076 --> 00:10:12.066 A:middle
I won't go into them in
detail here on this slide,

00:10:12.366 --> 00:10:14.986 A:middle
but this is great for
reference to come back and see

00:10:14.986 --> 00:10:16.796 A:middle
where does my task actually fit?

00:10:16.796 --> 00:10:19.516 A:middle
And we'll talk a little bit
more in detail about identifying

00:10:19.516 --> 00:10:20.946 A:middle
which of these your
task belongs to.

00:10:20.946 --> 00:10:22.976 A:middle
Now, a few of these
are most common.

00:10:22.976 --> 00:10:25.636 A:middle
You'll see this all over the
place and they're very common

00:10:25.636 --> 00:10:27.296 A:middle
for algorithms that
you'll be working with.

00:10:27.426 --> 00:10:28.656 A:middle
So I'll talk about
these in detail.

00:10:30.836 --> 00:10:34.226 A:middle
So the first-- before I get
into some specific details,

00:10:34.226 --> 00:10:36.186 A:middle
let me show you a comparison
of these order functions.

00:10:36.186 --> 00:10:37.666 A:middle
So it's easy to see
them in a table,

00:10:37.906 --> 00:10:39.756 A:middle
but maybe it doesn't hit
home why this is important.

00:10:39.756 --> 00:10:43.166 A:middle
First off, this is what order N
squared complexity looks like,

00:10:43.486 --> 00:10:49.186 A:middle
like a parabola, order N
log N, order N, order log N,

00:10:50.056 --> 00:10:51.376 A:middle
and order 1 or constant time.

00:10:51.906 --> 00:10:53.966 A:middle
Now, the first thing that
you can see is these diverge

00:10:54.146 --> 00:10:55.056 A:middle
really rapidly.

00:10:55.336 --> 00:10:57.216 A:middle
When you get to a
large number of items

00:10:57.216 --> 00:10:59.956 A:middle
across the bottom scale,
you have some of these

00:10:59.956 --> 00:11:01.276 A:middle
that it gets really complex

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:59.956 --> 00:11:01.276 A:middle
that it gets really complex

00:11:01.276 --> 00:11:02.506 A:middle
and shoots its way
up towards the top.

00:11:02.506 --> 00:11:04.546 A:middle
That means your performance is
going to be bad, you're doing

00:11:04.546 --> 00:11:05.876 A:middle
that much more work, right?

00:11:06.146 --> 00:11:07.336 A:middle
The other thing to
notice is that down

00:11:07.336 --> 00:11:09.786 A:middle
at the bottom left corner,
they're really close together.

00:11:09.936 --> 00:11:12.476 A:middle
So for small scale, it
may not be necessary

00:11:12.476 --> 00:11:14.136 A:middle
to find a really
optimal algorithm.

00:11:14.316 --> 00:11:15.706 A:middle
This would be a range
where you want to watch

00:11:15.706 --> 00:11:17.166 A:middle
out for premature optimization.

00:11:17.396 --> 00:11:18.586 A:middle
Am I really going to
have an issue here,

00:11:18.586 --> 00:11:20.756 A:middle
because they're all
pretty close together.

00:11:20.756 --> 00:11:22.266 A:middle
So those are some
things to be aware off.

00:11:22.976 --> 00:11:27.836 A:middle
So, I'm going to go through some
examples of a few sample pieces

00:11:27.836 --> 00:11:31.236 A:middle
of code that have some
of these complexities.

00:11:31.236 --> 00:11:33.286 A:middle
And remember, the key for this
is, is that we want to look

00:11:33.286 --> 00:11:36.136 A:middle
of the growth-- at the growth of
the amount of work as the size

00:11:36.136 --> 00:11:37.036 A:middle
of our input increases.

00:11:37.106 --> 00:11:38.646 A:middle
So first is a very simple one.

00:11:38.646 --> 00:11:40.236 A:middle
Let's say that we have
an array of integers

00:11:40.436 --> 00:11:42.596 A:middle
and I have a function where
I pass in an integer value

00:11:42.756 --> 00:11:44.506 A:middle
and an index, and I
simply want to know:

00:11:44.846 --> 00:11:46.926 A:middle
does this value appear
at that index?

00:11:46.926 --> 00:11:49.426 A:middle
Now you can see we're only doing
one operation, and you may know

00:11:49.426 --> 00:11:52.106 A:middle
that indexing into an
array is extremely fast.

00:11:52.356 --> 00:11:54.176 A:middle
So, in this case, it's order 1;

00:11:54.516 --> 00:11:56.076 A:middle
regardless of what
index I choose,

00:11:56.076 --> 00:11:57.486 A:middle
it's going to return
nearly instantly.

00:11:57.586 --> 00:11:59.226 A:middle
So if we have a sample array,

00:11:59.356 --> 00:12:01.546 A:middle
you can see I may
query one index and say

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:59.356 --> 00:12:01.546 A:middle
you can see I may
query one index and say

00:12:01.546 --> 00:12:02.806 A:middle
that that value is not there,

00:12:03.096 --> 00:12:04.816 A:middle
here I found it,
and there I've not.

00:12:05.046 --> 00:12:06.436 A:middle
So I don't have to
look at anything else

00:12:06.436 --> 00:12:07.646 A:middle
in the array, just one spot.

00:12:07.816 --> 00:12:09.046 A:middle
So that makes this order 1.

00:12:09.696 --> 00:12:11.806 A:middle
If we change this
up just slightly,

00:12:12.836 --> 00:12:14.276 A:middle
now we have an order
N algorithm.

00:12:14.566 --> 00:12:16.326 A:middle
So, now I'm interested in seeing

00:12:16.496 --> 00:12:18.876 A:middle
if a particular value
appears anywhere in an array,

00:12:19.016 --> 00:12:20.486 A:middle
not just at a given index.

00:12:20.486 --> 00:12:22.166 A:middle
In order to do that,
because I don't know

00:12:22.166 --> 00:12:24.496 A:middle
where it would appear, if it's
there at all, I have to look

00:12:24.496 --> 00:12:25.736 A:middle
through each index in the array.

00:12:26.076 --> 00:12:27.916 A:middle
So we have a for loop when
we start at the beginning

00:12:27.916 --> 00:12:28.666 A:middle
and we go towards the end,

00:12:28.666 --> 00:12:30.386 A:middle
and then we test to
see if it's there.

00:12:30.386 --> 00:12:32.476 A:middle
If at any point I
find it, I return yes.

00:12:32.676 --> 00:12:35.896 A:middle
But, the worst case is that it's
not there in the array at all,

00:12:35.896 --> 00:12:37.946 A:middle
and I have to check
thought every single index

00:12:37.946 --> 00:12:38.966 A:middle
in order to determine that.

00:12:38.966 --> 00:12:41.976 A:middle
So, you could see here, I
have to march one by one

00:12:42.116 --> 00:12:43.896 A:middle
down the array until
I find the object,

00:12:44.386 --> 00:12:45.436 A:middle
or determine that
it's not there.

00:12:45.946 --> 00:12:47.296 A:middle
So in worst case, order N.

00:12:47.496 --> 00:12:51.276 A:middle
For order N squared, let's
say we have a similar array,

00:12:51.356 --> 00:12:53.936 A:middle
I give it a value and I want
to say, does this value appear

00:12:53.936 --> 00:12:55.646 A:middle
at least twice anywhere
in the array?

00:12:55.646 --> 00:12:57.656 A:middle
In order to do that, I have

00:12:57.656 --> 00:13:01.086 A:middle
to compare every two possible
pairings of indexes in the array

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:57.656 --> 00:13:01.086 A:middle
to compare every two possible
pairings of indexes in the array

00:13:01.086 --> 00:13:01.966 A:middle
to see if they're equal.

00:13:02.376 --> 00:13:04.176 A:middle
So what that means is that
I have to do two for loops.

00:13:04.176 --> 00:13:06.326 A:middle
I have an outer for loop
and an inner for loop,

00:13:06.326 --> 00:13:09.766 A:middle
and each of these is
an order N algorithm.

00:13:10.936 --> 00:13:13.616 A:middle
And inside this for loop once
I get to comparing two indexes,

00:13:13.886 --> 00:13:16.846 A:middle
you see, I compare each of these
two to see if they're equal

00:13:16.846 --> 00:13:20.986 A:middle
and if at any point I find them,
I can bail out and say yes.

00:13:21.036 --> 00:13:22.806 A:middle
And you can see that we're
doing a lot more work here;

00:13:22.806 --> 00:13:26.296 A:middle
j is moving back and forth like
a madman, and i is just trying

00:13:26.296 --> 00:13:28.046 A:middle
to keep up, and finally
here at the end,

00:13:28.166 --> 00:13:30.006 A:middle
we find those two
matching values.

00:13:30.286 --> 00:13:32.486 A:middle
Now in the worst case, there
may be no values at all--

00:13:32.486 --> 00:13:34.676 A:middle
these two values may not
be present in the array,

00:13:34.996 --> 00:13:37.226 A:middle
or the value may not be
present twice in the array,

00:13:37.226 --> 00:13:40.116 A:middle
but we have to go to the
very end to find that out.

00:13:40.116 --> 00:13:41.116 A:middle
Now, some of you
may look at this

00:13:41.116 --> 00:13:43.116 A:middle
and realize this is a
rather naive implementation.

00:13:43.356 --> 00:13:45.286 A:middle
I'm starting the j loop
at zero every time.

00:13:45.726 --> 00:13:49.016 A:middle
So, for example, when i gets
to the very end of the array

00:13:49.016 --> 00:13:51.166 A:middle
and j starts at the
beginning, I've already compared

00:13:51.166 --> 00:13:53.556 A:middle
that when i was at the
beginning and j was at the end.

00:13:53.946 --> 00:13:55.656 A:middle
So that's kind of silly
to have to do that.

00:13:55.836 --> 00:13:58.256 A:middle
So instead you could choose
to start the inner for loop

00:13:58.436 --> 00:14:00.816 A:middle
at i plus 1 for example,
and you eliminate half

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:58.436 --> 00:14:00.816 A:middle
at i plus 1 for example,
and you eliminate half

00:14:00.816 --> 00:14:01.676 A:middle
of your comparisons.

00:14:01.916 --> 00:14:02.856 A:middle
That's great, that's
a great win.

00:14:02.856 --> 00:14:04.536 A:middle
So now we're to N
squared over 2,

00:14:05.146 --> 00:14:06.306 A:middle
but it's still N squared growth.

00:14:06.306 --> 00:14:09.186 A:middle
So the key to this is
although it's now much faster

00:14:09.336 --> 00:14:11.176 A:middle
for a given input
size, it's still going

00:14:11.176 --> 00:14:12.716 A:middle
to have the same
growth properties:

00:14:12.716 --> 00:14:15.506 A:middle
as you add one more object,
or one more item to the array,

00:14:15.796 --> 00:14:17.416 A:middle
you're going to add
N comparisons.

00:14:17.736 --> 00:14:19.636 A:middle
That's the important thing
from this, so order N squared.

00:14:20.336 --> 00:14:22.596 A:middle
OK. So, calculating complexity.

00:14:23.006 --> 00:14:25.276 A:middle
We've seen that you can
combine these order functions.

00:14:25.276 --> 00:14:28.156 A:middle
For the N squared example I just
showed, we have two for loops

00:14:28.326 --> 00:14:30.926 A:middle
and each of those is order N,
and we have nested complexities,

00:14:30.926 --> 00:14:33.336 A:middle
we multiply those together,
N times N, we get N squared.

00:14:33.726 --> 00:14:35.256 A:middle
When you have sequential
complexities,

00:14:35.256 --> 00:14:37.736 A:middle
we add those together and
then we take the largest term.

00:14:37.736 --> 00:14:40.306 A:middle
So for example, this function
would reduce to N squared.

00:14:40.656 --> 00:14:42.626 A:middle
We have one N squared
call, and two N,

00:14:42.836 --> 00:14:45.056 A:middle
and three that are constant
time, but all we care

00:14:45.056 --> 00:14:46.856 A:middle
about it the N squared,
nothing else,

00:14:46.856 --> 00:14:48.296 A:middle
because that's the
growth of this function.

00:14:48.486 --> 00:14:50.526 A:middle
OK. So we've seen
that with source code.

00:14:50.846 --> 00:14:53.066 A:middle
However, sometimes you may not
have access to the source code,

00:14:53.066 --> 00:14:56.536 A:middle
or not be aware of what work
it's doing, and in such cases,

00:14:56.536 --> 00:14:57.526 A:middle
you can often estimate.

00:14:58.096 --> 00:14:59.796 A:middle
You can consider what the
code would have to do,

00:14:59.796 --> 00:15:01.426 A:middle
what kind of work it's
trying to accomplish,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.796 --> 00:15:01.426 A:middle
what kind of work it's
trying to accomplish,

00:15:01.656 --> 00:15:03.176 A:middle
and another complementary
alternative is

00:15:03.176 --> 00:15:04.686 A:middle
to profile with Instruments.

00:15:04.786 --> 00:15:07.586 A:middle
This can be a great way to find
performance issues in your code.

00:15:07.586 --> 00:15:09.126 A:middle
There are many sessions
from previous years

00:15:09.126 --> 00:15:11.106 A:middle
about using Instruments,
and in fact,

00:15:11.106 --> 00:15:15.336 A:middle
Xcode 5 as you saw earlier this
week introduces new debug gauges

00:15:15.336 --> 00:15:17.376 A:middle
including memory and CPU
use that can help you

00:15:17.596 --> 00:15:18.936 A:middle
with identifying
these kind of issues.

00:15:19.956 --> 00:15:22.376 A:middle
Now, some APIs may
appear to be very similar

00:15:22.666 --> 00:15:23.976 A:middle
but it's important
not to confuse them

00:15:23.976 --> 00:15:25.706 A:middle
when you're estimating, just
look at the name and say, "Oh,

00:15:25.706 --> 00:15:27.146 A:middle
I know what that is"
because of the name.

00:15:27.146 --> 00:15:29.496 A:middle
For example, we have
a containsObject API

00:15:29.496 --> 00:15:31.216 A:middle
on both NSArray and NSSet.

00:15:31.576 --> 00:15:33.626 A:middle
But it would be folly to
assume that they're the same.

00:15:33.706 --> 00:15:35.836 A:middle
So let's look at NSArray first.

00:15:35.836 --> 00:15:37.406 A:middle
It's containsObject,
we want to see

00:15:37.406 --> 00:15:39.346 A:middle
if a given object appears
anywhere in the array.

00:15:39.996 --> 00:15:40.866 A:middle
What work does it do?

00:15:41.376 --> 00:15:42.186 A:middle
Well, in this case,

00:15:42.186 --> 00:15:44.316 A:middle
the documentation actually
tells us explicitly

00:15:44.586 --> 00:15:47.316 A:middle
that it sends the isEqual
message to each object

00:15:47.316 --> 00:15:49.496 A:middle
in the array until one
of them returns true,

00:15:49.496 --> 00:15:51.076 A:middle
or it reaches the
end of the array.

00:15:51.546 --> 00:15:52.816 A:middle
OK, so it goes through
each object.

00:15:52.816 --> 00:15:54.766 A:middle
That certainly sounds
like order N complexity,

00:15:54.956 --> 00:15:56.436 A:middle
and that's certainly
a valid assumption,

00:15:56.436 --> 00:15:57.926 A:middle
I think that that's
pretty reasonable.

00:15:58.446 --> 00:15:59.976 A:middle
Now, we may think, well, what

00:15:59.976 --> 00:16:01.776 A:middle
if I can enumerate
these concurrently

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:59.976 --> 00:16:01.776 A:middle
if I can enumerate
these concurrently

00:16:01.776 --> 00:16:02.676 A:middle
and compare the objects?

00:16:02.676 --> 00:16:04.106 A:middle
That would be sort of a win.

00:16:04.416 --> 00:16:07.146 A:middle
And it would, it would reduce
it by a constant factor

00:16:07.146 --> 00:16:09.306 A:middle
but it would still
be a linear operation

00:16:09.466 --> 00:16:10.196 A:middle
with the size of the array.

00:16:10.986 --> 00:16:13.166 A:middle
OK. So let's see NSSet.

00:16:13.766 --> 00:16:16.486 A:middle
NSSet also has a containsObject,
it has the same name.

00:16:16.486 --> 00:16:17.996 A:middle
I give it an object,
it does the same thing:

00:16:17.996 --> 00:16:19.576 A:middle
it tells me whether it's
in the collection or not.

00:16:20.276 --> 00:16:22.356 A:middle
It looks just like the one
that we just saw in NSArray.

00:16:22.356 --> 00:16:23.886 A:middle
Is it also order N?

00:16:24.046 --> 00:16:24.996 A:middle
You might assume
that it would be.

00:16:25.656 --> 00:16:28.246 A:middle
However, it's actually
order 1, it's constant time.

00:16:28.326 --> 00:16:29.696 A:middle
Regardless of the
size of the set,

00:16:29.696 --> 00:16:32.806 A:middle
containsObject is always
really fast, that's great.

00:16:33.636 --> 00:16:35.966 A:middle
There's a caveat, please don't
go start replacing NSArray

00:16:35.966 --> 00:16:38.286 A:middle
with NSSet everywhere in
your code because it's fast.

00:16:38.476 --> 00:16:40.256 A:middle
There's context to
understand about why this is

00:16:40.256 --> 00:16:41.266 A:middle
and if it will work for you.

00:16:41.266 --> 00:16:45.316 A:middle
So, the reason that it's faster
is it must be doing less work.

00:16:45.666 --> 00:16:48.336 A:middle
It's doing the same amount
of work, roughly speaking,

00:16:48.336 --> 00:16:50.046 A:middle
regardless of how
large my collection is.

00:16:50.046 --> 00:16:51.136 A:middle
So we'll talk about that.

00:16:51.406 --> 00:16:53.426 A:middle
The reason that this is is
something called hashing.

00:16:53.516 --> 00:16:55.606 A:middle
We'll talk about
hash-based organization.

00:16:55.706 --> 00:17:00.816 A:middle
So, NSSet uses a hash table for
storage, as does NSDictionary.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:55.706 --> 00:17:00.816 A:middle
So, NSSet uses a hash table for
storage, as does NSDictionary.

00:17:02.156 --> 00:17:04.665 A:middle
Every object has a
deterministic hash value.

00:17:04.665 --> 00:17:06.326 A:middle
You may have seen
the hash method.

00:17:06.326 --> 00:17:08.726 A:middle
This is defined on NSObject--
we'll talk about in detail--

00:17:09.406 --> 00:17:12.156 A:middle
and it returns an unsigned
integer value that you can use

00:17:12.226 --> 00:17:13.746 A:middle
to store this object
in a hash table.

00:17:14.376 --> 00:17:16.715 A:middle
And equal objects should
always have the same hash;

00:17:16.796 --> 00:17:20.316 A:middle
we'll talk about this in more
detail and give examples.

00:17:20.316 --> 00:17:23.006 A:middle
When in a hash table, objects
are grouped into "buckets",

00:17:23.175 --> 00:17:26.965 A:middle
parts of the array based on
the hash that they provide.

00:17:27.326 --> 00:17:30.666 A:middle
And the structure has a hash
function that takes a hash

00:17:30.666 --> 00:17:31.946 A:middle
and maps it to a given bucket.

00:17:32.126 --> 00:17:34.646 A:middle
It can decide that this range of
hashes goes in the first bucket,

00:17:34.646 --> 00:17:36.626 A:middle
and this one, and so on,
and it can divide those up.

00:17:36.626 --> 00:17:38.396 A:middle
And the goal of this
hash function is

00:17:38.396 --> 00:17:40.776 A:middle
to achieve uniform
distribution, so that you have

00:17:40.776 --> 00:17:42.116 A:middle
about the same number of objects

00:17:42.116 --> 00:17:43.466 A:middle
in all the buckets
in the hash table.

00:17:44.666 --> 00:17:48.156 A:middle
When you achieve this, lookup
in a hash table really only has

00:17:48.196 --> 00:17:50.146 A:middle
to consider the objects that
are in a particular bucket.

00:17:50.146 --> 00:17:52.306 A:middle
It knows if an object is
going to be there it will be

00:17:52.306 --> 00:17:55.586 A:middle
in this bucket, and it can check
isEqual on only a few objects,

00:17:55.636 --> 00:17:57.046 A:middle
or none at all if there's
none in the bucket.

00:17:57.246 --> 00:17:58.136 A:middle
This is an obvious win.

00:17:58.136 --> 00:18:00.636 A:middle
If you have an array that's a
thousand objects, you may have

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:58.136 --> 00:18:00.636 A:middle
If you have an array that's a
thousand objects, you may have

00:18:00.636 --> 00:18:03.336 A:middle
to check up to a thousand items
in order to see if it's there.

00:18:03.336 --> 00:18:05.616 A:middle
But with a set, you may have
to check only a handful.

00:18:05.836 --> 00:18:06.236 A:middle
This is great.

00:18:06.386 --> 00:18:09.236 A:middle
So let me give you a concrete
example with an animation here.

00:18:09.236 --> 00:18:11.836 A:middle
Say we have a hash function and
we have a hash table we're going

00:18:11.836 --> 00:18:12.726 A:middle
to store some objects in.

00:18:13.126 --> 00:18:15.006 A:middle
Let's say that we want
to store the names

00:18:15.006 --> 00:18:17.406 A:middle
of all Apple CEOs
past and present.

00:18:17.446 --> 00:18:19.156 A:middle
So let's start off
with Tim Cook.

00:18:19.156 --> 00:18:21.566 A:middle
We run this through our hash
function, and it determines

00:18:21.766 --> 00:18:23.776 A:middle
that Tim Cook by the
hash belongs in bucket 2.

00:18:23.886 --> 00:18:24.686 A:middle
Great, so we set him there.

00:18:25.386 --> 00:18:27.416 A:middle
We add Steve Jobs and
that gets determined to go

00:18:27.416 --> 00:18:29.076 A:middle
in bucket 0, great, no problem.

00:18:29.126 --> 00:18:31.576 A:middle
Now we're going to
add Gil Amelio,

00:18:31.906 --> 00:18:34.056 A:middle
and our hash function
decides that it goes

00:18:34.056 --> 00:18:35.376 A:middle
in the same bucket
as Steve Jobs.

00:18:35.376 --> 00:18:36.816 A:middle
We have a collision
in our hash table,

00:18:37.156 --> 00:18:39.326 A:middle
rather unfortunate
and somewhat awkward.

00:18:40.576 --> 00:18:43.346 A:middle
[laughter] In order to see if
we should insert this object,

00:18:43.556 --> 00:18:45.656 A:middle
we have to compare, so we
check isEqual, and in fact,

00:18:45.946 --> 00:18:47.846 A:middle
we see that Steve
Jobs is not equal

00:18:47.846 --> 00:18:49.406 A:middle
to Gil Amelio, thank goodness.

00:18:50.226 --> 00:18:53.216 A:middle
And so what happens
is we move one aside

00:18:53.216 --> 00:18:54.026 A:middle
and we chain these together,

00:18:54.026 --> 00:18:56.386 A:middle
they both occupy the
same bucket, great.

00:18:56.936 --> 00:18:58.046 A:middle
Now we add Michael Spindler,

00:18:58.166 --> 00:18:59.996 A:middle
no collision here,
goes into bucket 5.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:00.326 --> 00:19:02.606 A:middle
We add John Sculley, and
once again we get a hash

00:19:02.606 --> 00:19:03.326 A:middle
table collision.

00:19:03.326 --> 00:19:06.036 A:middle
So the hash function decides
it goes in the same place.

00:19:06.036 --> 00:19:07.236 A:middle
So once again, we compare each

00:19:07.236 --> 00:19:09.096 A:middle
of these objects to
see is this equal.

00:19:09.346 --> 00:19:11.806 A:middle
They are not equal, so we
move them aside and we stick

00:19:11.806 --> 00:19:12.576 A:middle
that in the same bucket.

00:19:12.866 --> 00:19:14.816 A:middle
So, this is all well and
good, except you'll notice

00:19:14.856 --> 00:19:17.546 A:middle
that now the majority of my
objects are all in one bucket

00:19:17.546 --> 00:19:19.316 A:middle
in the hash table, and half

00:19:19.316 --> 00:19:21.406 A:middle
of my hash table is completely
empty, I'm not using it.

00:19:21.646 --> 00:19:23.296 A:middle
This is obviously non-optimal.

00:19:23.496 --> 00:19:25.526 A:middle
If I have some sort of simple
query to see if someone is

00:19:25.526 --> 00:19:28.606 A:middle
in the list for example, and my
hash function happens to map it

00:19:28.606 --> 00:19:30.946 A:middle
to the same bucket, I now
have to check through each

00:19:30.946 --> 00:19:33.516 A:middle
of those objects to see if
they're equal to Bill Gates

00:19:33.516 --> 00:19:34.856 A:middle
to determine no, he's
not in the table.

00:19:34.856 --> 00:19:37.186 A:middle
All right, so this is
definitely not optimal.

00:19:37.186 --> 00:19:39.766 A:middle
Fortunately, something
like NSSet can choose

00:19:39.966 --> 00:19:41.696 A:middle
to optimize the hash
function on the fly.

00:19:41.696 --> 00:19:43.756 A:middle
If it realizes that your
performance is not as good

00:19:43.756 --> 00:19:46.286 A:middle
as you could expect, it
reserves the right to be able

00:19:46.286 --> 00:19:48.936 A:middle
to move objects around, to
change the hash function

00:19:48.936 --> 00:19:50.086 A:middle
and redistribute them evenly.

00:19:50.326 --> 00:19:51.796 A:middle
So here we're in a
much better situation

00:19:51.916 --> 00:19:54.166 A:middle
and our lookups are restored
to being really fast.

00:19:54.616 --> 00:19:55.686 A:middle
OK, great.

00:19:56.396 --> 00:19:58.276 A:middle
So how can you participate
in this?

00:19:58.336 --> 00:20:01.706 A:middle
Defining your identity for your
object is how you take part

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:58.336 --> 00:20:01.706 A:middle
Defining your identity for your
object is how you take part

00:20:01.706 --> 00:20:03.486 A:middle
of this hash-based identity.

00:20:03.486 --> 00:20:06.796 A:middle
So NSObject, as I mentioned,
defines an isEqual method

00:20:06.796 --> 00:20:09.086 A:middle
and a hash method, and
they're functionally equivalent

00:20:09.086 --> 00:20:11.586 A:middle
to comparing the pointers,
the object addresses

00:20:11.586 --> 00:20:12.996 A:middle
for these two objects,

00:20:12.996 --> 00:20:14.766 A:middle
and returning just
the address itself.

00:20:15.976 --> 00:20:17.936 A:middle
Now, Apple-provided subclasses

00:20:17.936 --> 00:20:19.876 A:middle
of NSObject will override
this as necessary.

00:20:19.876 --> 00:20:23.076 A:middle
For example, NSString has its
own hash, NSDate, NSNumber

00:20:23.076 --> 00:20:26.976 A:middle
and so on, there's a variety
that do this, and in fact,

00:20:26.976 --> 00:20:29.926 A:middle
arrays, and sets themselves also
have their own hash and isEqual.

00:20:30.676 --> 00:20:33.326 A:middle
Custom objects that you
create should choose

00:20:33.326 --> 00:20:34.236 A:middle
to override these methods

00:20:34.236 --> 00:20:36.626 A:middle
if pointer quality is not
sufficient for your needs.

00:20:36.626 --> 00:20:39.096 A:middle
For example, say that you
have two person objects

00:20:39.096 --> 00:20:40.536 A:middle
and you want them to
be considered equal

00:20:40.536 --> 00:20:43.436 A:middle
if the Social Security Number
is the same for both of them,

00:20:43.436 --> 00:20:44.266 A:middle
something to that effect.

00:20:44.666 --> 00:20:45.836 A:middle
And you can learn a
lot more about this--

00:20:45.836 --> 00:20:48.606 A:middle
this will be in the slides
for reference afterward--

00:20:48.856 --> 00:20:52.416 A:middle
about object comparison and
implementing these methods.

00:20:52.636 --> 00:20:54.336 A:middle
There are a few rules of
the road if you're going

00:20:54.336 --> 00:20:55.786 A:middle
to implement these
on your own object.

00:20:56.396 --> 00:20:59.346 A:middle
If isEqual returns
true for two objects,

00:20:59.586 --> 00:21:02.006 A:middle
then the hash must be the
same for both of these.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.586 --> 00:21:02.006 A:middle
then the hash must be the
same for both of these.

00:21:02.456 --> 00:21:04.286 A:middle
This is critical because
if you have two objects

00:21:04.286 --> 00:21:06.036 A:middle
that should be the same
but have different hashes,

00:21:06.306 --> 00:21:08.386 A:middle
they could get put in
different places in a hash table

00:21:08.556 --> 00:21:10.096 A:middle
and you won't be able to
find them when you're looking

00:21:10.096 --> 00:21:11.846 A:middle
for them, you'll get
incorrect results.

00:21:12.136 --> 00:21:14.766 A:middle
However, the same hash value
does not necessarily imply

00:21:15.026 --> 00:21:16.166 A:middle
that isEqual must be true.

00:21:16.706 --> 00:21:18.526 A:middle
You can have two objects
that have the same hash value

00:21:18.526 --> 00:21:20.416 A:middle
but isEqual will
be the tie breaker.

00:21:21.116 --> 00:21:23.406 A:middle
If you decide to
implement isEqual,

00:21:23.726 --> 00:21:26.326 A:middle
you really should also define
hash for this very reason:

00:21:26.486 --> 00:21:28.616 A:middle
so that you can guarantee
that they are the same.

00:21:28.796 --> 00:21:30.436 A:middle
Now, a good hash, as
you're implementing one,

00:21:30.596 --> 00:21:31.876 A:middle
should minimize collisions.

00:21:32.286 --> 00:21:35.006 A:middle
A poor hash will really cause
your performance to tank.

00:21:35.346 --> 00:21:36.626 A:middle
All right, for example,
in the worst case,

00:21:36.626 --> 00:21:38.066 A:middle
let's say that you're
like, "I don't know

00:21:38.066 --> 00:21:40.056 A:middle
about this hash thing,
I'm just going to return 1

00:21:40.056 --> 00:21:41.276 A:middle
for all of my objects."

00:21:41.646 --> 00:21:43.566 A:middle
They all have the same hash
which means they're all going

00:21:43.566 --> 00:21:45.256 A:middle
to go to the same
bucket in a hash table,

00:21:45.516 --> 00:21:47.826 A:middle
which means you've now turned
an NSSet into an NSArray

00:21:48.086 --> 00:21:49.176 A:middle
and killed your performance.

00:21:50.366 --> 00:21:51.586 A:middle
That's the opposite
of what we want.

00:21:52.156 --> 00:21:54.676 A:middle
So we want to be careful
about that and we'll talk

00:21:54.676 --> 00:21:57.076 A:middle
about that in just a moment.

00:21:57.356 --> 00:22:00.396 A:middle
One other key important thing is
that when you have hash lookup,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:57.356 --> 00:22:00.396 A:middle
One other key important thing is
that when you have hash lookup,

00:22:00.396 --> 00:22:02.426 A:middle
your hashes really should
be stable and predictable.

00:22:02.646 --> 00:22:04.736 A:middle
If your hash tends
to change while it's

00:22:04.736 --> 00:22:06.166 A:middle
in the collection,
it's really bad.

00:22:06.166 --> 00:22:08.006 A:middle
You're not going to
be able to find it.

00:22:08.006 --> 00:22:09.066 A:middle
So there are two options really.

00:22:09.066 --> 00:22:11.316 A:middle
The first is not to modify
and object in a collection.

00:22:11.316 --> 00:22:14.516 A:middle
If you have a mutable string and
you've put it in as the key--

00:22:14.516 --> 00:22:17.676 A:middle
or an object in a set, for
example, and you change

00:22:17.676 --> 00:22:19.436 A:middle
that string, the hash will
change and you're going

00:22:19.436 --> 00:22:21.986 A:middle
to have all sorts of hilarity
and hair-pulling that ensues.

00:22:22.436 --> 00:22:25.716 A:middle
The second option is to not
base your hash on mutable state.

00:22:25.716 --> 00:22:26.786 A:middle
This may be an option for you,

00:22:26.786 --> 00:22:28.106 A:middle
so that's something
to consider as well.

00:22:28.546 --> 00:22:30.166 A:middle
So let me show you a
sample implementation.

00:22:30.456 --> 00:22:32.986 A:middle
You all have the WWDC app
on your phones and iPads,

00:22:33.296 --> 00:22:34.646 A:middle
and there is a news object,

00:22:34.886 --> 00:22:36.716 A:middle
as you see in the news
update throughout the week,

00:22:36.716 --> 00:22:38.266 A:middle
we have these news
objects to represent that.

00:22:38.266 --> 00:22:39.716 A:middle
This is a simplified
representation.

00:22:39.716 --> 00:22:41.856 A:middle
Here we're just looking it
has a title and a time stamp.

00:22:41.936 --> 00:22:44.286 A:middle
So I want to focus on
these two implementations.

00:22:44.286 --> 00:22:47.096 A:middle
Now, for hash, you see that we
need to return some hash value

00:22:47.096 --> 00:22:49.766 A:middle
and we're just returning the
hash that NSString provides us

00:22:49.766 --> 00:22:50.646 A:middle
from this title property.

00:22:51.396 --> 00:22:54.026 A:middle
However, if we have
two news items

00:22:54.026 --> 00:22:56.276 A:middle
that may have the same title
and thus have the same hash,

00:22:56.516 --> 00:22:58.536 A:middle
we can break the tie
by calling isEqual

00:22:58.816 --> 00:23:01.046 A:middle
and compare both the
title and the time stamp,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.816 --> 00:23:01.046 A:middle
and compare both the
title and the time stamp,

00:23:01.136 --> 00:23:02.786 A:middle
and we also check to see
if it's the same object.

00:23:02.876 --> 00:23:05.866 A:middle
So, there are a lot more
examples of things like this

00:23:05.916 --> 00:23:07.596 A:middle
in the documentation
that I encourage you

00:23:07.866 --> 00:23:08.726 A:middle
to check out afterward.

00:23:09.486 --> 00:23:14.236 A:middle
OK. So next I want
to talk to you

00:23:14.346 --> 00:23:15.806 A:middle
about data structures
performance,

00:23:15.866 --> 00:23:16.936 A:middle
kind of applying
what we've learned.

00:23:17.146 --> 00:23:18.466 A:middle
We've got the math-y
part out of the way

00:23:18.466 --> 00:23:20.506 A:middle
about Big O complexity
and hashes and so on.

00:23:20.506 --> 00:23:21.706 A:middle
So I'm going to talk
to you a little

00:23:21.706 --> 00:23:23.186 A:middle
but about choosing
data structures

00:23:23.186 --> 00:23:25.376 A:middle
and the performance
characteristics about them.

00:23:25.376 --> 00:23:26.586 A:middle
So let's start with an analogy.

00:23:26.586 --> 00:23:28.586 A:middle
Say that you have books
that you need to organize.

00:23:29.016 --> 00:23:29.996 A:middle
There's a lot of different ways

00:23:29.996 --> 00:23:31.526 A:middle
that you could choose
to organize books.

00:23:32.476 --> 00:23:34.566 A:middle
Say you could sort them
by topic or author,

00:23:34.786 --> 00:23:36.066 A:middle
title, even size or color.

00:23:36.066 --> 00:23:38.036 A:middle
You can choose an arbitrary
characteristic and choose

00:23:38.036 --> 00:23:38.836 A:middle
to sort them that way.

00:23:39.156 --> 00:23:41.306 A:middle
Everyone does this with their
CD collections, and, well,

00:23:41.416 --> 00:23:42.766 A:middle
iTunes has solved
that problem now.

00:23:43.356 --> 00:23:44.786 A:middle
But everyone has their
own preferred way

00:23:44.956 --> 00:23:46.166 A:middle
to sort things and
organize them.

00:23:46.906 --> 00:23:49.516 A:middle
However, each of these options
makes some things really easy

00:23:49.836 --> 00:23:50.726 A:middle
and others difficult.

00:23:50.946 --> 00:23:52.686 A:middle
Say that you've chosen to
organize alphabetically

00:23:52.686 --> 00:23:54.406 A:middle
by author and then
later you want

00:23:54.406 --> 00:23:56.436 A:middle
to find all the New York
Times' best sellers,

00:23:56.636 --> 00:23:58.966 A:middle
or you want to find children's
books, those are scattered all

00:23:58.996 --> 00:24:01.396 A:middle
over in your collection and
it's not easy to look them

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:58.996 --> 00:24:01.396 A:middle
over in your collection and
it's not easy to look them

00:24:01.396 --> 00:24:02.406 A:middle
up when they're sorted
by author.

00:24:02.456 --> 00:24:03.516 A:middle
So this is something
to be aware of.

00:24:03.516 --> 00:24:06.456 A:middle
It's also important to plan
for scale when appropriate

00:24:06.456 --> 00:24:07.646 A:middle
as you're choosing
your data structures.

00:24:07.646 --> 00:24:10.286 A:middle
For example, it's a
completely different thing

00:24:10.286 --> 00:24:12.606 A:middle
to organize a small bookshelf
here where you can say,

00:24:12.606 --> 00:24:13.916 A:middle
"Go find the small green book"

00:24:14.266 --> 00:24:16.096 A:middle
and instantly you've all
found it because it's small,

00:24:16.756 --> 00:24:18.766 A:middle
versus organizing a
really large library.

00:24:18.986 --> 00:24:21.266 A:middle
Things that will work at small
scale may not necessarily

00:24:21.266 --> 00:24:22.806 A:middle
when you get to large
amounts of data.

00:24:23.446 --> 00:24:25.416 A:middle
You have to have a
more intelligent way

00:24:25.416 --> 00:24:26.186 A:middle
to organize things.

00:24:26.236 --> 00:24:28.076 A:middle
So, choosing a strategy,

00:24:28.366 --> 00:24:30.376 A:middle
every data structure
has some tradeoffs.

00:24:30.376 --> 00:24:32.256 A:middle
It has things that it's best
at and things that is not

00:24:32.256 --> 00:24:34.166 A:middle
as well suited for, and
you want to use the one

00:24:34.166 --> 00:24:35.226 A:middle
that best fits your needs.

00:24:35.656 --> 00:24:37.906 A:middle
When you choose a data structure
that's not the best fit,

00:24:37.906 --> 00:24:39.736 A:middle
it really hurts your
performance.

00:24:39.736 --> 00:24:41.686 A:middle
For example, using a
hammer to drive in a screw,

00:24:41.916 --> 00:24:43.666 A:middle
not the ideal tool
for the situation.

00:24:44.026 --> 00:24:45.336 A:middle
Even if you have the right tool,

00:24:45.536 --> 00:24:46.926 A:middle
you may not be using
it optimally.

00:24:47.116 --> 00:24:49.256 A:middle
If you have a hammer with
a nail and you just pressed

00:24:49.256 --> 00:24:53.156 A:middle
down really hardly-- as hard as
you can, it's not going to be

00:24:53.156 --> 00:24:55.086 A:middle
as effective as whacking
it really hard, right?

00:24:55.246 --> 00:24:57.026 A:middle
So, it's really important
to choose the right thing

00:24:57.026 --> 00:24:58.716 A:middle
for your needs and
use it correctly.

00:24:58.716 --> 00:25:01.306 A:middle
And we encourage
you to always prefer

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:58.716 --> 00:25:01.306 A:middle
And we encourage
you to always prefer

00:25:01.306 --> 00:25:03.306 A:middle
to use the built-in
API whenever possible.

00:25:03.636 --> 00:25:04.966 A:middle
The collections that
are available

00:25:04.966 --> 00:25:06.996 A:middle
in the Foundation framework
are extensively tested.

00:25:06.996 --> 00:25:08.246 A:middle
They've been around for years.

00:25:08.666 --> 00:25:10.726 A:middle
We use them just as much
as you do, and we want them

00:25:10.726 --> 00:25:13.006 A:middle
to be really, really fast
just as much as you do.

00:25:13.816 --> 00:25:17.646 A:middle
These also-- using the built-in
frameworks also guarantees

00:25:17.856 --> 00:25:20.136 A:middle
that in the future when we have
improvements, such as you'll see

00:25:20.136 --> 00:25:21.816 A:middle
in OS X Mavericks and in iOS 7,

00:25:21.816 --> 00:25:24.886 A:middle
that you will also get
those improvements for free.

00:25:25.116 --> 00:25:27.776 A:middle
Your apps will suddenly
become faster, which is great.

00:25:28.816 --> 00:25:31.596 A:middle
So, getting down to actually
choosing a data structure,

00:25:31.596 --> 00:25:33.676 A:middle
there's a few things you
have to know for context.

00:25:33.676 --> 00:25:35.246 A:middle
The first is knowing
what you need.

00:25:36.146 --> 00:25:37.946 A:middle
Is it important that my
objects have an order?

00:25:38.436 --> 00:25:40.026 A:middle
Will I allow duplicates
in my collection?

00:25:40.366 --> 00:25:42.746 A:middle
Do I have to be able to add or
remove objects, have it mutable?

00:25:43.346 --> 00:25:44.566 A:middle
What operations are
most critical

00:25:44.566 --> 00:25:45.826 A:middle
for me to be really fast?

00:25:45.826 --> 00:25:47.226 A:middle
What am I going to be
doing with my structure?

00:25:47.406 --> 00:25:49.326 A:middle
And even where will my
data come from and go to?

00:25:49.706 --> 00:25:51.116 A:middle
For example, you may
choose differently

00:25:51.336 --> 00:25:53.036 A:middle
if your data will
come from user input,

00:25:53.266 --> 00:25:55.376 A:middle
or from a property list
file, or Core Data,

00:25:55.766 --> 00:25:57.236 A:middle
or JSON over the web or so on.

00:25:57.556 --> 00:25:59.376 A:middle
There's certain things that
may change your decision.

00:25:59.376 --> 00:26:01.786 A:middle
And the second thing is
to know what to expect

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.376 --> 00:26:01.786 A:middle
And the second thing is
to know what to expect

00:26:01.936 --> 00:26:03.686 A:middle
from your collection, which
we'll go into in detail.

00:26:03.686 --> 00:26:05.316 A:middle
There are certain things
that are broadly true

00:26:05.316 --> 00:26:06.386 A:middle
across all of our collections.

00:26:06.436 --> 00:26:08.096 A:middle
For example, getting
the count of items

00:26:08.096 --> 00:26:10.886 A:middle
in a collection is always really
fast, that's constant time.

00:26:10.886 --> 00:26:12.826 A:middle
We cache that for you because
that's a common operation.

00:26:13.356 --> 00:26:14.756 A:middle
Enumerating through
all the objects

00:26:14.756 --> 00:26:17.416 A:middle
in a collection is generally
linear time, because you have

00:26:17.416 --> 00:26:18.816 A:middle
to visit each of N objects.

00:26:18.966 --> 00:26:21.486 A:middle
Even if you have a set or
dictionary, lookup is fast

00:26:21.556 --> 00:26:22.506 A:middle
but going through
each of them is going

00:26:22.506 --> 00:26:23.796 A:middle
to take the same amount of time.

00:26:23.796 --> 00:26:26.076 A:middle
And other operations will
vary by the collection.

00:26:26.076 --> 00:26:28.856 A:middle
So, before I go over
individual data structures,

00:26:28.856 --> 00:26:30.856 A:middle
I want to share just a
note about mutability.

00:26:31.166 --> 00:26:33.236 A:middle
The best guideline with
mutability, we got a lot

00:26:33.236 --> 00:26:35.816 A:middle
of questions about this, is
to use it when you need it,

00:26:35.886 --> 00:26:37.706 A:middle
when it's semantically
correct, when you're adding

00:26:37.706 --> 00:26:39.156 A:middle
and removing objects
from a collection.

00:26:39.896 --> 00:26:41.606 A:middle
Immutable collections
do have benefits.

00:26:41.666 --> 00:26:44.426 A:middle
If you don't need mutability,
it can be to your benefit

00:26:44.426 --> 00:26:47.246 A:middle
to use an immutable
collection instead.

00:26:47.246 --> 00:26:50.946 A:middle
Foremost among these
benefits is thread safety.

00:26:51.186 --> 00:26:54.316 A:middle
If a collection is
immutable such as an NSArray,

00:26:54.316 --> 00:26:56.636 A:middle
you know that no other thread
can add or remove objects,

00:26:56.636 --> 00:26:58.766 A:middle
and you don't have to worry
about exceptions or crashes.

00:26:59.626 --> 00:27:02.056 A:middle
Also, there are memory and speed
optimizations that are possible

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:59.626 --> 00:27:02.056 A:middle
Also, there are memory and speed
optimizations that are possible

00:27:02.216 --> 00:27:03.836 A:middle
with immutable collections
because we know

00:27:03.836 --> 00:27:05.026 A:middle
that they're not going
to change in size.

00:27:05.256 --> 00:27:07.486 A:middle
We can allocate just the
exact right amount of memory

00:27:07.486 --> 00:27:08.956 A:middle
for the objects that
you've provided.

00:27:10.516 --> 00:27:14.796 A:middle
Now, another option is to make a
collection immutable afterwards.

00:27:15.236 --> 00:27:17.906 A:middle
Make a copy of it that you
can use for quick reference

00:27:17.906 --> 00:27:19.906 A:middle
and get those benefits,
but still be able to build

00:27:19.906 --> 00:27:21.856 A:middle
up your collection
with add and remove.

00:27:22.416 --> 00:27:26.126 A:middle
And lastly, if you do use
mutability, it's often great

00:27:26.126 --> 00:27:27.426 A:middle
if you can help us to help you.

00:27:27.726 --> 00:27:29.516 A:middle
You know how your
collection is being used.

00:27:29.696 --> 00:27:32.416 A:middle
We design it for a broad
range of different uses,

00:27:32.636 --> 00:27:34.426 A:middle
and you know specifically what
you're going to do with it.

00:27:34.566 --> 00:27:35.936 A:middle
And there's times that
you can provide hints

00:27:35.936 --> 00:27:37.836 A:middle
that help us get you
the best performance.

00:27:37.836 --> 00:27:39.696 A:middle
One example is initializing
a collection

00:27:39.696 --> 00:27:40.866 A:middle
with initWithCapacity.

00:27:41.376 --> 00:27:43.206 A:middle
Now, what this does is
gives us kind of a hint

00:27:43.436 --> 00:27:45.526 A:middle
about how many objects
you're likely to store

00:27:45.736 --> 00:27:46.576 A:middle
in a given collection.

00:27:46.716 --> 00:27:49.626 A:middle
So for example, if you say "I'm
only going to store three items

00:27:49.626 --> 00:27:51.286 A:middle
in this mutable array
and add and remove them",

00:27:51.516 --> 00:27:53.106 A:middle
you can provide that
capacity up front

00:27:53.326 --> 00:27:54.576 A:middle
and we can optimize accordingly.

00:27:54.726 --> 00:27:58.006 A:middle
Now, don't-- It's not wise to
try to outsmart the collections

00:27:58.006 --> 00:28:00.076 A:middle
and ask for a really
large capacity.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:58.006 --> 00:28:00.076 A:middle
and ask for a really
large capacity.

00:28:00.336 --> 00:28:01.906 A:middle
The collections are
really finely tuned

00:28:01.906 --> 00:28:03.426 A:middle
and optimized to
take care of that.

00:28:03.706 --> 00:28:05.866 A:middle
And even if you do provide
the capacity hint up front,

00:28:06.086 --> 00:28:08.036 A:middle
the collection can
dynamically grow and shrink

00:28:08.036 --> 00:28:09.636 A:middle
as objects are added
and removed.

00:28:09.736 --> 00:28:11.716 A:middle
So this just provides us an
up front way to kind of get

00:28:11.716 --> 00:28:12.846 A:middle
in the ballpark of
what you need.

00:28:12.846 --> 00:28:16.046 A:middle
OK. So I'm going to go
on a quick tour of some

00:28:16.046 --> 00:28:20.176 A:middle
of the data structures
in Foundation,

00:28:20.176 --> 00:28:21.396 A:middle
some of the most
valuable players;

00:28:21.576 --> 00:28:22.736 A:middle
give you a brief
overview and talk

00:28:22.736 --> 00:28:24.826 A:middle
about their performance
characteristics.

00:28:24.826 --> 00:28:26.466 A:middle
First, NSArray and MutableArray.

00:28:26.726 --> 00:28:27.596 A:middle
You're all familiar with this.

00:28:27.596 --> 00:28:29.576 A:middle
It's a workhorse of
the Cocoa library.

00:28:30.516 --> 00:28:33.486 A:middle
It's an ordered collection,
it allows indexed access,

00:28:33.486 --> 00:28:35.326 A:middle
and you can have duplicate
objects in an array.

00:28:36.436 --> 00:28:38.416 A:middle
Operations that are
really fast are anything

00:28:38.416 --> 00:28:40.736 A:middle
that includes indexing:
objectAtIndex,

00:28:41.026 --> 00:28:42.466 A:middle
firstObject and lastObject.

00:28:42.756 --> 00:28:45.076 A:middle
Adding and removing
at either end

00:28:45.076 --> 00:28:47.316 A:middle
of a mutable array is
actually really fast as well.

00:28:47.506 --> 00:28:48.696 A:middle
This may come as a surprise;

00:28:49.016 --> 00:28:51.056 A:middle
adding at the end would seem
really fast, but you may think

00:28:51.056 --> 00:28:52.116 A:middle
that if you add at the
beginning you'd have

00:28:52.116 --> 00:28:53.206 A:middle
to shift everything over.

00:28:53.516 --> 00:28:56.136 A:middle
However, that tends to be
a common use case for a lot

00:28:56.136 --> 00:28:58.236 A:middle
of our developers, so
we've optimized that

00:28:58.506 --> 00:29:00.736 A:middle
and we've given the guarantee
that inserting at the front,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:58.506 --> 00:29:00.736 A:middle
and we've given the guarantee
that inserting at the front,

00:29:00.876 --> 00:29:03.056 A:middle
the very front of a mutable
array is also really fast.

00:29:03.116 --> 00:29:04.616 A:middle
So that's a great thing
to be aware of as well,

00:29:04.616 --> 00:29:06.576 A:middle
to not be afraid to
insert at the front.

00:29:06.616 --> 00:29:09.516 A:middle
Slower operations include
anything that involves search

00:29:09.516 --> 00:29:10.966 A:middle
and looking through
any of these indexes

00:29:11.026 --> 00:29:12.196 A:middle
as we've already
mentioned before.

00:29:12.486 --> 00:29:15.356 A:middle
Also, adding and removing at
an arbitrary index somewhere

00:29:15.496 --> 00:29:17.416 A:middle
in the middle of the array,
not at either of the ends,

00:29:17.566 --> 00:29:19.486 A:middle
would tend to be a
little bit slower.

00:29:19.486 --> 00:29:22.426 A:middle
One specialty operation I'd like
to call out is binary search.

00:29:22.646 --> 00:29:23.686 A:middle
If you're not familiar
with this,

00:29:23.686 --> 00:29:26.926 A:middle
binary search is a quick way
to narrow down your search.

00:29:27.216 --> 00:29:28.266 A:middle
There are a couple
pre-conditions.

00:29:28.266 --> 00:29:30.606 A:middle
You have to have some
sorted range of data.

00:29:30.606 --> 00:29:33.846 A:middle
So if I know that my array is
already sorted in ascending

00:29:33.846 --> 00:29:37.476 A:middle
or descending order, I could use
binary search to quickly narrow

00:29:37.476 --> 00:29:40.496 A:middle
down and cut out half of
the objects each time.

00:29:40.856 --> 00:29:43.846 A:middle
And this is a great win
because this is an order log N

00:29:44.066 --> 00:29:45.556 A:middle
operation, as compared
to order N.

00:29:45.556 --> 00:29:48.146 A:middle
If you remember from the graph,
order N was a line that goes

00:29:48.146 --> 00:29:49.466 A:middle
up at a 45-degree angle

00:29:49.576 --> 00:29:52.726 A:middle
and order log N stays
really close to the bottom.

00:29:52.726 --> 00:29:56.696 A:middle
It's got great performance
as your objects sizes scale.

00:29:57.446 --> 00:29:59.806 A:middle
Next is NSSet and NSMutableSet.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:00.546 --> 00:30:03.686 A:middle
This is an unordered collection,
it does not allow duplicates,

00:30:03.686 --> 00:30:05.996 A:middle
and it has hash-based lookup
as we discussed previously.

00:30:07.386 --> 00:30:09.556 A:middle
In sets, adding,
removing and searching

00:30:09.556 --> 00:30:10.986 A:middle
for objects are really fast,

00:30:11.076 --> 00:30:12.586 A:middle
precisely because of
the hash-based lookup.

00:30:13.186 --> 00:30:14.566 A:middle
Now, there are some
specialty operations

00:30:14.566 --> 00:30:16.076 A:middle
that are really convenient
on NSSet.

00:30:16.326 --> 00:30:18.286 A:middle
For example, set arithmetic.

00:30:18.286 --> 00:30:20.446 A:middle
If you think of a Venn diagram
where you've got two circles

00:30:20.446 --> 00:30:22.586 A:middle
that overlap, you can find
the intersection between them,

00:30:22.806 --> 00:30:24.356 A:middle
you can see if one is
completely contained

00:30:24.356 --> 00:30:25.126 A:middle
in the other, and so on.

00:30:25.376 --> 00:30:27.596 A:middle
And if you have mutable
sets, you can extend this

00:30:27.836 --> 00:30:31.186 A:middle
and intersect the set
and modify one set

00:30:31.546 --> 00:30:33.566 A:middle
to only contain the objects
that also appear in another set,

00:30:33.726 --> 00:30:35.546 A:middle
or minus set, or
union set and so on.

00:30:35.546 --> 00:30:37.006 A:middle
This can be really
convenient for merging

00:30:37.006 --> 00:30:39.256 A:middle
and separating different
collections of objects.

00:30:39.336 --> 00:30:40.066 A:middle
Good thing to be aware of.

00:30:40.736 --> 00:30:43.746 A:middle
Caveats with NSSet, when
you convert from an array

00:30:43.746 --> 00:30:47.236 A:middle
to an NSSet, you can do that
but you do lose your ordering

00:30:47.376 --> 00:30:49.626 A:middle
of the array, and you
lose any duplicates

00:30:49.626 --> 00:30:50.826 A:middle
that may appear in the array.

00:30:50.986 --> 00:30:52.336 A:middle
Those will be stripped
out with a set.

00:30:52.516 --> 00:30:55.516 A:middle
If you convert back to an array,
you may get a smaller array,

00:30:55.516 --> 00:30:57.626 A:middle
and you almost certainly get
one that's in a different order

00:30:57.626 --> 00:30:58.806 A:middle
that the one you passed in.

00:30:59.616 --> 00:31:02.196 A:middle
Related to this is that you
can't store a set directly

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:59.616 --> 00:31:02.196 A:middle
Related to this is that you
can't store a set directly

00:31:02.196 --> 00:31:04.276 A:middle
in a property list or
in JSON, as we'll talk

00:31:04.276 --> 00:31:06.326 A:middle
about in a little bit.

00:31:06.616 --> 00:31:10.166 A:middle
You can convert to an array and
back as you're reading them out,

00:31:10.316 --> 00:31:11.776 A:middle
but these are caveats
to be aware of.

00:31:12.286 --> 00:31:14.406 A:middle
A brief of note on NSCountedSet.

00:31:14.406 --> 00:31:16.526 A:middle
This is really a handy one that
many people are not aware of.

00:31:16.936 --> 00:31:18.686 A:middle
It's also unordered
just a like a set,

00:31:18.686 --> 00:31:20.046 A:middle
no duplicates and hash lookup.

00:31:20.546 --> 00:31:22.146 A:middle
It's a subclass of NSMutableSet,

00:31:22.146 --> 00:31:23.626 A:middle
so it has all the
same operations

00:31:23.626 --> 00:31:25.146 A:middle
and the same characteristics.

00:31:25.146 --> 00:31:28.076 A:middle
Its big trick though, is that it
tracks the net insertion count

00:31:28.076 --> 00:31:28.876 A:middle
of each object.

00:31:29.176 --> 00:31:32.346 A:middle
So, objects still only appear
once in a counted set, however,

00:31:32.346 --> 00:31:33.906 A:middle
if you insert the
same object again,

00:31:33.906 --> 00:31:36.186 A:middle
the count for that object
will increase to 2 and so on.

00:31:36.186 --> 00:31:37.646 A:middle
If you remove that
object, it decreases

00:31:37.856 --> 00:31:39.106 A:middle
and if it's removed it's at 0.

00:31:39.476 --> 00:31:41.306 A:middle
This can be really convenient
if you're trying to count

00:31:41.306 --> 00:31:44.876 A:middle
up occurrences of a particular
object, maybe words in text

00:31:44.876 --> 00:31:46.216 A:middle
or something like that.

00:31:46.506 --> 00:31:48.766 A:middle
It's kind of a histogram
binning type of thing,

00:31:49.006 --> 00:31:49.926 A:middle
so great thing to be aware of.

00:31:50.636 --> 00:31:52.646 A:middle
Next is NSDictionary
and NSMutableDictionary.

00:31:52.906 --> 00:31:54.166 A:middle
This you're also
very familiar with.

00:31:54.546 --> 00:31:57.696 A:middle
It's an unordered collection,
it has key value entries

00:31:57.886 --> 00:31:59.246 A:middle
to store those associated
together,

00:31:59.726 --> 00:32:01.216 A:middle
it has unique key values,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:59.726 --> 00:32:01.216 A:middle
it has unique key values,

00:32:01.296 --> 00:32:03.136 A:middle
and it uses hash lookup
just a like a set.

00:32:03.286 --> 00:32:07.576 A:middle
So, adding, removing and
searching are also really fast

00:32:07.576 --> 00:32:10.216 A:middle
in a dictionary, anything where
you're looking for an object

00:32:10.216 --> 00:32:12.206 A:middle
by the key, adding or
removing and searching.

00:32:13.026 --> 00:32:15.586 A:middle
Specialty operations, one thing
that's convenient is it has some

00:32:15.796 --> 00:32:17.706 A:middle
handy API for reading
and writing directly

00:32:17.706 --> 00:32:18.876 A:middle
from a property list file.

00:32:19.466 --> 00:32:21.586 A:middle
And also one other thing
that was added in 10.8

00:32:21.586 --> 00:32:23.846 A:middle
and iOS 6 is really handy.

00:32:23.846 --> 00:32:26.386 A:middle
If you have a mutable
array and you know up front

00:32:26.386 --> 00:32:29.456 A:middle
which keys will ever appear in
this mutable dictionary, sorry,

00:32:29.456 --> 00:32:31.906 A:middle
mutable dictionary, you
can provide a key set,

00:32:31.906 --> 00:32:33.466 A:middle
an array of those keys up front.

00:32:33.776 --> 00:32:35.396 A:middle
And there's a class
method on NSDictionary.

00:32:35.616 --> 00:32:36.596 A:middle
You give it an array of keys,

00:32:36.596 --> 00:32:38.786 A:middle
it will give you a
sharedKeySet object.

00:32:39.096 --> 00:32:41.886 A:middle
If you provide that when
creating an NSMutableDictionary,

00:32:42.266 --> 00:32:45.046 A:middle
it can create a really
optimal hash algorithm

00:32:45.046 --> 00:32:47.696 A:middle
for organizing those
particular keys.

00:32:47.696 --> 00:32:49.426 A:middle
It knows up front what's
likely to be there.

00:32:49.606 --> 00:32:52.086 A:middle
And it can be a great
situation if you need mutability

00:32:52.086 --> 00:32:54.126 A:middle
but you want speed and you
know the keys you're going

00:32:54.126 --> 00:32:55.446 A:middle
to have up front.

00:32:55.446 --> 00:32:58.536 A:middle
Caveats of NSDictionary, you're
probably familiar with the fact

00:32:58.536 --> 00:32:59.626 A:middle
that any keys that you provide

00:32:59.626 --> 00:33:01.996 A:middle
to NSDictionary are
going to be copied in.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:59.626 --> 00:33:01.996 A:middle
to NSDictionary are
going to be copied in.

00:33:02.376 --> 00:33:05.626 A:middle
They have to conform to
the NSCopying protocol.

00:33:06.186 --> 00:33:09.086 A:middle
And you should never mutate an
object that is a dictionary key.

00:33:09.406 --> 00:33:10.846 A:middle
The hash will change
very likely,

00:33:10.946 --> 00:33:12.686 A:middle
and you probably won't
be able to find it

00:33:12.686 --> 00:33:13.796 A:middle
and you'll get incorrect
results.

00:33:13.796 --> 00:33:16.826 A:middle
This is a major thing
to be aware of.

00:33:16.826 --> 00:33:17.666 A:middle
NSOrderedSet

00:33:17.666 --> 00:33:21.446 A:middle
and NSMutableOrderedSet
are an ordered collection,

00:33:21.446 --> 00:33:23.956 A:middle
similar to arrays, they don't
allow duplicates like a set,

00:33:23.956 --> 00:33:26.366 A:middle
and they support both index
and hash-based lookup.

00:33:26.716 --> 00:33:31.426 A:middle
This class was introduced
in iOS 5 and OS X 10.7.

00:33:31.426 --> 00:33:34.526 A:middle
And it's effectively across
between a set and array.

00:33:35.006 --> 00:33:36.286 A:middle
It's not a subclass
of either one,

00:33:36.286 --> 00:33:39.636 A:middle
although you can get an array
or set representation that--

00:33:39.636 --> 00:33:42.136 A:middle
one convenient thing about
these are they're live-updating.

00:33:42.386 --> 00:33:44.516 A:middle
So as objects are added or
removed to the mutable set,

00:33:44.516 --> 00:33:46.866 A:middle
those array and set
representations will be updated

00:33:46.866 --> 00:33:47.256 A:middle
as well.

00:33:48.046 --> 00:33:49.736 A:middle
Now, a caveat of this
is that you're going

00:33:49.736 --> 00:33:50.886 A:middle
to have increased memory usage.

00:33:50.886 --> 00:33:53.546 A:middle
You can't get the best of
both worlds as a free lunch.

00:33:53.826 --> 00:33:55.726 A:middle
So because we're
maintaining ordering,

00:33:55.906 --> 00:33:56.946 A:middle
we have an array internally.

00:33:56.946 --> 00:33:59.626 A:middle
And because we're
guaranteeing uniqueness

00:33:59.626 --> 00:34:01.406 A:middle
and no duplicate objects,
we also have a set.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:59.626 --> 00:34:01.406 A:middle
and no duplicate objects,
we also have a set.

00:34:01.656 --> 00:34:03.156 A:middle
So roughly double memory usage.

00:34:03.496 --> 00:34:06.306 A:middle
And also when you-- If you
want to store an ordered set

00:34:06.346 --> 00:34:08.306 A:middle
in a property list, you'd
have to convert it to an array

00:34:08.556 --> 00:34:11.656 A:middle
and then back as
you bring it out.

00:34:11.656 --> 00:34:13.536 A:middle
NSIndexSet and NSMutableIndexSet
differ

00:34:13.536 --> 00:34:15.806 A:middle
because they don't store
objects, they store indexes,

00:34:16.166 --> 00:34:19.056 A:middle
integer values, so it's a
collection of unique indexes

00:34:19.396 --> 00:34:22.446 A:middle
and these are really handy
for referencing some subset

00:34:22.446 --> 00:34:24.025 A:middle
of objects in an NSArray.

00:34:24.616 --> 00:34:26.186 A:middle
And it's really handy especially

00:34:26.186 --> 00:34:28.866 A:middle
because you can avoid the
memory overhead of making a copy

00:34:28.866 --> 00:34:31.275 A:middle
or saying objectsAtIndexes,
you can give it an index set

00:34:31.496 --> 00:34:33.886 A:middle
and it gives you a
new autoreleased array

00:34:34.226 --> 00:34:35.246 A:middle
with those objects in it.

00:34:35.406 --> 00:34:37.996 A:middle
If you want to avoid that
overhead, you can just enumerate

00:34:37.996 --> 00:34:39.656 A:middle
through the objects
at particular indexes

00:34:39.656 --> 00:34:41.726 A:middle
without creating a new array,
and it's really handy for that.

00:34:42.206 --> 00:34:44.116 A:middle
Index set has really
efficient storage

00:34:44.116 --> 00:34:45.876 A:middle
and coalescing of indexes.

00:34:46.065 --> 00:34:48.716 A:middle
So if you have a mutable index
set and you add the indexes 1

00:34:48.716 --> 00:34:50.196 A:middle
and 3, it will store
those separately.

00:34:50.485 --> 00:34:53.315 A:middle
If you add 2 as well, it's
intelligent enough to coalesce

00:34:53.315 --> 00:34:55.146 A:middle
and say, "I'm going to
store the range 1 to 3."

00:34:55.446 --> 00:34:57.666 A:middle
And if you add more indexes
that are consecutive,

00:34:57.756 --> 00:34:59.006 A:middle
it will group those
all together,

00:34:59.006 --> 00:35:00.366 A:middle
so it's really efficient
with storage.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.006 --> 00:35:00.366 A:middle
so it's really efficient
with storage.

00:35:00.936 --> 00:35:03.976 A:middle
It also supports set arithmetic
such as intersection, subset,

00:35:03.976 --> 00:35:06.386 A:middle
and difference like we
saw with mutable sets.

00:35:06.386 --> 00:35:09.136 A:middle
One caveat of this is when
you're using index set

00:35:09.136 --> 00:35:11.016 A:middle
and you apply it to
an NSMutableArray,

00:35:11.266 --> 00:35:13.976 A:middle
if that array changes after
you've obtained the index set,

00:35:13.976 --> 00:35:15.516 A:middle
you can have all
sorts of bad results.

00:35:15.516 --> 00:35:19.276 A:middle
For example, you have a mutable
array, you've gotten a group

00:35:19.276 --> 00:35:22.046 A:middle
of indexes, and then you
remove all the objects

00:35:22.046 --> 00:35:22.876 A:middle
or some of them in the array.

00:35:22.906 --> 00:35:24.366 A:middle
If you try to get
objectsAtIndexes,

00:35:24.516 --> 00:35:25.726 A:middle
you can easily get
a range exception

00:35:25.726 --> 00:35:27.446 A:middle
because that index no
longer exists in array.

00:35:27.446 --> 00:35:29.986 A:middle
So this is something
to be aware of.

00:35:29.986 --> 00:35:32.016 A:middle
NSMapTable and NSHashTable
are very interesting.

00:35:32.186 --> 00:35:32.926 A:middle
They are very similar

00:35:32.926 --> 00:35:35.226 A:middle
to NSMutableDictionary
and NSMutableSet.

00:35:35.976 --> 00:35:38.186 A:middle
There's a couple
of key differences.

00:35:38.336 --> 00:35:40.216 A:middle
They offer a lot more
flexibility with some

00:35:40.216 --> 00:35:41.396 A:middle
of these additional options.

00:35:41.596 --> 00:35:43.676 A:middle
You can use pointer
identity rather than choosing

00:35:43.676 --> 00:35:45.746 A:middle
to use isEqual, as you would
in these other collections.

00:35:46.086 --> 00:35:48.806 A:middle
It can contain any kind of
pointer, not just an object;

00:35:48.806 --> 00:35:50.156 A:middle
it could be a void or any kind

00:35:50.156 --> 00:35:51.356 A:middle
of C pointer you
can store in here.

00:35:51.826 --> 00:35:54.276 A:middle
You can optionally say that
you want weak references,

00:35:54.276 --> 00:35:56.566 A:middle
so that if all the strong
references to an object stored

00:35:56.756 --> 00:35:59.396 A:middle
as a key or value in a
map table, for example,

00:35:59.606 --> 00:36:00.516 A:middle
if any of those go away then

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:59.606 --> 00:36:00.516 A:middle
if any of those go away then

00:36:00.516 --> 00:36:02.296 A:middle
that entry would automatically
be removed for you.

00:36:02.506 --> 00:36:05.316 A:middle
And this works under ARC as
well with zeroing references.

00:36:05.906 --> 00:36:08.516 A:middle
And you can optionally say that
you don't want to copy on insert

00:36:08.746 --> 00:36:12.116 A:middle
as you add an object to
a map table, for example,

00:36:12.116 --> 00:36:13.066 A:middle
it won't copy the key.

00:36:13.906 --> 00:36:14.886 A:middle
You can specify that.

00:36:15.296 --> 00:36:19.056 A:middle
Now, you can't convert a
map table or a hash table

00:36:19.056 --> 00:36:21.256 A:middle
that contains these
raw C pointers directly

00:36:21.256 --> 00:36:24.896 A:middle
to their counterpart,
mutable dictionary or so on,

00:36:25.176 --> 00:36:28.736 A:middle
because they don't translate
over well, and also a caution

00:36:28.736 --> 00:36:30.096 A:middle
to be aware of premature
optimization.

00:36:30.096 --> 00:36:31.776 A:middle
This is one of those
situations that where you think,

00:36:31.776 --> 00:36:35.376 A:middle
this is going to be just what I
need, but you'll sacrifice some

00:36:35.376 --> 00:36:38.846 A:middle
of your compatibility with APIs
that require an NSDictionary,

00:36:39.016 --> 00:36:41.296 A:middle
and for most cases it's
probably not necessary.

00:36:41.296 --> 00:36:44.266 A:middle
It's a great tool to be aware
of, but it's not something

00:36:44.266 --> 00:36:45.136 A:middle
that you're generally
going to use.

00:36:45.136 --> 00:36:47.336 A:middle
This was also introduced
in OS X 10.5

00:36:47.666 --> 00:36:49.676 A:middle
and the corresponding iOS
release, so you should be able

00:36:49.676 --> 00:36:52.046 A:middle
to use this broadly
throughout your applications.

00:36:52.186 --> 00:36:53.046 A:middle
And last is NSCache.

00:36:53.436 --> 00:36:55.256 A:middle
This is also similar
to NSMutableDictionary,

00:36:55.526 --> 00:36:57.206 A:middle
and it's a great
tool to have as well.

00:36:57.796 --> 00:37:00.766 A:middle
Primarily, there's
a few big benefits.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:57.796 --> 00:37:00.766 A:middle
Primarily, there's
a few big benefits.

00:37:00.826 --> 00:37:03.036 A:middle
First and foremost is
that it's threadsafe,

00:37:03.086 --> 00:37:04.256 A:middle
unlike a mutable dictionary.

00:37:04.496 --> 00:37:06.926 A:middle
It doesn't copy your keys
unlike a mutable dictionary,

00:37:07.206 --> 00:37:09.516 A:middle
and it supports auto-removal
under memory pressure.

00:37:09.786 --> 00:37:11.236 A:middle
So when the OS needs
to reclaim memory,

00:37:11.236 --> 00:37:13.986 A:middle
it can automatically boot
out entries from this cache.

00:37:13.986 --> 00:37:16.016 A:middle
This is ideal for objects
that you can regenerate

00:37:16.016 --> 00:37:17.356 A:middle
or obtain again easily.

00:37:17.356 --> 00:37:18.596 A:middle
For more detail on this,

00:37:18.596 --> 00:37:21.096 A:middle
I highly recommend the talk
Building Efficient OS X Apps.

00:37:21.346 --> 00:37:23.286 A:middle
A lot of this also
applies to iOS as well.

00:37:23.286 --> 00:37:26.826 A:middle
It focuses a lot on memory
usage and disk IO and energy,

00:37:27.036 --> 00:37:29.846 A:middle
and it will go into much
more depth about NSCache

00:37:29.846 --> 00:37:31.996 A:middle
and purgeable data, and
what you can do to work well

00:37:31.996 --> 00:37:34.676 A:middle
and be a good citizen when
memory pressure comes to bear.

00:37:35.536 --> 00:37:37.576 A:middle
So, wrapping up these
data structures,

00:37:37.576 --> 00:37:39.956 A:middle
I have just two brief
asides as it relates

00:37:39.956 --> 00:37:41.466 A:middle
to data structures
and storing them.

00:37:41.816 --> 00:37:42.856 A:middle
So first, property lists.

00:37:42.856 --> 00:37:45.466 A:middle
You're all familiar with them
that you can store hierarchies

00:37:45.466 --> 00:37:47.756 A:middle
of data, in XML or
binary format.

00:37:47.896 --> 00:37:50.136 A:middle
Each of you at least has an
Info.plist in your application,

00:37:50.136 --> 00:37:51.686 A:middle
and may use them
in other places.

00:37:52.086 --> 00:37:53.856 A:middle
They support property
list objects.

00:37:53.856 --> 00:37:57.456 A:middle
It's a set of six objects in
Foundation: arrays, data, date,

00:37:57.456 --> 00:37:58.966 A:middle
dictionary, number, and string.

00:37:59.516 --> 00:38:02.346 A:middle
Any others that you can't, for
example, convert to a string,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:59.516 --> 00:38:02.346 A:middle
Any others that you can't, for
example, convert to a string,

00:38:02.606 --> 00:38:05.216 A:middle
you would have to use NSCoding
and archive it into an NSData

00:38:05.216 --> 00:38:06.816 A:middle
and store it in the
property list.

00:38:07.936 --> 00:38:09.246 A:middle
So you do have some
flexibility there.

00:38:09.496 --> 00:38:10.296 A:middle
It's good to be aware, though,

00:38:10.296 --> 00:38:11.696 A:middle
that mutability is
not preserved.

00:38:11.736 --> 00:38:13.916 A:middle
If I build up mutable
dictionaries and arrays

00:38:13.916 --> 00:38:16.656 A:middle
in a hierarchy that I like and
then store it to property list

00:38:16.656 --> 00:38:18.616 A:middle
and read it back out,
they're no longer mutable.

00:38:18.616 --> 00:38:20.266 A:middle
I'll get the immutable
variants of those.

00:38:20.406 --> 00:38:21.226 A:middle
That's important to know.

00:38:22.616 --> 00:38:24.746 A:middle
Property lists are generally
not efficient for lots

00:38:24.746 --> 00:38:26.986 A:middle
of binary data, like
encoding things into NSData

00:38:26.986 --> 00:38:29.206 A:middle
and sticking them in there,
or for really large files,

00:38:29.626 --> 00:38:31.736 A:middle
particularly if you're
using an XML format.

00:38:32.176 --> 00:38:34.006 A:middle
There may be better
alternatives to look into.

00:38:34.006 --> 00:38:38.496 A:middle
You'll see property lists
commonly with NSUserDefaults,

00:38:38.496 --> 00:38:40.486 A:middle
for storing user preferences
for your application,

00:38:40.736 --> 00:38:42.756 A:middle
it's a common way
to interact with it.

00:38:42.756 --> 00:38:45.756 A:middle
NSPropertyListSerialization is
also a really handy way to deal

00:38:45.756 --> 00:38:48.836 A:middle
with this for input and
output of property lists.

00:38:50.056 --> 00:38:52.026 A:middle
And I encourage you to
look at NSKeyedArchiver

00:38:52.026 --> 00:38:54.246 A:middle
and NSKeyedUnarchiver
if you have needs

00:38:54.246 --> 00:38:56.356 A:middle
to store other data
in a property list.

00:38:56.466 --> 00:38:57.776 A:middle
The second aside is on JSON.

00:38:58.206 --> 00:39:00.626 A:middle
This is JavaScript Object
Notation and originated

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:58.206 --> 00:39:00.626 A:middle
This is JavaScript Object
Notation and originated

00:39:00.626 --> 00:39:01.956 A:middle
in JavaScript, but
it's supported

00:39:01.956 --> 00:39:03.876 A:middle
across a broad variety
of platforms.

00:39:04.366 --> 00:39:06.996 A:middle
It's a lightweight data
interchange format that's human

00:39:06.996 --> 00:39:09.236 A:middle
readable and it's really
handy, and it's commonly used

00:39:09.236 --> 00:39:11.236 A:middle
for things like web
services or sending things

00:39:11.236 --> 00:39:12.356 A:middle
between different platforms.

00:39:12.676 --> 00:39:14.746 A:middle
And it works with a
few Foundation classes.

00:39:14.746 --> 00:39:16.096 A:middle
Some of them are
similar to property list.

00:39:16.096 --> 00:39:18.496 A:middle
You'll see array,
dictionary, number and string,

00:39:18.496 --> 00:39:19.676 A:middle
but there's also NSNull.

00:39:19.966 --> 00:39:22.146 A:middle
If you're not familiar with
this, this is null placeholder.

00:39:22.386 --> 00:39:25.176 A:middle
Collections in Cocoa don't
allow you to store nil inside

00:39:25.176 --> 00:39:28.016 A:middle
of a collection, but JSON
does allow null objects,

00:39:28.016 --> 00:39:31.116 A:middle
and you'll see those transfer
across as NSNull place holders.

00:39:31.566 --> 00:39:33.736 A:middle
And there are also
some restrictions,

00:39:33.736 --> 00:39:37.226 A:middle
such as the top level object in
JSON needs to be a dictionary,

00:39:37.226 --> 00:39:39.936 A:middle
and you can only use strings
for the keys in your dictionary,

00:39:39.936 --> 00:39:42.696 A:middle
you can't use numbers
or other things.

00:39:43.036 --> 00:39:45.736 A:middle
And you should definitely be
aware of NSJSONSerialization.

00:39:45.736 --> 00:39:47.356 A:middle
This was introduced
a few releases ago,

00:39:47.616 --> 00:39:52.286 A:middle
and it's a really convenient
way to deal with JSON.

00:39:52.286 --> 00:39:54.546 A:middle
It supports reading and writing,
you can even pass an object

00:39:54.546 --> 00:39:56.576 A:middle
and see if it will
form valid JSON.

00:39:56.886 --> 00:39:59.336 A:middle
You can also specify
whether you want mutability

00:39:59.336 --> 00:40:01.276 A:middle
when you read objects
out of JSON,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:59.336 --> 00:40:01.276 A:middle
when you read objects
out of JSON,

00:40:01.276 --> 00:40:03.706 A:middle
which is different
from property lists.

00:40:03.706 --> 00:40:08.206 A:middle
And this class has been improved
and iterated a lot over time.

00:40:08.206 --> 00:40:10.196 A:middle
It's fast and it's built-in,
you don't have to link

00:40:10.196 --> 00:40:13.276 A:middle
in a static library,
for example, on iOS.

00:40:13.456 --> 00:40:16.736 A:middle
You can count on the
improvements to efficiency

00:40:16.736 --> 00:40:17.896 A:middle
and performance over time.

00:40:18.096 --> 00:40:19.406 A:middle
And you'll see even
more improvements

00:40:19.606 --> 00:40:22.816 A:middle
in iOS 7 and in Mavericks.

00:40:22.936 --> 00:40:25.356 A:middle
OK. So that wraps up about
data structure and performance.

00:40:25.716 --> 00:40:26.656 A:middle
That's a lot of information.

00:40:26.656 --> 00:40:29.496 A:middle
For our final section, I'm going
to kind of tie this all together

00:40:29.496 --> 00:40:31.156 A:middle
and talk about real
world applications.

00:40:31.156 --> 00:40:33.986 A:middle
How we can take all this about
"Big O" complexity and talking

00:40:33.986 --> 00:40:35.206 A:middle
about data structures
performance

00:40:35.206 --> 00:40:37.916 A:middle
and how fast they are, and
apply that to my actual code.

00:40:37.916 --> 00:40:39.776 A:middle
So I'm going to give you
example again from our code.

00:40:39.776 --> 00:40:42.616 A:middle
From the WWDC App, we
refresh the sessions.

00:40:42.616 --> 00:40:43.866 A:middle
You all saw this on Monday.

00:40:44.046 --> 00:40:46.266 A:middle
You're anxiously waiting
for those TBAs to disappear

00:40:46.266 --> 00:40:47.746 A:middle
and see what the
sessions were going to be.

00:40:48.146 --> 00:40:49.996 A:middle
And we have this
functionality to refresh those.

00:40:49.996 --> 00:40:53.526 A:middle
So the data is stored in
Core Data on the application,

00:40:53.566 --> 00:40:55.586 A:middle
on your device, and we
periodically fetch updates

00:40:55.586 --> 00:40:57.556 A:middle
from the server to check
if there's new information.

00:40:58.086 --> 00:40:59.626 A:middle
Now, we did notice some
performances issues

00:40:59.626 --> 00:41:01.066 A:middle
in earlier versions
of the applications.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:59.626 --> 00:41:01.066 A:middle
in earlier versions
of the applications.

00:41:01.276 --> 00:41:02.556 A:middle
At first we were
getting great speed,

00:41:02.806 --> 00:41:05.566 A:middle
but as the conference
became more fleshed out

00:41:05.566 --> 00:41:06.516 A:middle
and more sessions were added,

00:41:06.696 --> 00:41:10.426 A:middle
the speed got progressively
slower, and noticeably slower,

00:41:10.426 --> 00:41:12.506 A:middle
not just a little bit,
but a lot more over time.

00:41:12.826 --> 00:41:14.016 A:middle
And it became kind
of unbearable.

00:41:14.296 --> 00:41:15.286 A:middle
And when we profiled it,

00:41:15.286 --> 00:41:16.546 A:middle
we found that there
was non-linear growth.

00:41:16.546 --> 00:41:17.626 A:middle
We obviously had some sort

00:41:17.626 --> 00:41:19.256 A:middle
of complexity problem,
doing too much work.

00:41:19.346 --> 00:41:21.366 A:middle
So I'm going to walk you
through a simple example here.

00:41:21.366 --> 00:41:23.336 A:middle
So this is what we did at first.

00:41:23.456 --> 00:41:26.196 A:middle
We have an array of sessions
that we get from the server,

00:41:26.226 --> 00:41:28.776 A:middle
we've just fetched, and then we
iterate through each of those,

00:41:28.776 --> 00:41:31.136 A:middle
so we want to handle each
of these refreshed sessions

00:41:31.136 --> 00:41:33.016 A:middle
so we have a for loop,
that's order N complexity.

00:41:33.476 --> 00:41:34.876 A:middle
And then we do a Core Data fetch

00:41:34.876 --> 00:41:37.166 A:middle
to see what we have
locally on our device.

00:41:37.306 --> 00:41:41.116 A:middle
We look for a session with that
particular ID, and then we see,

00:41:41.116 --> 00:41:42.526 A:middle
if I had a session with
that then I'm going

00:41:42.526 --> 00:41:44.156 A:middle
to merge them together,
if this is a new session,

00:41:44.156 --> 00:41:45.336 A:middle
I'm going to insert
it into Core Data.

00:41:45.816 --> 00:41:47.326 A:middle
So we were seeing
non-linear performance.

00:41:47.546 --> 00:41:50.746 A:middle
And probably the suspicion
is this may be N squared.

00:41:51.106 --> 00:41:54.576 A:middle
Well, the for loop has to be
there, and the part at the end

00:41:54.576 --> 00:41:55.976 A:middle
about merging sessions
looks pretty simple.

00:41:55.976 --> 00:41:57.486 A:middle
So the work must be
somewhere in between,

00:41:57.816 --> 00:41:59.026 A:middle
right here in the
Core Data fetch.

00:41:59.226 --> 00:42:01.016 A:middle
Now let's think about
what work it has to do.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:59.226 --> 00:42:01.016 A:middle
Now let's think about
what work it has to do.

00:42:01.746 --> 00:42:04.216 A:middle
Well, we're forming a predicate
to search where we say,

00:42:04.726 --> 00:42:08.146 A:middle
"Find me a WWDCSession object
where the session ID is equal

00:42:08.146 --> 00:42:09.636 A:middle
to this session that
I just gave you".

00:42:10.136 --> 00:42:11.786 A:middle
So when I tell Core Data
to do that, we think,

00:42:11.916 --> 00:42:12.926 A:middle
what would it have to do?

00:42:13.486 --> 00:42:16.556 A:middle
Well, because it may not have
ordering on the other side,

00:42:16.556 --> 00:42:18.276 A:middle
probably what it's doing
is it's going through each

00:42:18.276 --> 00:42:20.486 A:middle
of the sessions and seeing
if that session ID matches,

00:42:20.976 --> 00:42:22.486 A:middle
which is an order N algorithm.

00:42:22.876 --> 00:42:24.356 A:middle
So there we have
our hidden work.

00:42:24.356 --> 00:42:25.856 A:middle
We have an order
N loop and order N

00:42:25.856 --> 00:42:28.216 A:middle
for finding the session,
this Core Data fetch.

00:42:28.606 --> 00:42:29.456 A:middle
That's where our N squared is.

00:42:29.676 --> 00:42:31.286 A:middle
So, let's just hoist
that right out,

00:42:31.286 --> 00:42:32.116 A:middle
let's take the Core Data out,

00:42:32.116 --> 00:42:33.816 A:middle
we'll optimize that
a little bit.

00:42:33.816 --> 00:42:35.566 A:middle
Let's say that we now
change it so that instead

00:42:35.566 --> 00:42:38.016 A:middle
of fetching one session
at a time, we get the list

00:42:38.016 --> 00:42:40.426 A:middle
of session IDs that we've
just gotten and we fetch all

00:42:40.426 --> 00:42:41.316 A:middle
of those at the same time.

00:42:41.646 --> 00:42:43.766 A:middle
Now we have them all in
one array and that's great.

00:42:43.766 --> 00:42:45.166 A:middle
We should see order
N performance now,

00:42:45.636 --> 00:42:46.376 A:middle
except we don't.

00:42:47.106 --> 00:42:47.816 A:middle
If you have keen eyes,

00:42:47.816 --> 00:42:49.826 A:middle
you'll notice there's still
some work left inside the loop.

00:42:50.276 --> 00:42:52.736 A:middle
Now, although we know
what session it is

00:42:52.736 --> 00:42:54.346 A:middle
and we've just moved
the session--

00:42:54.346 --> 00:42:56.986 A:middle
the problem, all the work
out of Core Data of finding

00:42:56.986 --> 00:42:58.236 A:middle
that session, we've
moved it into a line

00:42:58.236 --> 00:42:59.976 A:middle
where we're calling
indexOfObject.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:00.086 --> 00:43:01.376 A:middle
Now we have an array
of all these sessions,

00:43:01.376 --> 00:43:02.906 A:middle
but we're still doing
a linear search.

00:43:03.096 --> 00:43:04.716 A:middle
We're stepping through each
of these until we find the one

00:43:04.716 --> 00:43:05.506 A:middle
with the right session.

00:43:05.936 --> 00:43:07.526 A:middle
So, we haven't really
eliminated the problem.

00:43:08.216 --> 00:43:09.316 A:middle
But there is a great
way around it.

00:43:09.656 --> 00:43:12.516 A:middle
Since we're using session IDs
that are unique across these,

00:43:13.116 --> 00:43:14.486 A:middle
we do a slight modification,

00:43:14.486 --> 00:43:16.196 A:middle
and after we've gotten all
those sessions up front,

00:43:16.196 --> 00:43:18.816 A:middle
we create a dictionary where
the objects are the sessions

00:43:18.816 --> 00:43:20.706 A:middle
themselves, and we key
them by the session ID,

00:43:20.706 --> 00:43:21.856 A:middle
'cause these are
going to be unique.

00:43:22.056 --> 00:43:24.946 A:middle
And now, inside the loop, you
can see that we just have look

00:43:24.946 --> 00:43:26.786 A:middle
at that dictionary
and find the one--

00:43:27.096 --> 00:43:29.006 A:middle
the session has that
particular session ID,

00:43:29.326 --> 00:43:32.306 A:middle
and look up in a dictionary is
order 1, it's no longer order N.

00:43:32.486 --> 00:43:33.466 A:middle
So we just solved our problem.

00:43:33.466 --> 00:43:35.966 A:middle
We've taken this algorithm from
order N squared to order N,

00:43:36.156 --> 00:43:39.286 A:middle
and now all of you can get your
session updates really quickly.

00:43:39.286 --> 00:43:41.066 A:middle
There's not 5,000 of
you waiting forever

00:43:41.066 --> 00:43:42.186 A:middle
for all those sessions
to reload.

00:43:42.246 --> 00:43:44.806 A:middle
So that's a real world example
from our own application.

00:43:45.856 --> 00:43:49.226 A:middle
So, I want to also
give a couple of tips

00:43:49.226 --> 00:43:50.516 A:middle
about eliminating extra work.

00:43:52.196 --> 00:43:54.376 A:middle
Really what you want to
do is minimize redundancy

00:43:54.436 --> 00:43:56.126 A:middle
and in particular
the expensive code.

00:43:56.436 --> 00:43:58.416 A:middle
So what we just saw in the
previous example was each time

00:43:58.416 --> 00:43:59.566 A:middle
to the for loop we
we're searching

00:43:59.566 --> 00:44:01.826 A:middle
through the same array just
for a different session ID.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:59.566 --> 00:44:01.826 A:middle
through the same array just
for a different session ID.

00:44:01.826 --> 00:44:05.276 A:middle
If there's a way that we can
get that out of a loop and do

00:44:05.276 --> 00:44:08.236 A:middle
that work just once, do it less
frequently, that's a big win.

00:44:08.906 --> 00:44:11.546 A:middle
Also, take advantage of
faster lookup when possible,

00:44:11.576 --> 00:44:12.846 A:middle
like we did with
the NSDictionary.

00:44:12.926 --> 00:44:15.436 A:middle
Sets can also be useful for
this when that's appropriate.

00:44:16.676 --> 00:44:18.306 A:middle
Using mutable collections
and strings

00:44:18.586 --> 00:44:21.556 A:middle
when it makes sense can also
be a big performance win.

00:44:21.556 --> 00:44:23.826 A:middle
And I'll show you an example
of that in just a moment.

00:44:23.826 --> 00:44:25.976 A:middle
And also streamline how
you access your data.

00:44:26.096 --> 00:44:28.546 A:middle
Don't make it hard for yourself
to get to the data that you need

00:44:28.736 --> 00:44:29.796 A:middle
as quickly as possible.

00:44:30.106 --> 00:44:31.666 A:middle
You can organize your
data in such a way

00:44:31.666 --> 00:44:33.176 A:middle
that it's structured
intelligently

00:44:33.176 --> 00:44:34.786 A:middle
and your lookup will
be really fast.

00:44:35.616 --> 00:44:38.206 A:middle
And again, try not to
reinvent the wheel.

00:44:38.316 --> 00:44:39.616 A:middle
There's times where you
need to write your own code

00:44:39.616 --> 00:44:42.876 A:middle
but there are situations,
for example, joining an array

00:44:42.876 --> 00:44:43.826 A:middle
of components with strings.

00:44:43.826 --> 00:44:46.036 A:middle
You may have a group of strings
that you want to comma separate.

00:44:46.456 --> 00:44:49.076 A:middle
You could write your own code to
do that and append into a string

00:44:49.076 --> 00:44:50.106 A:middle
and so on, but there's
already API

00:44:50.106 --> 00:44:51.586 A:middle
where you can give it
an array of objects

00:44:51.856 --> 00:44:53.976 A:middle
and give it some string that
you want as the delimiter,

00:44:53.976 --> 00:44:55.146 A:middle
and it can join them
together for you.

00:44:55.226 --> 00:44:58.256 A:middle
So wherever possible use
those, you'll benefit

00:44:59.386 --> 00:45:02.566 A:middle
from the optimizations and
eliminate extra work, you know,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:59.386 --> 00:45:02.566 A:middle
from the optimizations and
eliminate extra work, you know,

00:45:02.566 --> 00:45:04.096 A:middle
that we're doing as fast
as we can think to do it.

00:45:04.226 --> 00:45:07.246 A:middle
So, an example on
eliminating this extra work,

00:45:07.956 --> 00:45:10.966 A:middle
let's say that you have a method
that takes an array and I want

00:45:10.966 --> 00:45:12.936 A:middle
to scan through that and do
something with these objects,

00:45:12.936 --> 00:45:15.406 A:middle
and if the result is not nil,
I want to add it to a new array

00:45:15.406 --> 00:45:16.346 A:middle
and I'm going to
return that back

00:45:16.346 --> 00:45:17.746 A:middle
from this function--
from this method.

00:45:19.356 --> 00:45:20.806 A:middle
The big problem here is really

00:45:20.806 --> 00:45:23.986 A:middle
that each time we're creating a
new immutable copy of an array.

00:45:23.986 --> 00:45:26.516 A:middle
This is an obvious no-no
and we can avoid this.

00:45:26.856 --> 00:45:29.666 A:middle
Instead of doing that, you can
create a mutable array up front

00:45:29.796 --> 00:45:31.536 A:middle
and add the objects to
the array which is going

00:45:31.536 --> 00:45:33.696 A:middle
to be really fast, and then
at the end when we're done,

00:45:33.906 --> 00:45:36.726 A:middle
we can call copy which gives
us back an immutable NSArray

00:45:36.846 --> 00:45:37.716 A:middle
and we can return that.

00:45:37.716 --> 00:45:39.586 A:middle
So we take a full
advantage of the mutability

00:45:39.586 --> 00:45:42.066 A:middle
when it make sense for us, and
we still fulfill the contract

00:45:42.066 --> 00:45:44.576 A:middle
of our method by saying we'll
return an actual NSArray.

00:45:44.956 --> 00:45:46.826 A:middle
And you could do similar
things with appending

00:45:47.036 --> 00:45:50.376 A:middle
to an NSMutableString or
NSMutableData and so on.

00:45:51.766 --> 00:45:53.996 A:middle
The key takeaway from this
whole section, I like to say,

00:45:54.046 --> 00:45:55.506 A:middle
don't leave performance
on the table.

00:45:55.866 --> 00:45:58.286 A:middle
If there's performance there
just waiting for you to take it

00:45:58.286 --> 00:46:00.356 A:middle
and be faster, don't
leave it there.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:58.286 --> 00:46:00.356 A:middle
and be faster, don't
leave it there.

00:46:00.916 --> 00:46:02.036 A:middle
Take advantage of it.

00:46:02.036 --> 00:46:04.576 A:middle
You know, if I could be using
an NSDictionary for this rather

00:46:04.576 --> 00:46:07.476 A:middle
than an NSArray, I might
as well do that, you know?

00:46:07.546 --> 00:46:10.246 A:middle
You have to weigh the
benefits, the pros and cons

00:46:10.786 --> 00:46:12.296 A:middle
of choosing either way.

00:46:12.856 --> 00:46:15.396 A:middle
But I really encourage
you to think deeply

00:46:15.646 --> 00:46:17.786 A:middle
about the performance that
you're going to expect to see

00:46:17.786 --> 00:46:18.856 A:middle
with your data structures.

00:46:19.386 --> 00:46:21.426 A:middle
There's a lot more information
that you can find on this.

00:46:21.426 --> 00:46:23.816 A:middle
Dave DeLong is our App
Frameworks Evangelist,

00:46:23.816 --> 00:46:26.376 A:middle
and he'll be a great point
man for any questions you have

00:46:26.376 --> 00:46:28.896 A:middle
on this, and also in the Cocoa
Labs, the Developer Forums,

00:46:28.896 --> 00:46:30.356 A:middle
and then I have three
documentation links

00:46:30.356 --> 00:46:33.146 A:middle
that are really useful for
more in-depth understanding

00:46:33.146 --> 00:46:35.206 A:middle
of collections, property
lists, and archives

00:46:35.206 --> 00:46:36.016 A:middle
and serialization and so on.

00:46:36.376 --> 00:46:37.956 A:middle
There's two related
sessions, I mentioned the one

00:46:37.956 --> 00:46:41.406 A:middle
on Building Efficient OS X
Apps, and Hidden Gems in Cocoa

00:46:41.406 --> 00:46:43.296 A:middle
and Cocoa Touch is immediately
following in this room.

00:46:43.296 --> 00:46:44.836 A:middle
This is a great overview
of a lot

00:46:44.836 --> 00:46:46.736 A:middle
of things you may not be
familiar with or even aware

00:46:46.736 --> 00:46:49.566 A:middle
of throughout the Cocoa
and Cocoa Touch frameworks,

00:46:49.566 --> 00:46:52.246 A:middle
also in Xcode and
different things like that.

00:46:52.276 --> 00:46:54.036 A:middle
So just to summarize, I
have a few key takeaways

00:46:54.036 --> 00:46:55.676 A:middle
that I want you to remember if
nothing else from this session.

00:46:56.066 --> 00:46:59.126 A:middle
The first is that complexity
kills large-scale performance.

00:46:59.476 --> 00:47:02.366 A:middle
If you have a lot of work and
your complexity grows over time,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:59.476 --> 00:47:02.366 A:middle
If you have a lot of work and
your complexity grows over time,

00:47:02.596 --> 00:47:03.916 A:middle
when you get to large
amounts of data,

00:47:04.156 --> 00:47:05.206 A:middle
your performance will tank.

00:47:05.586 --> 00:47:06.466 A:middle
You need to be aware of that.

00:47:06.696 --> 00:47:09.926 A:middle
Second, know how much
work your code is doing.

00:47:10.256 --> 00:47:11.866 A:middle
Know what it's actually
trying to accomplish,

00:47:11.866 --> 00:47:13.746 A:middle
that's where a lot of the
hidden complexity lies.

00:47:14.376 --> 00:47:16.636 A:middle
Avoid redundancy and
strive for efficiency,

00:47:16.636 --> 00:47:19.376 A:middle
this is those last two points of
how you can resolve these kind

00:47:19.376 --> 00:47:20.356 A:middle
of performance issues.

00:47:20.836 --> 00:47:22.406 A:middle
If you're doing something
over and over again,

00:47:22.666 --> 00:47:24.296 A:middle
take it out of a
loop, do it just once.

00:47:24.576 --> 00:47:26.486 A:middle
If you're doing something
in an inefficient way,

00:47:26.486 --> 00:47:27.646 A:middle
try to find a better algorithm.

00:47:28.466 --> 00:47:30.996 A:middle
Focus on the biggest
performance wins first,

00:47:30.996 --> 00:47:32.266 A:middle
as we talked about Amdahl's Law.

00:47:32.266 --> 00:47:34.136 A:middle
Find the bottlenecks and
eliminate them first,

00:47:34.136 --> 00:47:35.526 A:middle
don't prematurely optimize.

00:47:36.256 --> 00:47:37.706 A:middle
Prefer to use the
built-in collections

00:47:37.706 --> 00:47:41.116 A:middle
and API wherever possible so you
can benefit from optimizations

00:47:41.116 --> 00:47:42.106 A:middle
and improvements over time.

00:47:42.866 --> 00:47:45.316 A:middle
Design according to
your particular needs.

00:47:45.646 --> 00:47:49.026 A:middle
Choose a data structure that
fits how you need to access it.

00:47:49.366 --> 00:47:51.746 A:middle
Something that will make it
really fast for the tasks

00:47:51.746 --> 00:47:53.746 A:middle
that you need to do, and
it's going to be convenient.

00:47:54.556 --> 00:47:56.626 A:middle
And last, think about
performance early.

00:47:57.046 --> 00:47:59.206 A:middle
There's a difference between
premature optimization

00:47:59.466 --> 00:48:00.936 A:middle
and being-- having common sense

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:59.466 --> 00:48:00.936 A:middle
and being-- having common sense

00:48:01.126 --> 00:48:02.756 A:middle
about the performance
of your application.

00:48:03.006 --> 00:48:04.356 A:middle
When you use some
of this knowledge

00:48:04.356 --> 00:48:06.496 A:middle
about understanding how
complexity can affect your

00:48:06.496 --> 00:48:08.586 A:middle
performance, it enables you to
make great decisions up front

00:48:08.876 --> 00:48:12.156 A:middle
about how to store your data so
that you can access it quickly,

00:48:12.486 --> 00:48:14.726 A:middle
you'll be happy, and your
users will be delighted

00:48:14.726 --> 00:48:16.136 A:middle
with the performance
of your application.

00:48:16.356 --> 00:48:21.076 A:middle
Thank you.

00:48:21.576 --> 00:48:25.850 A:middle
[ Applause ]

