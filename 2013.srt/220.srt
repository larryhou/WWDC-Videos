
1
00:00:09.766 --> 00:00:10.986
>> Good afternoon.

2
00:00:11.356 --> 00:00:12.946
This is Session 220.

3
00:00:13.446 --> 00:00:16.175
Advanced Text Layouts and
Effects with Text Kit.

4
00:00:16.516 --> 00:00:20.086
I'm Aki Inoue, a senior
text architect at Apple.

5
00:00:21.246 --> 00:00:26.426
Yesterday, Ian, Johannes and
Jordan introduced Text Kit,

6
00:00:26.716 --> 00:00:28.746
a new technology in iOS 7.

7
00:00:30.066 --> 00:00:33.316
Today in this session,
we're going to discover

8
00:00:33.316 --> 00:00:37.916
that you have broader and
finer controls over your text

9
00:00:38.546 --> 00:00:39.736
through this technology.

10
00:00:40.336 --> 00:00:42.256
Let's get started.

11
00:00:42.256 --> 00:00:44.316
These are the items
we're covering today.

12
00:00:44.316 --> 00:00:47.836
We're going to start
with text effects.

13
00:00:47.866 --> 00:00:50.856
As you've seen earlier
in this conference,

14
00:00:51.466 --> 00:00:55.676
iOS 7 supports gorgeous
letterpress text effects.

15
00:00:56.056 --> 00:00:56.946
You're going to learn how

16
00:00:56.946 --> 00:00:59.186
to integrate this effect
in the application.

17
00:00:59.956 --> 00:01:04.286
Next, we're going to cover the
three main Text Kit objects,

18
00:00:59.956 --> 00:01:04.286
Next, we're going to cover the
three main Text Kit objects,

19
00:01:04.635 --> 00:01:10.106
NSLayoutManager, NSTextContainer
and NSTextStorage, the power,

20
00:01:10.106 --> 00:01:12.916
the typographic enhancements
in iOS 7.

21
00:01:13.266 --> 00:01:17.426
There are many advanced
text layout features

22
00:01:18.246 --> 00:01:23.656
such as multiple page
documents that are integral

23
00:01:23.656 --> 00:01:25.746
to the Text Kit architecture.

24
00:01:26.156 --> 00:01:30.126
Then we're going to dive
deeper into NSLayoutManager.

25
00:01:30.546 --> 00:01:32.066
You're going to learn
what you can do

26
00:01:32.066 --> 00:01:35.116
with some rich text layout
information available

27
00:01:35.116 --> 00:01:36.146
to your applications.

28
00:01:36.796 --> 00:01:39.446
And finally, I'm
going to cover a some

29
00:01:39.446 --> 00:01:42.726
of the customization point
provided for your applications.

30
00:01:43.046 --> 00:01:45.266
Of course, order of the material

31
00:01:46.216 --> 00:01:51.106
in this session brand
new to iOS 7.

32
00:01:51.146 --> 00:01:55.746
Now, I would like to bring
my colleague, Peter Hajas,

33
00:01:55.746 --> 00:02:02.896
who's going to tell you how
to spice up your application,

34
00:01:55.746 --> 00:02:02.896
who's going to tell you how
to spice up your application,

35
00:02:03.226 --> 00:02:04.856
what is the cool text effects.

36
00:02:05.246 --> 00:02:05.746
Peter.

37
00:02:06.236 --> 00:02:07.056
>> Good afternoon.

38
00:02:07.246 --> 00:02:08.545
My name is Peter Hajas.

39
00:02:08.856 --> 00:02:10.076
I'm a UIKit engineer.

40
00:02:10.496 --> 00:02:13.766
And today, I'd like to talk
to you about text effects.

41
00:02:14.006 --> 00:02:18.356
Text effects are a beautiful
new graphical effect we've added

42
00:02:18.676 --> 00:02:21.326
for your text in
your application.

43
00:02:21.846 --> 00:02:26.206
And in iOS 7, we're
introducing a beautiful,

44
00:02:26.446 --> 00:02:29.506
gorgeous letterpress effect.

45
00:02:30.896 --> 00:02:34.256
In case you're not familiar,
letterpress is a form

46
00:02:34.496 --> 00:02:37.326
of relief printing
by which texts

47
00:02:37.326 --> 00:02:40.016
and images are pressed
into the page.

48
00:02:40.096 --> 00:02:41.236
It's absolutely stunning.

49
00:02:42.456 --> 00:02:44.826
Now prior to iOS
7, if you wanted

50
00:02:44.826 --> 00:02:46.616
to create this effect
programmatically,

51
00:02:47.226 --> 00:02:49.196
it was extraordinarily
difficult for you

52
00:02:49.196 --> 00:02:54.136
to duplicate the shadows, the
embossing, this beautiful,

53
00:02:54.316 --> 00:02:55.876
beautiful effect for your text.

54
00:02:56.846 --> 00:03:00.496
But now, in iOS 7, we're
exposing this to you

55
00:02:56.846 --> 00:03:00.496
But now, in iOS 7, we're
exposing this to you

56
00:03:00.496 --> 00:03:03.146
through one attributed
string key

57
00:03:03.376 --> 00:03:05.376
and a new attributed
string value.

58
00:03:06.626 --> 00:03:10.086
That key is
NSTextEffectAttributeName.

59
00:03:11.186 --> 00:03:15.226
And that value is
NSTextEffectLetterpressStyle.

60
00:03:16.426 --> 00:03:19.006
Now, if you've used
attributed strings before,

61
00:03:19.006 --> 00:03:21.156
and I hope you have, this works

62
00:03:21.156 --> 00:03:24.076
with all the standard NS
attributed string keys

63
00:03:24.076 --> 00:03:24.956
that you're familiar with,

64
00:03:25.226 --> 00:03:26.966
like
ForegroundColorAttributeName

65
00:03:27.196 --> 00:03:29.626
and others.

66
00:03:29.836 --> 00:03:32.586
Letterpress is a
complex graphical effect

67
00:03:33.216 --> 00:03:34.726
and you should use
it tastefully.

68
00:03:35.506 --> 00:03:38.666
If you look at our system
applications, like reminders

69
00:03:38.666 --> 00:03:42.916
and notes, you'll notice that
we use it in those applications

70
00:03:42.916 --> 00:03:45.216
for the title of
a reminder's list

71
00:03:46.026 --> 00:03:47.706
or the title of a
notes document.

72
00:03:49.956 --> 00:03:53.006
Now, I'd like to give
you a quick overview

73
00:03:53.616 --> 00:03:55.786
of the main Text Kit classes.

74
00:03:56.626 --> 00:03:58.846
This is a review of what
you saw at the Intro

75
00:03:58.846 --> 00:04:00.546
to Text Kit session yesterday.

76
00:03:58.846 --> 00:04:00.546
to Text Kit session yesterday.

77
00:04:02.376 --> 00:04:05.676
In Text Kit, there are
three classes that we use

78
00:04:06.176 --> 00:04:09.106
to represent the text in
your application and turn it

79
00:04:09.106 --> 00:04:11.616
into glyphs which users
will see on screen.

80
00:04:12.776 --> 00:04:16.176
Text Storage which
provides the backing store

81
00:04:16.346 --> 00:04:18.296
for the text in your
application.

82
00:04:19.926 --> 00:04:22.566
Layout Manager which
is in charge of how

83
00:04:22.566 --> 00:04:26.736
that text gets turned into
glyphs and has override points

84
00:04:26.736 --> 00:04:28.326
for you to customize it.

85
00:04:28.876 --> 00:04:32.986
And Text Container, which
describes the geometry

86
00:04:32.986 --> 00:04:34.236
about which we flow lines

87
00:04:34.476 --> 00:04:39.016
and line fragments
in your text view.

88
00:04:39.226 --> 00:04:40.676
Let's start with Text Storage.

89
00:04:41.656 --> 00:04:45.616
NSTextStorage is a mutable
attributed string subclass.

90
00:04:45.766 --> 00:04:48.246
So it supports all the
standard attributed string,

91
00:04:48.696 --> 00:04:50.316
keys and values that
you're customary

92
00:04:50.316 --> 00:04:51.676
with including letterpress.

93
00:04:52.716 --> 00:04:56.446
NSTextStorage is versatile
enough for a short document,

94
00:04:56.556 --> 00:05:00.936
like a brief note or message,
and a document as long as War

95
00:04:56.556 --> 00:05:00.936
like a brief note or message,
and a document as long as War

96
00:05:00.936 --> 00:05:04.396
and Peace, so it should be
totally perfect for your needs.

97
00:05:05.436 --> 00:05:09.286
If, however, you find the
need to subclass Text Storage,

98
00:05:09.956 --> 00:05:12.816
you'll need to override all
the primitive attributed string

99
00:05:13.546 --> 00:05:15.716
and mutable attributed
string API.

100
00:05:17.596 --> 00:05:20.736
Next, NSLayoutManager.

101
00:05:21.246 --> 00:05:25.646
If NSTextStorage is the thing
that controls the backing store

102
00:05:25.646 --> 00:05:28.246
for your text and all
your Unicode characters

103
00:05:28.246 --> 00:05:30.166
and attributes and
things like that,

104
00:05:30.956 --> 00:05:35.706
Layout Manager is the object
that translates that text

105
00:05:36.096 --> 00:05:37.526
into glyphs on screen.

106
00:05:38.776 --> 00:05:41.526
Now if you'd like to
override that layout process,

107
00:05:41.826 --> 00:05:43.396
you can do so through delegation

108
00:05:43.526 --> 00:05:45.816
and this is how you can
accomplish advanced layout

109
00:05:45.886 --> 00:05:50.136
techniques such as, for
example, folding lines

110
00:05:50.226 --> 00:05:51.896
or other advanced
text rendering.

111
00:05:52.376 --> 00:05:56.126
And finally, NSTextContainer.

112
00:05:57.486 --> 00:06:01.436
Text Container represents
one area on the display

113
00:05:57.486 --> 00:06:01.436
Text Container represents
one area on the display

114
00:06:01.696 --> 00:06:03.166
in which you'd like
to draw a text.

115
00:06:03.726 --> 00:06:06.266
It's not the object that
does the actual drawing,

116
00:06:06.356 --> 00:06:07.616
that's up to your text view.

117
00:06:08.366 --> 00:06:11.116
Instead Text Container
describes the geometry

118
00:06:11.116 --> 00:06:12.106
about which we draw.

119
00:06:13.246 --> 00:06:15.686
If you were in the
introduction session yesterday,

120
00:06:16.246 --> 00:06:19.206
you saw just how easy our
declarative exclusion path

121
00:06:19.206 --> 00:06:21.926
support is, and this is
built on Text Container.

122
00:06:23.026 --> 00:06:25.156
Now, as we'll see
in a little bit,

123
00:06:25.156 --> 00:06:30.106
Text Container represents one
area on which you draw a text.

124
00:06:30.606 --> 00:06:35.556
So if you'd like multiple pages
or multiple columns for each

125
00:06:35.556 --> 00:06:39.276
of those pages, columns or other
areas in which you flow text,

126
00:06:39.956 --> 00:06:41.936
you'll need an additional
Text Container.

127
00:06:42.456 --> 00:06:48.436
In their most basic
configuration, you'll have one

128
00:06:48.636 --> 00:06:49.896
of each of these objects.

129
00:06:50.866 --> 00:06:54.036
One Text Storage providing that
backing store for your document.

130
00:06:55.376 --> 00:06:58.516
One Layout Manager controlling
how that text gets turned

131
00:06:58.516 --> 00:06:59.606
into glyphs on screen.

132
00:07:00.126 --> 00:07:04.366
And one Text Container
describing the geometry

133
00:07:04.366 --> 00:07:05.526
of your lines.

134
00:07:06.396 --> 00:07:07.516
But let's say you want

135
00:07:07.516 --> 00:07:11.106
to do something a little more
intricate like a multi-columnar

136
00:07:11.156 --> 00:07:13.436
or multi-page layout,
that's fine.

137
00:07:13.506 --> 00:07:15.676
Text Kit supports this
right out of the box.

138
00:07:16.346 --> 00:07:18.196
Just use multiple
Text Containers,

139
00:07:18.536 --> 00:07:20.406
attached to the same
Layout Manager,

140
00:07:20.976 --> 00:07:23.036
backed by the same
Text Storage document.

141
00:07:23.786 --> 00:07:25.706
This is how you'd get
multi-page support

142
00:07:26.416 --> 00:07:28.076
and multi-columnar support.

143
00:07:29.276 --> 00:07:31.556
Now, let's say you want
to go really advanced

144
00:07:31.746 --> 00:07:35.116
and you want a different
layout for your text depending

145
00:07:35.116 --> 00:07:37.636
on if it's on the
device or if it's

146
00:07:37.636 --> 00:07:39.736
on the printed page, hard copy.

147
00:07:40.686 --> 00:07:43.796
In that case, you'd use
multiple Layout Managers,

148
00:07:44.156 --> 00:07:45.686
each with their own
Text Container,

149
00:07:46.236 --> 00:07:49.346
but they're still backed
by the same Text Storage.

150
00:07:49.876 --> 00:07:53.206
So now that I've showed
you just how easy it is

151
00:07:53.236 --> 00:07:57.216
to compose our Text Kit
classes in your applications,

152
00:07:57.986 --> 00:07:59.686
I'd like to give
you a quick demo

153
00:07:59.686 --> 00:08:02.896
of just how simple you
can implement a document

154
00:07:59.686 --> 00:08:02.896
of just how simple you
can implement a document

155
00:08:02.896 --> 00:08:05.406
of arbitrary length, a
multi-paged document.

156
00:08:05.896 --> 00:08:08.376
Here I've got some code and
I'm working on an application

157
00:08:08.846 --> 00:08:12.236
where I have a document sitting
in my applications bundle

158
00:08:12.896 --> 00:08:15.816
and I'd like to flow
this document on screen.

159
00:08:16.266 --> 00:08:18.776
In addition to flowing this
document on the screen,

160
00:08:19.296 --> 00:08:22.116
I want my user, when they're
scrolling through the pages

161
00:08:22.116 --> 00:08:24.726
of my document, to
fill like they would

162
00:08:24.726 --> 00:08:25.836
on the rest of the system.

163
00:08:25.836 --> 00:08:29.116
So I'm going to use
UIPageViewController.

164
00:08:30.126 --> 00:08:33.986
Now, the way PageViewController
works is it needs a view

165
00:08:33.986 --> 00:08:37.436
controller to represent every
page that you'd like to express.

166
00:08:38.035 --> 00:08:40.916
So first, we're going to
need a view controller

167
00:08:40.916 --> 00:08:42.666
to represent a particular page.

168
00:08:43.916 --> 00:08:46.696
Now, thankfully before you all
came in, I had this code sitting

169
00:08:46.696 --> 00:08:47.636
in the oven overnight.

170
00:08:48.146 --> 00:08:50.056
So, it should ready to go.

171
00:08:50.216 --> 00:08:53.336
I'm just going to
drag in a class

172
00:08:53.336 --> 00:08:57.066
that I wrote called
Text Container Instance

173
00:08:57.066 --> 00:08:57.806
View Controller.

174
00:08:58.526 --> 00:09:01.566
And this just encapsulates
a text view which is going

175
00:08:58.526 --> 00:09:01.566
And this just encapsulates
a text view which is going

176
00:09:01.566 --> 00:09:04.696
to draw the text on
screen and the page number

177
00:09:04.696 --> 00:09:07.846
that we can reference when
the PageViewController asks us

178
00:09:07.846 --> 00:09:09.906
for a view controller after

179
00:09:09.906 --> 00:09:11.526
or before a particular
view controller.

180
00:09:12.006 --> 00:09:15.176
Next, in our main
view controller,

181
00:09:15.316 --> 00:09:19.396
we're going to add a method,
ViewControllerForPageNumber.

182
00:09:20.406 --> 00:09:24.776
Remember, a Text Container
represents one area

183
00:09:24.776 --> 00:09:26.516
on the screen in which
you'd like to draw.

184
00:09:27.116 --> 00:09:30.256
So for every page, we're going
to need a Text Container.

185
00:09:30.556 --> 00:09:31.556
But that's no big deal.

186
00:09:31.556 --> 00:09:32.786
Text Kit's pretty performant.

187
00:09:33.036 --> 00:09:36.476
We're going to create a new
page controller representing a

188
00:09:36.476 --> 00:09:41.186
particular page wired
up to our Layout Manager

189
00:09:41.186 --> 00:09:44.986
and add a text view into
the view controller.

190
00:09:48.436 --> 00:09:51.306
Next, we're going to
implement awakeFromNib.

191
00:09:52.376 --> 00:09:55.366
In awakeFromNib, we're going to
create a new PageViewController

192
00:09:55.556 --> 00:09:57.166
and set ourselves
as the delegate.

193
00:09:57.686 --> 00:10:00.186
Next, we're going to implement
the page view controller data

194
00:09:57.686 --> 00:10:00.186
Next, we're going to implement
the page view controller data

195
00:10:00.186 --> 00:10:01.126
source methods.

196
00:10:02.356 --> 00:10:05.266
As I said before, the way
PageViewController works is

197
00:10:05.266 --> 00:10:08.016
by referencing a view
controller before

198
00:10:08.286 --> 00:10:11.816
or after a particular view
controller and that's fine.

199
00:10:12.436 --> 00:10:15.276
Because our single
PageViewController has a page

200
00:10:15.276 --> 00:10:18.866
number instance variable, we
can just add or subtract one

201
00:10:19.416 --> 00:10:21.726
and return the view controller
representing that page.

202
00:10:22.186 --> 00:10:24.836
Finally, we're going to
implement viewWillAppear

203
00:10:24.836 --> 00:10:25.876
in our view controller.

204
00:10:26.446 --> 00:10:30.886
And we're going to loop
through each of our pages

205
00:10:31.236 --> 00:10:33.456
and create a Text
Container for each page.

206
00:10:33.706 --> 00:10:36.076
Because the Text Container
represents one area

207
00:10:36.076 --> 00:10:39.036
in which we need to draw,
we'll need one for every page.

208
00:10:39.586 --> 00:10:40.726
And that's it.

209
00:10:41.296 --> 00:10:42.416
I'm going to build and run.

210
00:10:45.296 --> 00:10:48.386
And this is the same demo
application that you saw

211
00:10:48.386 --> 00:10:51.526
in the Intro to Text Kit
session talk yesterday.

212
00:10:52.736 --> 00:10:54.906
So we're going to drop into
the Text Container demo.

213
00:10:56.106 --> 00:11:02.136
And as you can see our text is
flowed into this view perfectly.

214
00:10:56.106 --> 00:11:02.136
And as you can see our text is
flowed into this view perfectly.

215
00:11:02.746 --> 00:11:05.756
And as we scroll using the
paging behavior our users have

216
00:11:05.756 --> 00:11:10.446
come to expect, we'll be able
to go from page to page to page.

217
00:11:11.316 --> 00:11:13.616
And you'll notice we've even
got a little bit of spacing

218
00:11:13.696 --> 00:11:16.756
in between these pages.

219
00:11:16.916 --> 00:11:20.076
Now, if we had right to
left text from languages

220
00:11:20.076 --> 00:11:22.986
such as Hebrew, Text Kit
was built from the ground

221
00:11:22.986 --> 00:11:25.866
up to support text
in all directions.

222
00:11:25.936 --> 00:11:29.436
So that right to left text
would flow alongside this left

223
00:11:29.436 --> 00:11:30.206
to right text.

224
00:11:32.236 --> 00:11:35.096
And so, that's just
how easy it is

225
00:11:35.096 --> 00:11:39.556
to implement multi-page support
using the core Text Kit objects.

226
00:11:40.926 --> 00:11:44.276
Now, I'd like to hand it
back to my colleague Aki,

227
00:11:44.866 --> 00:11:48.176
our senior textpert, who's going
to go deeper into TextLayout.

228
00:11:48.396 --> 00:11:48.756
Thank you.

229
00:11:49.006 --> 00:11:49.616
>> Thank you, Peter.

230
00:11:50.776 --> 00:11:53.626
Now, let's get close
to NSLayoutManager.

231
00:11:54.056 --> 00:11:59.066
NSLayoutManager is not a
new API for old layout.

232
00:11:59.066 --> 00:12:04.066
It's a Text Kit controller
class that orchestrates

233
00:11:59.066 --> 00:12:04.066
It's a Text Kit controller
class that orchestrates

234
00:12:04.216 --> 00:12:08.906
between NSTextContainer
and NSTextStorage.

235
00:12:10.316 --> 00:12:14.846
And it manages and stores
the layout information.

236
00:12:15.546 --> 00:12:18.836
Using that information,
NSLayoutManager measures

237
00:12:19.086 --> 00:12:26.046
and renders text
as we pressed it.

238
00:12:26.046 --> 00:12:28.796
NSLayoutManager is
designed to be open.

239
00:12:29.176 --> 00:12:33.926
It's not just black box that
serve its sibling objects.

240
00:12:35.076 --> 00:12:42.236
So that all the information used
by Text Kit objects, the power,

241
00:12:42.236 --> 00:12:46.076
the magic is available
to your applications.

242
00:12:47.376 --> 00:12:52.786
Finally, its object-oriented
interface gives you excessive

243
00:12:52.786 --> 00:12:54.306
support for customization

244
00:12:55.766 --> 00:12:58.976
through the familiar
design patterns

245
00:12:58.976 --> 00:13:01.266
such as delegation
and subclassing.

246
00:12:58.976 --> 00:13:01.266
such as delegation
and subclassing.

247
00:13:04.176 --> 00:13:06.476
Before going any deeper,

248
00:13:07.116 --> 00:13:12.206
I'd like to recap
what a text layout is.

249
00:13:13.176 --> 00:13:18.786
Text layout is basically
glyphs and locations.

250
00:13:20.776 --> 00:13:28.326
Then I'd like to
look at the glyphs.

251
00:13:28.746 --> 00:13:31.926
Glyphs-- A glyph is a
graphical representation

252
00:13:31.926 --> 00:13:33.986
of one word characters.

253
00:13:34.506 --> 00:13:35.136
It's simple.

254
00:13:36.916 --> 00:13:43.486
These are three examples of
glyphs for a same character.

255
00:13:44.046 --> 00:13:48.026
As you can see, the graphical
informations you have

256
00:13:48.026 --> 00:13:53.536
in fonts are used to convert
character into glyphs,

257
00:13:53.916 --> 00:13:55.386
the graphical representation.

258
00:13:55.986 --> 00:14:03.246
And since glyphs are graphical
elements, they can be handled

259
00:13:55.986 --> 00:14:03.246
And since glyphs are graphical
elements, they can be handled

260
00:14:03.246 --> 00:14:05.846
by the graphic subsystem
such as quotes.

261
00:14:06.826 --> 00:14:12.046
And on our platform, that glyph
information, glyph IDs to work

262
00:14:12.046 --> 00:14:15.046
in core graphics
data type, CGGlyph.

263
00:14:15.046 --> 00:14:21.386
Now that we covered the basics
of text layout information,

264
00:14:22.136 --> 00:14:26.356
I'd like to walk you though
some of the things you could do

265
00:14:26.536 --> 00:14:29.846
with the layout informations
to work in NSLayoutManager.

266
00:14:32.006 --> 00:14:36.276
In addition to, get the
size of the entire string,

267
00:14:37.496 --> 00:14:41.226
now you can get the
size of single line

268
00:14:42.256 --> 00:14:45.696
to a single glyph at will.

269
00:14:45.896 --> 00:14:48.946
As Ian mentioned yesterday
in his Introduction

270
00:14:48.946 --> 00:14:53.246
to Text Kit session, hit-testing
the character or a word

271
00:14:53.456 --> 00:14:55.926
under your touch
is very trivial.

272
00:14:59.156 --> 00:15:02.466
Also you can get the
precise location,

273
00:14:59.156 --> 00:15:02.466
Also you can get the
precise location,

274
00:15:03.126 --> 00:15:06.616
fix your perfect location
of individual glyphs

275
00:15:07.326 --> 00:15:10.506
so that you can add your
custom rendering or animation

276
00:15:10.856 --> 00:15:16.376
at arbitrary range of
characters in your document.

277
00:15:16.906 --> 00:15:20.456
And with all text
layout information,

278
00:15:21.146 --> 00:15:26.066
glyphs plus locations,
you can transform

279
00:15:26.066 --> 00:15:32.316
and animate text using the power
of the core graphic system.

280
00:15:36.276 --> 00:15:39.256
OK. Let's look at the
glyph information stored

281
00:15:39.256 --> 00:15:40.346
in Layout Manager.

282
00:15:41.566 --> 00:15:44.386
You can access the glyph
information using this method,

283
00:15:45.286 --> 00:15:47.516
glyphAtIndex, simply enough.

284
00:15:48.666 --> 00:15:51.186
But notice that the index passed

285
00:15:51.276 --> 00:15:55.356
through this method
is a glyph index.

286
00:15:56.176 --> 00:15:58.986
It's not the character
index you use

287
00:15:58.986 --> 00:16:01.896
to access the contents
of NSTextStorage.

288
00:15:58.986 --> 00:16:01.896
to access the contents
of NSTextStorage.

289
00:16:02.236 --> 00:16:05.556
So glyph index character
index, where are they?

290
00:16:06.776 --> 00:16:07.996
They are usually the same

291
00:16:08.036 --> 00:16:10.636
but they don't map one
to one all the time.

292
00:16:11.486 --> 00:16:19.786
It's because ligatures,
translation or hyphenation.

293
00:16:20.836 --> 00:16:25.996
There are many common situations
that make the glyphs to map

294
00:16:25.996 --> 00:16:29.366
to their original
character directory.

295
00:16:29.986 --> 00:16:34.996
So for that reason,
NSLayoutManager keeps track

296
00:16:35.856 --> 00:16:39.046
of the character index, the
original character index

297
00:16:39.426 --> 00:16:40.936
for each glyph for you.

298
00:16:42.176 --> 00:16:44.396
You can access the
character index using

299
00:16:44.476 --> 00:16:47.006
characterIndexForGlyphAtIndex
method.

300
00:16:47.006 --> 00:16:53.406
And also you can access
that index other way around.

301
00:16:54.416 --> 00:16:59.586
These are-- You could use these
two methods that maps glyph

302
00:16:59.586 --> 00:17:01.176
and characters in bulk.

303
00:16:59.586 --> 00:17:01.176
and characters in bulk.

304
00:17:01.616 --> 00:17:06.486
And remember, it's important
to remember that, in any case,

305
00:17:06.896 --> 00:17:10.526
you want to use one of these
methods to convert glyphs

306
00:17:10.705 --> 00:17:14.836
and character index when you're
working with NSLayoutManager.

307
00:17:17.665 --> 00:17:19.876
We look at the glyph
information,

308
00:17:20.705 --> 00:17:22.776
let's look at the allocations.

309
00:17:23.116 --> 00:17:30.836
Just like the glyph info itself,
NSLayoutManager keeps track

310
00:17:30.836 --> 00:17:34.726
of the text layout information,
the allocations for glyph.

311
00:17:35.976 --> 00:17:37.636
There are three elements--

312
00:17:38.256 --> 00:17:42.096
generally three elements in
text layout, Text Container,

313
00:17:43.086 --> 00:17:46.076
line and the glyph
location itself.

314
00:17:46.476 --> 00:17:49.466
As Peter described
earlier in this session,

315
00:17:50.306 --> 00:17:55.236
NSLayoutManager connects to
an array of Text Containers,

316
00:17:55.786 --> 00:18:00.076
glyphs are filled from the
beginning of the Text Container

317
00:17:55.786 --> 00:18:00.076
glyphs are filled from the
beginning of the Text Container

318
00:18:00.076 --> 00:18:03.586
at index zero and
from so and so forth.

319
00:18:05.486 --> 00:18:08.446
You can access your Text
Container associated

320
00:18:08.446 --> 00:18:12.646
with a glyph using the
textContainerForGlyphAtIndex

321
00:18:12.696 --> 00:18:14.076
effectiveRange method.

322
00:18:15.076 --> 00:18:19.096
We now know that NSRange pointed

323
00:18:19.166 --> 00:18:23.896
by the second argument
will be filled

324
00:18:23.976 --> 00:18:25.556
with the glyph range
corresponding

325
00:18:25.556 --> 00:18:29.436
to the Text Container
returned from this method.

326
00:18:30.076 --> 00:18:33.406
So in a way, you can use
this method to animate

327
00:18:33.406 --> 00:18:35.076
through all the Text Containers

328
00:18:35.246 --> 00:18:37.126
and the corresponding
glyph range.

329
00:18:39.056 --> 00:18:44.956
Lines. Just as glyph
belong to Text Container,

330
00:18:46.076 --> 00:18:47.106
they are inside the line.

331
00:18:48.086 --> 00:18:52.026
And Text Containers are
filled with lines of text.

332
00:18:52.816 --> 00:18:57.796
But notice that a bigger
line could be divided

333
00:18:57.796 --> 00:19:01.226
into multiple pieces
like this due

334
00:18:57.796 --> 00:19:01.226
into multiple pieces
like this due

335
00:19:01.226 --> 00:19:07.396
to NSTextContainer geometrical
shape defined by exclusion path.

336
00:19:08.386 --> 00:19:15.136
So for that reason, we call that
data element a line fragment.

337
00:19:15.616 --> 00:19:17.396
You can access the line fragment

338
00:19:17.816 --> 00:19:22.416
for a glyph using the
lineFragmentRectForGlyphAtIndex

339
00:19:22.416 --> 00:19:23.786
effectiveRange method.

340
00:19:24.946 --> 00:19:29.716
It returns the CGRect that
represent the rectangular area

341
00:19:30.276 --> 00:19:31.236
for the line fragment.

342
00:19:31.236 --> 00:19:37.846
And finally, the glyph
location itself, it's relative

343
00:19:37.846 --> 00:19:42.796
to the line fragmented rect
that the glyph is inside.

344
00:19:44.276 --> 00:19:45.846
You can access the
location using

345
00:19:45.846 --> 00:19:47.746
the locationForGlyphAtIndex.

346
00:19:48.286 --> 00:19:57.426
Now we covered APIs, I'd like to
explain the actual relationship

347
00:19:57.576 --> 00:20:02.086
among the three geometrical
elements inside the

348
00:19:57.576 --> 00:20:02.086
among the three geometrical
elements inside the

349
00:20:02.086 --> 00:20:03.066
layout information.

350
00:20:04.286 --> 00:20:05.666
We have Text Container.

351
00:20:06.636 --> 00:20:13.296
It has its own system and it
starts at the upper left corner.

352
00:20:16.316 --> 00:20:21.446
The origin of the Text Container
could be actually anywhere

353
00:20:21.446 --> 00:20:25.146
inside a view coordinate
system of its parent view.

354
00:20:25.766 --> 00:20:29.696
So, it could be offsetted
like this.

355
00:20:35.596 --> 00:20:38.996
Now, look into the
line fragment itself.

356
00:20:39.716 --> 00:20:43.116
The line fragment is
represented by CGRect.

357
00:20:44.356 --> 00:20:49.656
And its frame origin is
relative to the line fragment.

358
00:20:49.656 --> 00:20:51.966
It's relative to the Text
Container coordinate system.

359
00:20:52.446 --> 00:20:58.486
Inside the line fragment, it has
its own coordinate system too

360
00:20:58.966 --> 00:21:00.616
that start with the
upper left corner.

361
00:20:58.966 --> 00:21:00.616
that start with the
upper left corner.

362
00:21:02.176 --> 00:21:09.106
And the glyphs are located at
its baseline origin that starts

363
00:21:09.246 --> 00:21:16.336
from the upper left corner of
the line fragment rect itself.

364
00:21:16.546 --> 00:21:22.026
OK. We covered so many
concepts and APIs.

365
00:21:23.146 --> 00:21:25.556
Now make them used in practice.

366
00:21:25.996 --> 00:21:30.936
In this example, I'd like to
locate or find the location

367
00:21:30.936 --> 00:21:36.436
of the glyph associated with the
last character in your document.

368
00:21:36.736 --> 00:21:37.706
It's simple.

369
00:21:39.576 --> 00:21:43.596
First, we'll get the index of
the character in your doc--

370
00:21:43.826 --> 00:21:48.516
the last character in a
document just at the lengths

371
00:21:48.636 --> 00:21:51.236
of the document and
subtract one.

372
00:21:52.266 --> 00:21:57.876
Here we are assuming that
it's not an empty document.

373
00:21:58.316 --> 00:22:01.456
Then as we discussed earlier,

374
00:21:58.316 --> 00:22:01.456
Then as we discussed earlier,

375
00:22:02.876 --> 00:22:06.006
we want to convert the
character index to glyph index.

376
00:22:06.526 --> 00:22:09.066
Here we're using the
glyphIndexForCharacterIndex

377
00:22:09.066 --> 00:22:09.336
method.

378
00:22:09.336 --> 00:22:13.036
Once you have the glyph index,

379
00:22:13.326 --> 00:22:16.626
it's easy to get the
other layout elements.

380
00:22:17.006 --> 00:22:19.186
Here we're getting
the line fragment rect

381
00:22:19.186 --> 00:22:23.866
for the glyph using the
lineFragmentRectForGlyphAtIndex.

382
00:22:25.236 --> 00:22:32.006
Then get the location of
the glyph at glyph itself.

383
00:22:32.146 --> 00:22:35.126
Now, we translate the location

384
00:22:35.496 --> 00:22:37.616
by adding the line
fragment origin

385
00:22:38.436 --> 00:22:40.766
so that the location
is now contained

386
00:22:40.846 --> 00:22:42.926
in Text Container
coordinate system.

387
00:22:44.316 --> 00:22:48.456
If you want, you can further
translate that location

388
00:22:48.456 --> 00:22:49.996
into the view coordinate system

389
00:22:50.266 --> 00:22:54.156
if the Text Container origin
is not at the view origin.

390
00:22:54.706 --> 00:22:55.586
Next example.

391
00:22:57.596 --> 00:23:00.896
In addition to the
primitive methods that acts

392
00:22:57.596 --> 00:23:00.896
In addition to the
primitive methods that acts

393
00:23:00.896 --> 00:23:03.506
as the layout information
we discussed so far,

394
00:23:03.506 --> 00:23:08.926
NSLayoutManager provides
many, many convenience methods

395
00:23:09.436 --> 00:23:10.936
to make your life easier.

396
00:23:11.596 --> 00:23:15.736
In this example we
are doing hit testing.

397
00:23:16.166 --> 00:23:21.466
We get the location of the touch
inside your text view using the

398
00:23:21.466 --> 00:23:22.646
locationInView method.

399
00:23:24.556 --> 00:23:27.826
Here we are assuming
the location.

400
00:23:28.636 --> 00:23:32.416
The view coordinate
system is equal

401
00:23:32.416 --> 00:23:35.216
to Text Container coordinate
system in this example.

402
00:23:36.946 --> 00:23:38.366
Now you have the location.

403
00:23:39.406 --> 00:23:45.766
Using the characterIndexForPoint
inTextContainer

404
00:23:46.886 --> 00:23:50.856
fractionOfDistance
BetweenInsertionPoints,

405
00:23:51.556 --> 00:23:54.966
you can get the character
index correspondent

406
00:23:54.966 --> 00:23:58.586
to the glyph closest to
the location you specify.

407
00:24:01.006 --> 00:24:05.336
Once you have the character
index, it's relatively simple

408
00:24:05.336 --> 00:24:10.736
to find out what range using
some of the NSString amenities

409
00:24:11.676 --> 00:24:15.086
such as
enumerateSubstringsInRange:

410
00:24:15.166 --> 00:24:16.806
options:usingBlock: method.

411
00:24:18.396 --> 00:24:20.966
So we are not going deep

412
00:24:20.966 --> 00:24:24.786
into the actual implementation
finding the word range,

413
00:24:25.046 --> 00:24:30.346
but you can do so
pretty trivially.

414
00:24:33.416 --> 00:24:40.856
Next. Usually, we recommend
sticking to UIKit objects

415
00:24:41.336 --> 00:24:45.436
such as UITextView and UILevel

416
00:24:45.436 --> 00:24:48.726
for all your text
rendering needs.

417
00:24:50.096 --> 00:24:52.836
Because with the
deeper integration

418
00:24:52.926 --> 00:24:54.426
with the attribute string,

419
00:24:55.186 --> 00:24:59.376
these objects now provide
sufficient functionalities

420
00:24:59.376 --> 00:25:04.146
and extensibilities for your
needs while you can enjoy Text

421
00:24:59.376 --> 00:25:04.146
and extensibilities for your
needs while you can enjoy Text

422
00:25:04.536 --> 00:25:10.566
Kit and amenities such as
old layout and accessibility.

423
00:25:10.956 --> 00:25:14.696
In some few cases,
though, you might want

424
00:25:14.696 --> 00:25:18.426
to consider rendering
NSLayoutManager

425
00:25:19.066 --> 00:25:20.396
into your custom view.

426
00:25:21.736 --> 00:25:29.506
For example, you have multiple
overlapping text image frames

427
00:25:29.906 --> 00:25:33.436
in your view, commonly
found in magazines

428
00:25:33.586 --> 00:25:36.556
or newspaper applications,

429
00:25:37.796 --> 00:25:42.386
or you want to have
custom pagination

430
00:25:43.196 --> 00:25:44.966
when you're printing
your documents.

431
00:25:46.226 --> 00:25:51.636
In this case, you could
actually directly access the

432
00:25:51.636 --> 00:25:55.606
NSLayoutManager and manually
render the contents yourself.

433
00:25:55.936 --> 00:26:01.876
Here, it's assumed this Layout
Manager variable contains

434
00:25:55.936 --> 00:26:01.876
Here, it's assumed this Layout
Manager variable contains

435
00:26:02.156 --> 00:26:04.336
preconfigured Layout Manager.

436
00:26:04.576 --> 00:26:09.476
And we have the rendering area.

437
00:26:09.816 --> 00:26:17.766
It's the area inside your view
you want to fill the glyph with.

438
00:26:17.766 --> 00:26:20.006
It's sort of, you know,
you'll get that rect

439
00:26:20.006 --> 00:26:22.136
from the direct method.

440
00:26:22.716 --> 00:26:27.896
And finally, we and-- we
have the container origin

441
00:26:28.906 --> 00:26:31.286
that contains the origin

442
00:26:31.646 --> 00:26:35.376
of the Text Container inside
your view coordinate system.

443
00:26:35.896 --> 00:26:41.166
First thing, you want to
convert the rendering area

444
00:26:41.616 --> 00:26:43.756
into the Text Container
coordinate system,

445
00:26:44.516 --> 00:26:46.256
just subtract the
container origin

446
00:26:47.756 --> 00:26:53.566
from the bounding rect frame.

447
00:26:53.766 --> 00:26:54.926
Then use

448
00:26:54.966 --> 00:26:58.066
that glyphRangeForBoundingRect
inTextContainer,

449
00:26:58.356 --> 00:26:59.756
another useful method.

450
00:27:00.386 --> 00:27:04.226
You can get the glyph
range that are filling

451
00:27:04.226 --> 00:27:06.246
that specify that bounding rect.

452
00:27:06.826 --> 00:27:12.736
Notice that that glyph range
might contain some extra glyphs

453
00:27:12.736 --> 00:27:14.876
outside of bounding
rect actually.

454
00:27:15.636 --> 00:27:20.796
It's because we're handling
the bidirectional language

455
00:27:20.796 --> 00:27:22.656
such as Arabic and Hebrew,

456
00:27:23.276 --> 00:27:25.956
the glyph location
could be out of order.

457
00:27:26.796 --> 00:27:29.866
So in order to contain
all the glyph range,

458
00:27:30.246 --> 00:27:34.146
some of the glyph might be lying
outside of the bounding rect.

459
00:27:35.296 --> 00:27:37.576
So in those cases, you
might consider clipping

460
00:27:38.346 --> 00:27:41.816
when you are rendering.

461
00:27:41.866 --> 00:27:45.556
Once you have the glyph
range, you can render.

462
00:27:46.976 --> 00:27:51.976
Here we are rendering
the background using

463
00:27:51.976 --> 00:27:54.666
that drawBackgroundForGlyphRange
atPoint.

464
00:27:55.926 --> 00:27:58.476
This method renders attributes

465
00:27:58.476 --> 00:28:01.656
such as
NSBackgroundColorAttributeName.

466
00:27:58.476 --> 00:28:01.656
such as
NSBackgroundColorAttributeName.

467
00:28:02.736 --> 00:28:08.016
But we recommend always using
this method whenever you are

468
00:28:08.016 --> 00:28:09.036
rendering glyphs.

469
00:28:09.616 --> 00:28:15.706
It's because in the future,
we might enhance this method

470
00:28:15.706 --> 00:28:17.506
to support some other
attributes.

471
00:28:18.256 --> 00:28:22.226
In that case, your application
automatically get the new

472
00:28:22.226 --> 00:28:25.346
functionalities out of it.

473
00:28:25.886 --> 00:28:27.426
Once you render the background,

474
00:28:28.096 --> 00:28:33.216
now render the glyphs using
the drawGlyphsForGlyohRange

475
00:28:33.216 --> 00:28:34.126
atPoint method.

476
00:28:35.166 --> 00:28:39.046
It renders a glyph in
the glyph range as well

477
00:28:39.046 --> 00:28:45.606
as other auxiliary graphical
items such as underlines,

478
00:28:45.856 --> 00:28:49.926
strikethrough, shadows
and attachments.

479
00:28:50.096 --> 00:28:54.556
You might have noticed that we
are passing container origin

480
00:28:54.556 --> 00:28:55.606
to these methods.

481
00:28:56.156 --> 00:28:59.786
So we are rendering an
arbitrary glyph range,

482
00:29:01.016 --> 00:29:06.706
but you are not passing
some location corresponding

483
00:29:06.706 --> 00:29:08.376
to the glyph range
to drawing method.

484
00:29:08.816 --> 00:29:11.286
Maybe that's not
what you are used to.

485
00:29:11.716 --> 00:29:14.836
Actually, it's quite
simple and straightforward.

486
00:29:15.316 --> 00:29:21.276
It's because Layout
Manager is designed

487
00:29:21.306 --> 00:29:23.646
to render Text Containers.

488
00:29:24.206 --> 00:29:28.826
So even though you are
passing the glyph range a part

489
00:29:28.826 --> 00:29:34.616
of the Text Container, you are
always rendering Text Container

490
00:29:34.616 --> 00:29:39.416
itself and rendering contents.

491
00:29:40.126 --> 00:29:43.106
So when you're passing
the location,

492
00:29:43.616 --> 00:29:46.786
it's always at the
Text Container origin.

493
00:29:46.786 --> 00:29:50.946
Now that doesn't necessary
mean you will start

494
00:29:50.946 --> 00:29:53.176
with your original
Text Container shape.

495
00:29:54.486 --> 00:29:58.336
You are free to translate
the location by yourself

496
00:29:58.336 --> 00:30:04.276
so that the location paths

497
00:29:58.336 --> 00:30:04.276
so that the location paths

498
00:30:05.736 --> 00:30:08.756
to the rendering
method can be arbitrary

499
00:30:09.236 --> 00:30:11.776
and your glyph range
can be moved

500
00:30:11.776 --> 00:30:13.916
to some other places
in the view.

501
00:30:14.476 --> 00:30:17.696
Here we have the glyph
range we want to render.

502
00:30:18.416 --> 00:30:20.616
That's some range inside
your Text Container.

503
00:30:21.246 --> 00:30:24.406
And we have the location.

504
00:30:24.856 --> 00:30:27.576
We want that glyph
range to appear

505
00:30:27.576 --> 00:30:29.696
at the location inside of view.

506
00:30:30.196 --> 00:30:30.636
First,

507
00:30:31.196 --> 00:30:34.056
using
lineFragmentRectForGlyphAtIndex

508
00:30:34.056 --> 00:30:40.256
method we saw earlier, we
get the line fragment origin

509
00:30:41.006 --> 00:30:42.646
for the glyph you
want to render.

510
00:30:43.126 --> 00:30:46.996
So in this case, you
get the line rect

511
00:30:46.996 --> 00:30:49.426
for the first glyph
in the glyph range.

512
00:30:50.866 --> 00:30:56.256
Once you get that, you
subtract the glyph origin

513
00:30:56.786 --> 00:30:58.236
from the location
you want to render.

514
00:31:00.116 --> 00:31:04.366
By doing that, the
location is now translated

515
00:31:05.896 --> 00:31:13.446
so that the Text Container
origin is moved far

516
00:31:13.446 --> 00:31:19.956
and the location coincide to the
glyph range you want to render.

517
00:31:20.116 --> 00:31:24.066
Now, you have the
location, just render it.

518
00:31:24.476 --> 00:31:31.026
Another common questions we
get at labs and mailing lists,

519
00:31:31.696 --> 00:31:36.496
it's like number of
lines in your document.

520
00:31:38.306 --> 00:31:39.496
It's really simple.

521
00:31:41.136 --> 00:31:44.346
But it was actually
difficult before Text Kit.

522
00:31:45.666 --> 00:31:49.576
With the Text Kits, since
NSLayoutManager keeps tracks

523
00:31:49.726 --> 00:31:55.396
of all the line fragment rect in
your documents, it's easy now.

524
00:31:56.356 --> 00:32:01.396
Remember, a visual
line could be divided

525
00:31:56.356 --> 00:32:01.396
Remember, a visual
line could be divided

526
00:32:01.396 --> 00:32:05.696
into multiple line fragments
because of the exclusion path.

527
00:32:06.656 --> 00:32:12.756
You want to store the Y location
of the line fragment and using

528
00:32:12.756 --> 00:32:15.946
that cache value,
you want to compare

529
00:32:15.946 --> 00:32:19.346
to the current line fragment
rect before answering

530
00:32:19.346 --> 00:32:21.546
incremental number of lines.

531
00:32:23.976 --> 00:32:27.256
Here using the glyph
range for Text Container,

532
00:32:28.556 --> 00:32:33.456
you can get the glyph range
inside the Text Container and,

533
00:32:33.616 --> 00:32:37.206
you know, you should get
used to this method by now,

534
00:32:37.706 --> 00:32:41.156
lineFragmentRectForGlyphAtIndex
effectiveRange.

535
00:32:41.756 --> 00:32:49.206
And as I described it earlier,
you can pass a point out to--

536
00:32:49.366 --> 00:32:55.896
a point out to NSRange and
get back the glyph range

537
00:32:55.976 --> 00:32:58.146
corresponding to the
line fragment rect.

538
00:32:58.696 --> 00:33:04.316
And here we are enumerating all
the line fragment rect inside

539
00:32:58.696 --> 00:33:04.316
And here we are enumerating all
the line fragment rect inside

540
00:33:04.606 --> 00:33:13.536
the fixed container by comparing
the stored last line fragment

541
00:33:13.536 --> 00:33:16.466
origin to the current
line fragment origin.

542
00:33:17.426 --> 00:33:22.176
If the new origin is larger,
that means you are moved

543
00:33:22.176 --> 00:33:26.156
to the new visual line so that
you can increment the number

544
00:33:26.216 --> 00:33:30.916
of lines like this.

545
00:33:31.706 --> 00:33:36.806
And at data stored
information was the new line

546
00:33:36.846 --> 00:33:37.636
fragment origin.

547
00:33:38.296 --> 00:33:39.256
It's that simple.

548
00:33:40.006 --> 00:33:44.136
We've seen glyphs and
layout informations stored

549
00:33:44.136 --> 00:33:48.716
in NSLayoutManager there
are endless possibilities

550
00:33:48.716 --> 00:33:55.646
that you can do with the broader
and finer controls you have

551
00:33:55.786 --> 00:34:00.426
in your text using
the information stored

552
00:33:55.786 --> 00:34:00.426
in your text using
the information stored

553
00:34:00.426 --> 00:34:03.766
in NSLayoutManager and
you can freely access now.

554
00:34:04.466 --> 00:34:10.926
But the control over your
text doesn't end there.

555
00:34:11.146 --> 00:34:16.846
One of the main Text Kit
architecture strength is its

556
00:34:16.846 --> 00:34:19.485
vast support for customization.

557
00:34:19.815 --> 00:34:25.366
Let's look at how to customize
layout using Text Kit.

558
00:34:25.366 --> 00:34:30.726
NSLayoutManager provides a rich
set of delegation interface.

559
00:34:31.295 --> 00:34:36.585
You can-- With some of the
interface, you can get notified

560
00:34:38.016 --> 00:34:40.335
for step [phonetic]
change such as

561
00:34:40.956 --> 00:34:43.676
when your layout
cache is invited.

562
00:34:45.295 --> 00:34:50.386
Or, layout for the container was
finished, so on and so forth.

563
00:34:51.186 --> 00:34:53.936
With some other delegation
interface,

564
00:34:54.596 --> 00:34:58.226
you can override many aspects

565
00:34:58.226 --> 00:35:04.466
of layout process while
it's being laid out.

566
00:34:58.226 --> 00:35:04.466
of layout process while
it's being laid out.

567
00:35:05.076 --> 00:35:10.066
For example, you can
override the line spacing.

568
00:35:10.196 --> 00:35:13.296
Your delegate object
gets consulted at the end

569
00:35:13.296 --> 00:35:16.146
of that every single
line fragment rect

570
00:35:17.076 --> 00:35:20.336
and you can provide
your own line spacing

571
00:35:20.586 --> 00:35:24.756
at that point overriding
their values stored

572
00:35:24.866 --> 00:35:27.636
in paragraph style
associated with that text.

573
00:35:29.096 --> 00:35:32.936
So for example, with that
paragraph style line spacing

574
00:35:32.936 --> 00:35:37.466
value, a single line
spacing value is used

575
00:35:37.466 --> 00:35:39.806
for the whole paragraph.

576
00:35:40.726 --> 00:35:45.856
But using this method,
you can have custom line

577
00:35:45.856 --> 00:35:47.056
spacing everywhere.

578
00:35:48.486 --> 00:35:53.416
And this is useful when
you want to make space

579
00:35:53.466 --> 00:36:01.036
for some other extra
rendering like this.

580
00:35:53.466 --> 00:36:01.036
for some other extra
rendering like this.

581
00:36:03.156 --> 00:36:08.196
[Inaudible] a lot annotation
when you want to have this kind

582
00:36:08.196 --> 00:36:13.616
of extra rendering right below
the text you want to make space

583
00:36:15.116 --> 00:36:19.386
and you don't know if you
want to make the space

584
00:36:20.376 --> 00:36:22.716
when you are creating
the text layout itself,

585
00:36:23.116 --> 00:36:25.006
so you have to determine
this kind

586
00:36:25.006 --> 00:36:30.906
of layout conditions dynamical
while you are laying out.

587
00:36:30.906 --> 00:36:37.786
Similar to the line
spacing, you can override

588
00:36:37.986 --> 00:36:44.786
with soft wrapping line--
soft wrapping lines at the end

589
00:36:44.786 --> 00:36:48.516
of every single soft
wrapping-- soft line breaking.

590
00:36:48.516 --> 00:36:52.186
So there it gets consulted.

591
00:37:00.556 --> 00:37:08.326
And by default, we are using
the line breaking logic provided

592
00:37:08.326 --> 00:37:11.716
by the Unicode standard,
so it should be sufficient

593
00:37:11.936 --> 00:37:17.636
for most cases, and it provides
a localized way of line breaking

594
00:37:17.696 --> 00:37:21.976
for every language
available on iOS.

595
00:37:22.606 --> 00:37:27.286
But in some few cases, you
want to enhance the ways

596
00:37:27.286 --> 00:37:30.946
of the line wrapping happens
for your typographic needs.

597
00:37:31.916 --> 00:37:35.666
In that case, you are
[inaudible] to override

598
00:37:36.146 --> 00:37:42.386
that line wrapping
phase like this.

599
00:37:42.586 --> 00:37:47.896
Another powerful feature
techniques you can use

600
00:37:47.946 --> 00:37:53.366
with delegation, by default,
NSLayoutManager uses the mapping

601
00:37:53.486 --> 00:37:57.896
between character and glyphs
stored inside the font itself.

602
00:37:57.896 --> 00:38:00.156
That's the default
glyph mapping.

603
00:37:57.896 --> 00:38:00.156
That's the default
glyph mapping.

604
00:38:01.906 --> 00:38:05.746
You can override this
glyph mapping all

605
00:38:05.746 --> 00:38:11.186
by yourself while it's
laying out of text.

606
00:38:11.996 --> 00:38:13.226
This is powerful.

607
00:38:13.226 --> 00:38:16.546
It's used by, for example,
bullet substitution

608
00:38:17.046 --> 00:38:22.376
in security mode or when you
want to hide some portion

609
00:38:22.376 --> 00:38:25.466
of text when you are
folding the line.

610
00:38:25.636 --> 00:38:31.646
And there are many,
many other ways

611
00:38:33.156 --> 00:38:36.586
to customize your text layout

612
00:38:37.216 --> 00:38:43.116
like a dynamic query
while it's being laid out.

613
00:38:43.406 --> 00:38:45.486
Today, I would like to look

614
00:38:45.486 --> 00:38:49.746
at the custom glyph
mapping a little farther.

615
00:38:50.046 --> 00:38:54.726
When you had text and
the text doesn't fit

616
00:38:54.726 --> 00:38:59.446
into the available space,
it's a common technique used

617
00:39:00.336 --> 00:39:03.856
to tail truncation like this.

618
00:39:04.056 --> 00:39:07.386
But with the simple
tail truncation logic,

619
00:39:08.056 --> 00:39:14.936
you might encounter, the actual
important information might be

620
00:39:15.016 --> 00:39:18.526
truncated out from
the user's view.

621
00:39:19.836 --> 00:39:21.386
You don't like that.

622
00:39:23.296 --> 00:39:26.546
So using the custom
glyph generation logic,

623
00:39:27.366 --> 00:39:33.776
you can override and add
additional truncation range

624
00:39:34.436 --> 00:39:39.776
to your string and make
sure your important range

625
00:39:39.776 --> 00:39:42.426
of text is visible to the user.

626
00:39:42.946 --> 00:39:45.506
Let's see how we
can accomplish that.

627
00:39:45.616 --> 00:39:51.646
First, with NSLayout method--
NSLayoutManager method,

628
00:39:52.746 --> 00:39:57.576
truncatedGlyphRangeInLine
FragmentForGlyphAtIndex method,

629
00:39:58.576 --> 00:40:02.946
you can get the range of the
glyphs that's being truncated

630
00:39:58.576 --> 00:40:02.946
you can get the range of the
glyphs that's being truncated

631
00:40:02.946 --> 00:40:07.716
out from the user's view.

632
00:40:09.376 --> 00:40:14.366
And you can compare this
range with your focus range,

633
00:40:14.756 --> 00:40:17.436
for example, when you
are searching some words,

634
00:40:17.976 --> 00:40:23.046
you want to keep the-- match the
words inside the user's view.

635
00:40:24.566 --> 00:40:26.656
When it matches this range,

636
00:40:27.176 --> 00:40:30.586
you want to truncate
additional location.

637
00:40:31.016 --> 00:40:36.116
In that case, we estimate the
additional truncation range

638
00:40:37.636 --> 00:40:42.606
probably using the
[inaudible] being truncated out.

639
00:40:43.986 --> 00:40:45.266
Now we layout.

640
00:40:45.966 --> 00:40:52.536
Inside the layout process, your
delegate method, layoutManager:

641
00:40:52.536 --> 00:40:57.306
shouldGenerateGlyphs:
properties:characterIndexes:

642
00:40:57.306 --> 00:41:01.036
font:forGlyphRange
method get being called.

643
00:40:57.306 --> 00:41:01.036
font:forGlyphRange
method get being called.

644
00:41:01.696 --> 00:41:05.566
And inside this method, you
can override the default

645
00:41:05.566 --> 00:41:06.266
glyph mapping.

646
00:41:06.896 --> 00:41:10.356
So, you can do whatever
you want.

647
00:41:10.916 --> 00:41:19.506
In this case, we substitute
the default glyph mapping

648
00:41:19.996 --> 00:41:21.106
with [inaudible]
glyphs and truncate.

649
00:41:21.106 --> 00:41:24.906
It's that simple.

650
00:41:26.676 --> 00:41:31.426
And repeat itself until
you find the ideal range

651
00:41:31.936 --> 00:41:33.046
that fits everything.

652
00:41:33.396 --> 00:41:36.476
Well then let's take a look
at the delegate method itself.

653
00:41:36.896 --> 00:41:39.316
The delegate method is called

654
00:41:39.706 --> 00:41:44.606
for all the text ranges
inside your Text Storage

655
00:41:45.196 --> 00:41:49.276
when it gets mapped to glyphs.

656
00:41:49.276 --> 00:41:53.486
It receives glyph's
properties and character indexes

657
00:41:54.836 --> 00:41:56.096
for the chunk of text.

658
00:41:57.686 --> 00:41:59.506
And this is a default
information

659
00:41:59.796 --> 00:42:02.356
and you can override
any way you want

660
00:41:59.796 --> 00:42:02.356
and you can override
any way you want

661
00:42:02.626 --> 00:42:06.276
until you have your delegate
object and your implementation

662
00:42:06.466 --> 00:42:09.156
of the delegate method.

663
00:42:09.316 --> 00:42:12.096
You will see a chunk of glyphs.

664
00:42:17.436 --> 00:42:22.596
Look through it and you
find a particular range

665
00:42:22.716 --> 00:42:28.176
of glyph matches your focus
range and you can check

666
00:42:28.356 --> 00:42:31.696
against using the
original character index.

667
00:42:32.286 --> 00:42:38.226
When that happens,
you override pass

668
00:42:38.476 --> 00:42:41.816
in glyphs information
with ellipsis glyph.

669
00:42:48.706 --> 00:42:54.316
And you might wonder what are
these things after ellipsis.

670
00:42:55.616 --> 00:42:58.886
In order to keep the character
and glyph index simple

671
00:42:58.986 --> 00:43:02.836
and be efficient,
NSLayoutManager often try

672
00:42:58.986 --> 00:43:02.836
and be efficient,
NSLayoutManager often try

673
00:43:02.836 --> 00:43:07.666
to pad the glyph range that's
being hidden from the users.

674
00:43:08.366 --> 00:43:13.346
To do so, the glyph
property is working here.

675
00:43:13.346 --> 00:43:15.176
What is the glyph property?

676
00:43:16.656 --> 00:43:18.476
So it's like other
glyph information.

677
00:43:18.846 --> 00:43:23.566
Glyph NSLayoutManager keeps
track of glyph property

678
00:43:23.646 --> 00:43:29.436
for glyph and it stores semantic
behavior for each glyph.

679
00:43:29.746 --> 00:43:34.166
For example, you can identify
a glyph as a control character

680
00:43:34.296 --> 00:43:37.196
like a tab or a new
line, so on and so forth.

681
00:43:38.246 --> 00:43:44.416
Or, a glyph could be white space
that can be treated as elastic

682
00:43:44.416 --> 00:43:47.626
at the end of the line break.

683
00:43:48.546 --> 00:43:52.806
In our example, we are
using this property,

684
00:43:53.226 --> 00:43:56.906
NSGlyphPropertyNull, by
displaying this property,

685
00:43:57.456 --> 00:44:02.806
the glyph will be treated
as the glyph will be ignored

686
00:43:57.456 --> 00:44:02.806
the glyph will be treated
as the glyph will be ignored

687
00:44:02.806 --> 00:44:05.366
from both layout and rendering.

688
00:44:06.466 --> 00:44:08.176
So, you can hide a part

689
00:44:08.176 --> 00:44:10.476
of the glyph range
from the user's view.

690
00:44:10.886 --> 00:44:17.966
Now, I'd like to point
our Text Kit demo maester,

691
00:44:18.976 --> 00:44:24.486
Jordan Breeding to show that
multiple truncations demo.

692
00:44:25.436 --> 00:44:25.876
Jordan.

693
00:44:25.876 --> 00:44:30.516
>> So, what I'm going to
show you right now is a view

694
00:44:30.516 --> 00:44:32.776
controller inside of our
demo shell that we used

695
00:44:32.776 --> 00:44:34.196
in the Intro session as well.

696
00:44:35.666 --> 00:44:38.046
In this case, instead
of using a UITextView,

697
00:44:38.046 --> 00:44:43.156
we're actually using a new
class, a text rendering view.

698
00:44:44.206 --> 00:44:47.116
This is a UIView subclass
in which we are going

699
00:44:47.116 --> 00:44:50.086
to render the glyphs ourselves
to achieve multiple truncation.

700
00:44:51.336 --> 00:44:53.616
First, I'll show
you at running live

701
00:44:53.696 --> 00:44:57.986
and then we'll explain
what some of the code does.

702
00:44:58.186 --> 00:45:02.526
Now we're building and running.

703
00:44:58.186 --> 00:45:02.526
Now we're building and running.

704
00:45:02.656 --> 00:45:05.306
And when we run the
demo, you'll notice

705
00:45:05.306 --> 00:45:06.936
that we have highlighted
the range

706
00:45:06.936 --> 00:45:10.226
so that we are concerned
about not truncating.

707
00:45:10.776 --> 00:45:18.306
And as we get closer and
closer to that, you'll notice

708
00:45:19.166 --> 00:45:21.656
that it automatically starts
to truncate to the left

709
00:45:22.626 --> 00:45:26.656
so that we keep it intact.

710
00:45:26.936 --> 00:45:28.236
So, how do we do that?

711
00:45:28.826 --> 00:45:30.856
Well, in the text
rendering view,

712
00:45:31.166 --> 00:45:33.196
we actually made a new
class called a focus

713
00:45:33.196 --> 00:45:34.266
truncation renderer.

714
00:45:34.876 --> 00:45:36.646
We setup an instance
variable for that.

715
00:45:36.646 --> 00:45:40.506
And then awakeFromNib,
we actually setup some

716
00:45:40.506 --> 00:45:43.026
of our data including
the focus range

717
00:45:43.026 --> 00:45:45.426
that we are concerned
with keeping intact.

718
00:45:46.866 --> 00:45:50.446
Then in our draw rect, we
setup some basic information

719
00:45:50.446 --> 00:45:52.226
and then we also
tell our renderer

720
00:45:52.726 --> 00:45:57.636
to use each drawing rect
to draw in the same place.

721
00:45:57.796 --> 00:46:00.536
So if we go over to our
focus truncation renderer,

722
00:45:57.796 --> 00:46:00.536
So if we go over to our
focus truncation renderer,

723
00:46:01.646 --> 00:46:03.526
you'll notice that when
we setup the contents

724
00:46:03.576 --> 00:46:07.326
for the Text Storage,
we also set ourselves

725
00:46:07.326 --> 00:46:09.636
as the Layout Manager's
delegate right here.

726
00:46:11.976 --> 00:46:18.526
The reason that we do that
is then in our draw and rect,

727
00:46:19.166 --> 00:46:23.986
when we actually draw
all of our characters

728
00:46:24.956 --> 00:46:27.696
and we know whether we need
to force tail truncation

729
00:46:28.136 --> 00:46:32.016
and truncate ahead of time
or not, all of this calls

730
00:46:32.016 --> 00:46:35.616
to Layout Manager will actually
consult us for glyph generation.

731
00:46:39.216 --> 00:46:43.736
So, all these calls
end up calling

732
00:46:43.736 --> 00:46:44.956
down into our delegate method.

733
00:46:45.536 --> 00:46:48.386
In this case, layoutManager:
shouldGenerateGlyphs:

734
00:46:48.576 --> 00:46:51.426
properties:characterIndexes:
font:forGlyphRange.

735
00:46:51.666 --> 00:46:53.026
This is the method Aki pointed

736
00:46:53.026 --> 00:46:55.226
out for laying out
custom glyphs.

737
00:46:56.076 --> 00:46:58.256
So, what are we actually
doing here?

738
00:46:58.976 --> 00:47:00.066
Well, first, we're finding

739
00:46:58.976 --> 00:47:00.066
Well, first, we're finding

740
00:47:00.066 --> 00:47:01.916
out if we have an
intersection range.

741
00:47:03.526 --> 00:47:07.066
And then in our actual code,

742
00:47:07.066 --> 00:47:11.006
we're checking the character
indexes that we've been passed

743
00:47:11.066 --> 00:47:12.216
by the Layout Manager.

744
00:47:12.896 --> 00:47:16.776
And if they're inside the target
range, we know that we need

745
00:47:16.776 --> 00:47:18.206
to use the ellipsis glyph.

746
00:47:19.466 --> 00:47:21.666
So, we get the character
for the ellipsis glyph

747
00:47:21.726 --> 00:47:24.376
and then we get the
glyph for the characters

748
00:47:24.376 --> 00:47:26.156
and then we actually
do the replacement.

749
00:47:27.296 --> 00:47:28.886
Then, just like Aki said,

750
00:47:29.386 --> 00:47:32.966
we actually change the other
glyph character properties

751
00:47:33.026 --> 00:47:37.356
to be the control character
and the null character

752
00:47:37.356 --> 00:47:39.586
so that everything just
lays out automatically

753
00:47:39.656 --> 00:47:41.886
for us in our draw rect.

754
00:47:42.586 --> 00:47:45.216
It's actually just
as simple as that.

755
00:47:45.316 --> 00:47:47.086
It was a lot harder
before, right?

756
00:47:48.226 --> 00:47:51.506
Next, I'd like to have
Aki come back up and close

757
00:47:51.506 --> 00:47:52.556
out our session for us.

758
00:47:53.126 --> 00:47:56.746
>> We saw you can use
the gorgeous text layouts

759
00:47:56.746 --> 00:47:58.376
in your applications.

760
00:47:58.876 --> 00:48:05.996
And you learned how to
achieve multiple page,

761
00:47:58.876 --> 00:48:05.996
And you learned how to
achieve multiple page,

762
00:48:05.996 --> 00:48:09.046
multiple document
configuration easy--

763
00:48:09.776 --> 00:48:14.376
easily with the application.

764
00:48:14.376 --> 00:48:21.546
And we covered the rich in text
layout information provided

765
00:48:22.306 --> 00:48:26.676
through the NSLayoutManager API.

766
00:48:27.046 --> 00:48:36.926
And finally, we saw some aspect
of the Text Kit customizability

767
00:48:37.846 --> 00:48:40.436
that was previously
not possible.

768
00:48:42.536 --> 00:48:51.436
So, Text Kit is not just another
text API you need to learn.

769
00:48:51.986 --> 00:48:55.946
With the deep integration
with UIKit,

770
00:48:57.246 --> 00:49:01.316
comprehensive functionalities
and broad customizability,

771
00:48:57.246 --> 00:49:01.316
comprehensive functionalities
and broad customizability,

772
00:49:02.696 --> 00:49:08.036
we believe it will be the last

773
00:49:08.036 --> 00:49:12.296
and only text API even be
working for years to come.

774
00:49:13.066 --> 00:49:16.386
If you want to know more,

775
00:49:16.386 --> 00:49:19.556
you can contact our
evangelist, Jake Behrens.

776
00:49:20.346 --> 00:49:24.086
And we have two related
sessions,

777
00:49:24.476 --> 00:49:28.606
one already happened
yesterday and another coming

778
00:49:28.666 --> 00:49:31.726
up tomorrow morning
at 9:00 at Presidio.

779
00:49:33.076 --> 00:49:35.126
And that's going to talk

780
00:49:35.126 --> 00:49:39.096
about the technology
behind the dynamic type.

781
00:49:39.436 --> 00:49:42.046
And if you want to know how

782
00:49:42.046 --> 00:49:46.306
to utilize all the cool
technologies such as UIFont

783
00:49:46.306 --> 00:49:49.166
and UIFont Descriptor,
you want to be there.

784
00:49:49.346 --> 00:49:53.836
So, thank you and enjoy
the rest of the conference.

785
00:49:54.516 --> 00:49:58.480
[ Applause ]
