
1
00:00:00.506 --> 00:00:09.456
[ Silence ]

2
00:00:09.956 --> 00:00:14.496
>> Hi. I'm Ian Baird, iOS
Text Kit Lead Engineer.

3
00:00:15.056 --> 00:00:16.966
And today, I would
like to talk to you

4
00:00:16.966 --> 00:00:20.546
about what I personally think
is one of the coolest features

5
00:00:21.036 --> 00:00:23.246
in iOS 7, and I know
you're going to want

6
00:00:23.246 --> 00:00:24.826
to use it in your app.

7
00:00:24.956 --> 00:00:28.766
I want to introduce
you to Text Kit.

8
00:00:30.956 --> 00:00:34.036
First, let's lay out an
agenda for today's talk.

9
00:00:35.006 --> 00:00:37.166
We're going to talk a little
bit about the motivation,

10
00:00:37.516 --> 00:00:40.786
why we created Text Kit.

11
00:00:40.996 --> 00:00:44.306
Next, we're going to talk
about what is Text Kit,

12
00:00:44.616 --> 00:00:46.846
how it's composed, and
why you should care.

13
00:00:47.556 --> 00:00:54.326
And then we're going to give
you a quick tour of some

14
00:00:54.326 --> 00:00:55.956
of the headline features
in Text Kit,

15
00:00:55.956 --> 00:00:57.926
and I think you're
going to be impressed.

16
00:00:59.346 --> 00:01:00.636
And finally, we're going to wrap

17
00:00:59.346 --> 00:01:00.636
And finally, we're going to wrap

18
00:01:00.636 --> 00:01:05.396
up with an awesome demo
showing you how to use

19
00:01:05.636 --> 00:01:10.036
and display Rich Text inside
of your app in noble ways

20
00:01:10.036 --> 00:01:12.806
that you can only
do using iOS 7.

21
00:01:14.396 --> 00:01:15.566
So let's get started.

22
00:01:15.986 --> 00:01:16.626
Motivation.

23
00:01:17.296 --> 00:01:19.326
Why did we do Text Kit?

24
00:01:20.636 --> 00:01:24.256
Well, quite simply, we
needed it to realize the type

25
00:01:24.256 --> 00:01:30.226
of graphically heavy and complex
designs that you see in iOS 7.

26
00:01:30.866 --> 00:01:38.196
In the beginning,
we had NSString --

27
00:01:38.196 --> 00:01:41.916
sorry, we had String
Drawing and we had WebKit

28
00:01:42.476 --> 00:01:45.696
which were both based on
Core Text and Core Graphics.

29
00:01:46.216 --> 00:01:50.826
And upon the stack, we were
able to build almost all

30
00:01:50.826 --> 00:01:53.146
of the UIText components.

31
00:01:53.686 --> 00:01:55.926
And this worked really
well for many people.

32
00:01:55.926 --> 00:01:58.266
And like yourself, I was
a third-party developer

33
00:01:58.546 --> 00:02:00.786
and I made great
apps using the stack.

34
00:01:58.546 --> 00:02:00.786
and I made great
apps using the stack.

35
00:02:00.786 --> 00:02:03.926
But occasionally,
it wasn't enough.

36
00:02:04.776 --> 00:02:07.466
You'd have to drop down to
Core Text to turn on kerning

37
00:02:08.006 --> 00:02:10.226
or to have ligated glyphs.

38
00:02:11.226 --> 00:02:16.866
And as we all know, Core
Text is very advanced.

39
00:02:17.436 --> 00:02:19.346
I read your tweets.

40
00:02:19.576 --> 00:02:20.736
I saw what you guys said.

41
00:02:22.376 --> 00:02:24.986
As a matter of fact,
somebody even called it a rite

42
00:02:25.686 --> 00:02:27.586
of passage.

43
00:02:27.706 --> 00:02:30.946
And this complexity is really
just inherent in the system

44
00:02:31.186 --> 00:02:34.696
because Core Text is an
advanced Unicode layout engine.

45
00:02:35.796 --> 00:02:38.976
You use it to build
a complex text system

46
00:02:39.576 --> 00:02:42.206
or a web toolkit on top of it.

47
00:02:42.536 --> 00:02:46.606
It's really overkill to use it
to render a label especially

48
00:02:46.606 --> 00:02:48.746
when all you want to
do is kern your text.

49
00:02:50.076 --> 00:02:54.626
So that being said, the
great thing about Text Kit

50
00:02:54.806 --> 00:02:59.656
and Text Kit's design is that if
you've invested the time to come

51
00:02:59.656 --> 00:03:04.436
up to speed on Core Text,
this time is not lost.

52
00:02:59.656 --> 00:03:04.436
up to speed on Core Text,
this time is not lost.

53
00:03:04.916 --> 00:03:06.206
The way the system is layered,

54
00:03:06.536 --> 00:03:10.096
most concepts are Toll-Free
Bridged to Text Kit.

55
00:03:10.716 --> 00:03:14.926
You can use a CTFont for a
UIFont, a UIFont descriptor

56
00:03:15.236 --> 00:03:16.586
for a CTFont descriptor.

57
00:03:16.696 --> 00:03:17.476
It's that easy.

58
00:03:18.516 --> 00:03:23.856
[ Applause ]

59
00:03:24.356 --> 00:03:26.546
You know what, if you
couldn't use Core Text,

60
00:03:28.006 --> 00:03:31.526
a lot of you would embed
rich web content inside

61
00:03:31.526 --> 00:03:32.416
of your application.

62
00:03:32.926 --> 00:03:33.776
And this is great.

63
00:03:34.396 --> 00:03:38.106
UIWebView is awesome for
embedding web content.

64
00:03:38.606 --> 00:03:42.146
And the reason it's awesome is
because it's built on WebKit

65
00:03:42.636 --> 00:03:46.676
and WebKit is the preeminent
HTML rendering system

66
00:03:46.676 --> 00:03:47.756
for the mobile platform.

67
00:03:47.936 --> 00:03:50.346
It's awesome, it kicks ass.

68
00:03:51.016 --> 00:03:52.836
Unfortunately, there
are a couple of places

69
00:03:52.836 --> 00:03:55.836
where you can't really use
it, like in ScrollViews.

70
00:03:56.486 --> 00:03:59.366
And this had unfortunate
consequences

71
00:03:59.946 --> 00:04:03.286
for UIText components
that were built on top

72
00:03:59.946 --> 00:04:03.286
for UIText components
that were built on top

73
00:04:03.286 --> 00:04:04.826
of WebViews like TextView.

74
00:04:05.126 --> 00:04:07.886
It made it really hard
to use them in places

75
00:04:07.926 --> 00:04:11.636
like collection view or
table view cells or anything

76
00:04:11.636 --> 00:04:13.086
which required animations.

77
00:04:14.356 --> 00:04:18.396
So we were faced with all
these challenges and we looked

78
00:04:18.396 --> 00:04:20.245
around the company to
see what we could do.

79
00:04:20.245 --> 00:04:23.976
How could we expose
the power or Core Text

80
00:04:24.286 --> 00:04:28.806
without exposing our developers
to the necessary complexity

81
00:04:28.906 --> 00:04:31.506
of an advanced Unicode
layout engine?

82
00:04:32.266 --> 00:04:34.576
And I think you're going
to love our answer to this.

83
00:04:35.426 --> 00:04:40.826
Our answer to this
problem is Text Kit.

84
00:04:42.276 --> 00:04:43.596
So what is Text Kit?

85
00:04:44.676 --> 00:04:47.566
Well, if you are going
to take away one point

86
00:04:47.986 --> 00:04:52.096
from my talk today, I'd like you
to know that Text Kit is a fast,

87
00:04:52.556 --> 00:04:55.446
modern text layout
and rendering engine.

88
00:04:56.996 --> 00:05:00.206
It's built on top of Core Text.

89
00:04:56.996 --> 00:05:00.206
It's built on top of Core Text.

90
00:05:01.216 --> 00:05:02.436
And so this is awesome.

91
00:05:02.606 --> 00:05:05.486
It gives you all the power
and flexibility of Core Text

92
00:05:05.626 --> 00:05:09.116
without exposing you
to the hairy API.

93
00:05:09.836 --> 00:05:12.636
A hairy API which uses CF types

94
00:05:12.636 --> 00:05:14.126
which as we know are
not necessarily --

95
00:05:14.126 --> 00:05:17.466
aren't friendly or developer --
or easy for developers to use.

96
00:05:19.116 --> 00:05:22.956
And even better,
it features great,

97
00:05:23.606 --> 00:05:26.396
and I mean great
integration with UIKit.

98
00:05:27.006 --> 00:05:27.976
What does this do for you?

99
00:05:33.076 --> 00:05:38.606
Well, it gives you
everything that you want

100
00:05:38.686 --> 00:05:39.726
because it's built --

101
00:05:40.876 --> 00:05:45.296
everything, all of the
UIText components are built

102
00:05:45.586 --> 00:05:47.236
on top of Text Kit.

103
00:05:48.516 --> 00:05:54.086
[ Applause ]

104
00:05:54.586 --> 00:05:56.116
And as I was saying
a moment ago,

105
00:05:56.416 --> 00:06:00.226
this gives you complete control
over all of the text rendering

106
00:05:56.416 --> 00:06:00.226
this gives you complete control
over all of the text rendering

107
00:06:01.006 --> 00:06:02.776
in your UIText elements.

108
00:06:04.176 --> 00:06:07.266
UITextField, UITextView,

109
00:06:07.566 --> 00:06:13.726
and UILabel were completely
rebuilt on top of Text Kit.

110
00:06:14.206 --> 00:06:17.316
And so this gives you seamless
integration with animations,

111
00:06:17.806 --> 00:06:20.386
UICollectionView,
and UITableView.

112
00:06:20.586 --> 00:06:22.316
You won't get white
flashes anymore.

113
00:06:22.316 --> 00:06:23.746
Things scroll onto screen.

114
00:06:26.166 --> 00:06:30.256
It also features an extensible
object-oriented architecture

115
00:06:30.776 --> 00:06:34.306
with support for customization
features like subclassing,

116
00:06:36.816 --> 00:06:42.346
delegation, and even has rich
support for notifications.

117
00:06:42.646 --> 00:06:46.996
If you're already using UIKit
and other Cocoa frameworks,

118
00:06:47.116 --> 00:06:48.596
you know how to use Text Kit.

119
00:06:49.316 --> 00:06:50.976
You know how to bend
it to your will.

120
00:06:55.536 --> 00:06:57.326
So, that's Text Kit.

121
00:06:58.346 --> 00:07:00.866
The next thing I want to tell
you about today is I want

122
00:06:58.346 --> 00:07:00.866
The next thing I want to tell
you about today is I want

123
00:07:00.866 --> 00:07:04.556
to give you a high-level
overview of some

124
00:07:04.556 --> 00:07:07.006
of the headline features
inside of Text Kit

125
00:07:07.336 --> 00:07:09.676
and how I think you can
use them in your app.

126
00:07:11.106 --> 00:07:13.636
And the first thing I'd like
to start out with is something

127
00:07:13.636 --> 00:07:14.976
that was difficult to do

128
00:07:15.236 --> 00:07:18.166
in years past using text
components we gave you.

129
00:07:19.076 --> 00:07:23.596
Now, using Text Kit, it's easy
to create paginated layouts.

130
00:07:24.176 --> 00:07:27.266
It's easy to lay
out text in columns.

131
00:07:29.146 --> 00:07:31.096
Text wrapping around
arbitrary figures

132
00:07:31.096 --> 00:07:35.276
and shapes, that's simple too.

133
00:07:35.516 --> 00:07:39.386
And again, as I said, you
even have superior control

134
00:07:39.626 --> 00:07:43.816
over Rich Text editing inside
of your app, and this allows you

135
00:07:43.816 --> 00:07:48.716
to have access to features
like interactive text coloring.

136
00:07:49.026 --> 00:07:52.636
As the user types into your
app, you can change attributes.

137
00:07:53.186 --> 00:07:59.646
Let's pretend I'm building
an interactive client

138
00:07:59.936 --> 00:08:02.876
for a popular internet
messaging service.

139
00:07:59.936 --> 00:08:02.876
for a popular internet
messaging service.

140
00:08:04.606 --> 00:08:06.106
Just pretend, this
is hypothetical.

141
00:08:07.676 --> 00:08:11.096
I type in my friend's handle,
and it just sort of sits there

142
00:08:11.096 --> 00:08:12.806
in the content, just
blending in.

143
00:08:13.386 --> 00:08:15.516
And you know what I'd like
to do, I'd like to view this

144
00:08:15.516 --> 00:08:18.866
with meaning, I'd like to make
a pop out to user by coloring it

145
00:08:18.936 --> 00:08:20.956
and making it stand out from
the rest of the content.

146
00:08:21.326 --> 00:08:25.846
This is now easy to do with Text
Kit, just a few lines of code.

147
00:08:27.636 --> 00:08:31.246
Text folding is also
easy to accomplish

148
00:08:31.246 --> 00:08:34.486
with just a few lines
of code in Text Kit.

149
00:08:35.785 --> 00:08:38.666
And next, this is one of the
features I think you're going

150
00:08:38.666 --> 00:08:41.376
to think is the coolest,
custom truncation.

151
00:08:42.635 --> 00:08:45.636
Well, the great thing about the
iPhone and one of the reasons

152
00:08:45.636 --> 00:08:47.836
that we love it is that
it fits in your pocket.

153
00:08:48.566 --> 00:08:51.496
The downside of that is the
screen is incredibly small,

154
00:08:52.826 --> 00:08:55.116
even on the new iPhone 5.

155
00:08:56.486 --> 00:09:00.546
And sometimes, especially
when you're using some

156
00:08:56.486 --> 00:09:00.546
And sometimes, especially
when you're using some

157
00:09:00.546 --> 00:09:04.256
of the new text styles,
not all of the content

158
00:09:04.256 --> 00:09:06.746
that your user has
selected or you want to show

159
00:09:06.746 --> 00:09:09.046
to the user will actually
fit on that display.

160
00:09:10.076 --> 00:09:12.476
So in the past, you were
stuck with tail truncation,

161
00:09:12.756 --> 00:09:14.936
head truncation, or
middle truncation.

162
00:09:15.636 --> 00:09:17.626
Using Text Kit and
a few lines of code,

163
00:09:17.626 --> 00:09:24.836
you can have custom
truncation now.

164
00:09:25.406 --> 00:09:29.986
Also enhanced in iOS 7, all
of these techniques work

165
00:09:29.986 --> 00:09:32.686
in standard controls, you
don't have to subclass TextView

166
00:09:32.686 --> 00:09:34.636
to have custom truncation
or text folding.

167
00:09:35.106 --> 00:09:35.596
Isn't that cool?

168
00:09:36.516 --> 00:09:40.746
[ Applause ]

169
00:09:41.246 --> 00:09:44.686
And building on our
heritage from iOS 6,

170
00:09:44.686 --> 00:09:46.976
in the attributed text support
that we've brought to you

171
00:09:46.976 --> 00:09:51.516
in iOS 6, we have now extended
UITextView and UITextField

172
00:09:51.516 --> 00:09:53.926
to support all text attributes.

173
00:09:54.516 --> 00:09:58.566
[ Applause ]

174
00:09:59.066 --> 00:10:01.206
And as Toby and Jason
and everyone else

175
00:09:59.066 --> 00:10:01.206
And as Toby and Jason
and everyone else

176
00:10:01.206 --> 00:10:04.146
with Toby this week,
we've extended kerning

177
00:10:04.146 --> 00:10:05.516
and ligature support everywhere

178
00:10:05.516 --> 00:10:06.836
and we've turned
it on by default.

179
00:10:07.446 --> 00:10:14.556
And we've even given you
simple single attribute access

180
00:10:15.056 --> 00:10:18.096
to advanced text
effects like Letterpress.

181
00:10:18.656 --> 00:10:22.666
If you want to know more
about this, I would suggest

182
00:10:22.666 --> 00:10:25.526
that you see the session
Advanced Text Layouts

183
00:10:25.686 --> 00:10:27.626
and Effects with Text Kit.

184
00:10:28.976 --> 00:10:33.126
So, the next thing I'm going to
tell you about is another thing

185
00:10:33.126 --> 00:10:36.166
that I think is just
incredibly awesome in Text Kit.

186
00:10:36.616 --> 00:10:39.136
And Jason and Toby
and everyone else

187
00:10:39.136 --> 00:10:41.186
and Chris have been
talking about this all week.

188
00:10:42.156 --> 00:10:42.976
It's Dynamic Type.

189
00:10:43.796 --> 00:10:44.656
What's Dynamic Type?

190
00:10:45.576 --> 00:10:48.806
Well, Dynamic Type is a
set of designed type styles

191
00:10:49.226 --> 00:10:52.146
which are made for you
to use in your app.

192
00:10:53.336 --> 00:10:57.726
They're optimized for
legibility, so they're easy

193
00:10:57.726 --> 00:10:59.106
for your users to read.

194
00:10:59.716 --> 00:11:02.666
And again, it's user-centric.

195
00:10:59.716 --> 00:11:02.666
And again, it's user-centric.

196
00:11:02.666 --> 00:11:04.756
Your user is able
to pick the size.

197
00:11:05.296 --> 00:11:09.226
They can go small,
medium, or large.

198
00:11:09.826 --> 00:11:11.816
And there's rich support

199
00:11:11.816 --> 00:11:15.106
for accessibility built
right in to Dynamic Type.

200
00:11:15.656 --> 00:11:20.206
And there's great support
for Dynamic Type in Xcode 5.

201
00:11:23.356 --> 00:11:28.336
So, to really utilize Dynamic
Type to its fullest potential,

202
00:11:28.826 --> 00:11:30.116
you're going to want to know

203
00:11:30.116 --> 00:11:32.256
about the next feature
I'm about to show you.

204
00:11:33.806 --> 00:11:34.726
Font descriptors.

205
00:11:35.926 --> 00:11:37.976
Now, for those of you
coming from Core Text,

206
00:11:38.426 --> 00:11:40.306
this is not necessarily
all that new.

207
00:11:40.836 --> 00:11:45.526
But for the rest of us
who have been using iOS 6

208
00:11:45.526 --> 00:11:48.706
and previous versions,
it's really, really cool.

209
00:11:49.546 --> 00:11:52.796
Font descriptors are a way of
specifying one or more fonts,

210
00:11:53.436 --> 00:11:55.326
and you can interact
with the font system

211
00:11:55.696 --> 00:11:57.506
by using a font descriptor
for query --

212
00:11:57.506 --> 00:12:02.746
to query for a font and it will
return the results in the form

213
00:11:57.506 --> 00:12:02.746
to query for a font and it will
return the results in the form

214
00:12:02.836 --> 00:12:05.906
of more font descriptors which
then you can hand to the system

215
00:12:05.906 --> 00:12:08.286
and tell it, "Hey, create a
font for this font descriptor."

216
00:12:09.406 --> 00:12:11.436
This is a big improvement
over the past.

217
00:12:11.436 --> 00:12:15.386
In the past, you have to create
a font, change the point size,

218
00:12:15.936 --> 00:12:18.196
apply a trait, a symbolic
trait of some variety,

219
00:12:18.196 --> 00:12:19.486
and everytime you
were doing this,

220
00:12:19.536 --> 00:12:21.106
the system was creating a font

221
00:12:21.336 --> 00:12:23.766
to back this UIFont
instance in the background.

222
00:12:24.496 --> 00:12:26.306
You don't have to do that
with font descriptors.

223
00:12:26.306 --> 00:12:28.116
They're super cheap
and lightweight.

224
00:12:29.216 --> 00:12:30.146
They can be archived.

225
00:12:30.786 --> 00:12:34.966
And if you want to know more
about using fonts with Text Kit,

226
00:12:35.206 --> 00:12:38.626
I urge you to see the session
Using Fonts with Text Kit.

227
00:12:38.956 --> 00:12:40.576
It's going to be really awesome.

228
00:12:41.266 --> 00:12:45.346
So you have these fonts and
they're working well for you.

229
00:12:46.296 --> 00:12:51.926
But, maybe you get a design that
says, "The new fonts are great

230
00:12:51.926 --> 00:12:53.746
but we just need bold here."

231
00:12:53.956 --> 00:12:54.946
How are you going to do that?

232
00:12:54.946 --> 00:12:57.276
Well, you're going to do
that with symbolic traits.

233
00:12:57.806 --> 00:13:02.936
You can see here we have our
regular unadorned type styles,

234
00:12:57.806 --> 00:13:02.936
You can see here we have our
regular unadorned type styles,

235
00:13:03.246 --> 00:13:04.156
a nice list of them.

236
00:13:04.876 --> 00:13:08.076
Let's apply bold and italic
attributes, and you can see --

237
00:13:08.076 --> 00:13:09.556
or sorry, symbolic traits

238
00:13:10.016 --> 00:13:12.986
and you can see what
it does to those fonts.

239
00:13:14.346 --> 00:13:17.036
We also have support for the
expanded and condensed traits.

240
00:13:17.556 --> 00:13:20.866
And if you want to
affect the line spacing,

241
00:13:21.196 --> 00:13:22.536
we even have traits for that.

242
00:13:23.076 --> 00:13:26.076
For example, the
tight trait allows you

243
00:13:26.076 --> 00:13:29.006
to pack more text
into a smaller area.

244
00:13:29.696 --> 00:13:31.976
Now, when you do this,
and I wouldn't recommend

245
00:13:31.976 --> 00:13:34.436
that you do it all the time,
but you can do it in places

246
00:13:34.486 --> 00:13:38.346
like summary fields where
information density is

247
00:13:38.346 --> 00:13:39.856
at a premium for your user,

248
00:13:40.156 --> 00:13:42.946
and you don't want sacrificing
a little bit of legibility.

249
00:13:42.946 --> 00:13:44.946
So you wouldn't want to
do this all over your app.

250
00:13:46.576 --> 00:13:50.956
And if you're embedding rich
web content inside your app,

251
00:13:51.256 --> 00:13:52.526
I've got great news for you.

252
00:13:52.916 --> 00:13:54.986
All of this is supported
by WebKit.

253
00:13:55.556 --> 00:13:59.876
And if you want to know more
about the great enhancements

254
00:13:59.876 --> 00:14:03.056
to fonts in WebKit, you should
see the session What's New

255
00:13:59.876 --> 00:14:03.056
to fonts in WebKit, you should
see the session What's New

256
00:14:03.056 --> 00:14:05.816
in Safari and WebKit
for developers.

257
00:14:07.546 --> 00:14:12.286
Next, I'd like to show you how
we built one of the components

258
00:14:12.766 --> 00:14:16.316
in the UIText world,
the TextView.

259
00:14:17.556 --> 00:14:22.596
Here's our simple TextView and
it has a nursery rhyme in it.

260
00:14:23.216 --> 00:14:24.876
Well, how was it built now?

261
00:14:24.876 --> 00:14:26.926
In the past, it had a
WebView backing everything.

262
00:14:27.496 --> 00:14:29.676
The first thing you're
going to see

263
00:14:29.676 --> 00:14:33.246
when you pull it apart is
the NSTextContainer instance.

264
00:14:33.596 --> 00:14:38.826
NSTextContainer is giving the
NSLayoutManager the bounds,

265
00:14:38.826 --> 00:14:41.686
the geometry to render
the text into.

266
00:14:42.626 --> 00:14:47.216
And NSLayoutManager is
taking all of the text

267
00:14:47.436 --> 00:14:53.456
from your NSTextStorage
and turning it into lines

268
00:14:53.456 --> 00:14:55.696
of glyphs inside
of your TextView.

269
00:14:56.826 --> 00:14:59.266
But now that you understand
how TextView is built,

270
00:14:59.576 --> 00:15:01.236
this unlocks other
features for you.

271
00:14:59.576 --> 00:15:01.236
this unlocks other
features for you.

272
00:15:02.236 --> 00:15:03.606
Like, again, when
we were talking

273
00:15:03.606 --> 00:15:06.766
about exclusion paths before,
the way you do this inside

274
00:15:06.766 --> 00:15:09.496
of a TextView, the way you
get support for simple figures

275
00:15:09.496 --> 00:15:12.336
and cutouts in your
UITextView is

276
00:15:12.996 --> 00:15:15.056
to first create an
exclusion path.

277
00:15:15.056 --> 00:15:17.836
In this case, we're creating an
exclusion path for a butterfly.

278
00:15:18.586 --> 00:15:20.676
And then you would take
this exclusion path,

279
00:15:21.086 --> 00:15:24.446
you'd pack into an array, and
you'd set it on the text --

280
00:15:24.446 --> 00:15:26.676
the exclusion path's
property of the text container

281
00:15:26.676 --> 00:15:28.586
which is associated
with your TextView.

282
00:15:28.586 --> 00:15:30.436
And that's all you'd have to do.

283
00:15:30.606 --> 00:15:33.416
At that point, the text
just magically wraps

284
00:15:33.416 --> 00:15:34.136
around your figure.

285
00:15:34.236 --> 00:15:35.166
It's that simple.

286
00:15:36.516 --> 00:15:40.526
[ Applause ]

287
00:15:41.026 --> 00:15:41.386
Thank you.

288
00:15:42.916 --> 00:15:44.616
It's an easy and
declarative model.

289
00:15:46.086 --> 00:15:47.846
You'll notice, there
was no subclassing

290
00:15:47.846 --> 00:15:49.106
or delegation involved.

291
00:15:49.136 --> 00:15:53.416
So let's talk a bit more
about text container.

292
00:15:53.776 --> 00:15:54.996
What is a text container?

293
00:15:55.576 --> 00:15:59.006
A text container defines a
coordinate system and geometry

294
00:15:59.286 --> 00:16:00.806
for an NSLayoutManager.

295
00:15:59.286 --> 00:16:00.806
for an NSLayoutManager.

296
00:16:01.646 --> 00:16:04.586
As we talked about,
exclusion paths live entirely

297
00:16:04.836 --> 00:16:08.686
in the NSTextContainer's
coordinate space.

298
00:16:09.226 --> 00:16:11.756
Hit-testing is also done

299
00:16:11.756 --> 00:16:13.616
in the NSTextContainer's
coordinate space,

300
00:16:13.616 --> 00:16:16.206
and I'm teasing another big
feature that we've enabled

301
00:16:16.206 --> 00:16:19.146
for you in TextViews in iOS 7.

302
00:16:19.806 --> 00:16:21.606
Hit-testing.

303
00:16:22.416 --> 00:16:24.536
In the past, whenever
we laid out text --

304
00:16:25.516 --> 00:16:29.426
[ Applause ]

305
00:16:29.926 --> 00:16:30.716
I'm glad you like it.

306
00:16:31.776 --> 00:16:33.746
In the past, when
we laid out text,

307
00:16:33.966 --> 00:16:36.176
we immediately threw away
all of the information,

308
00:16:36.276 --> 00:16:39.626
all of the extents, the glyph
IDs, everything just went away

309
00:16:39.626 --> 00:16:41.276
and we gave you back a bit map.

310
00:16:41.976 --> 00:16:45.236
Now, NSLayoutManager
keeps all of this around.

311
00:16:45.556 --> 00:16:47.666
And this is useful
for you because now,

312
00:16:47.666 --> 00:16:50.966
if you want to resolve a tap to
a character index, all you have

313
00:16:50.966 --> 00:16:52.296
to do is call this API.

314
00:16:53.016 --> 00:16:54.166
User's finger comes down.

315
00:16:55.326 --> 00:16:57.736
You get the index into
your text storage, and bam,

316
00:16:57.846 --> 00:16:58.736
you have your character.

317
00:16:58.886 --> 00:16:59.956
It's that simple.

318
00:17:00.136 --> 00:17:05.726
In order to understand the next
few features, we have to go

319
00:17:05.726 --> 00:17:07.376
over some front matter
about glyphs.

320
00:17:07.866 --> 00:17:08.736
What is a glyph?

321
00:17:09.846 --> 00:17:12.665
A glyph represents
one or more characters

322
00:17:12.665 --> 00:17:14.236
on the screen or
the printed page.

323
00:17:14.906 --> 00:17:17.106
An important thing to
remember about glyphs is

324
00:17:17.106 --> 00:17:21.006
that there's not necessarily a
one-to-one mapping from a glyph

325
00:17:21.546 --> 00:17:23.786
to a set of characters
or vice-versa.

326
00:17:24.746 --> 00:17:27.566
Now, you may wonder, "How
do I do this mapping then?"

327
00:17:28.066 --> 00:17:31.596
Well, the answer is our
friend again, NSLayoutManager.

328
00:17:32.116 --> 00:17:37.506
NSLayoutManager maintains
this mapping of glyph ranges

329
00:17:37.676 --> 00:17:42.246
to character ranges and
it's really easy to use.

330
00:17:42.706 --> 00:17:47.826
Just call this API, pass in the
glyph range and it will map,

331
00:17:48.046 --> 00:17:50.696
in the case, the
FFI ligated glyph

332
00:17:51.156 --> 00:17:53.436
to the three characters
it's representing

333
00:17:53.776 --> 00:17:54.896
and it can go the other way.

334
00:17:55.136 --> 00:17:55.896
It's that easy.

335
00:17:55.896 --> 00:17:58.856
And it will maintain this
mapping through edits,

336
00:17:59.206 --> 00:18:02.486
programmatic manipulations,
attribute changes,

337
00:17:59.206 --> 00:18:02.486
programmatic manipulations,
attribute changes,

338
00:18:02.486 --> 00:18:06.546
whatever you do, NSLayoutManager
always stays up-to-date.

339
00:18:09.816 --> 00:18:11.546
There are a whole host

340
00:18:11.766 --> 00:18:14.556
of new interaction
features in TextView.

341
00:18:15.236 --> 00:18:17.526
Now, in the past, you may say,
"Well, you can always interact

342
00:18:17.526 --> 00:18:19.426
with links," and
that's absolutely true.

343
00:18:19.426 --> 00:18:23.386
But what it necessitated was
it necessitated using data

344
00:18:23.386 --> 00:18:28.436
detectors and putting in a
web style, maybe HTTP link.

345
00:18:29.026 --> 00:18:32.066
What's new in iOS 7, and what
I think you're going to love,

346
00:18:32.336 --> 00:18:35.596
is that you can turn
any arbitrary text range

347
00:18:36.466 --> 00:18:38.856
into a link now using
NSLink attribute.

348
00:18:39.516 --> 00:18:43.226
[ Applause ]

349
00:18:43.726 --> 00:18:46.536
Associate a URL with
it, and now,

350
00:18:46.536 --> 00:18:49.776
you have a rich interaction
model right out of the box

351
00:18:49.926 --> 00:18:52.796
that your users are
going to love.

352
00:18:53.386 --> 00:18:55.596
We still support data
detectors, they're there.

353
00:18:55.596 --> 00:18:58.366
You see, we have the
Moscone Center address.

354
00:18:59.236 --> 00:19:01.226
The user taps or long-presses,

355
00:18:59.236 --> 00:19:01.226
The user taps or long-presses,

356
00:19:01.556 --> 00:19:06.176
and up comes an action sheet
filled with useful interactions

357
00:19:06.176 --> 00:19:07.346
for the user to choose from.

358
00:19:08.006 --> 00:19:12.236
Now, in order to understand the
next feature, I want to tell you

359
00:19:12.236 --> 00:19:14.096
about text attachments.

360
00:19:14.556 --> 00:19:17.066
The text attachments have
been a long time coming

361
00:19:17.066 --> 00:19:19.996
to our platform, but they're
really cool and really useful.

362
00:19:21.016 --> 00:19:23.346
And they're totally distinct
from exclusion paths,

363
00:19:23.626 --> 00:19:24.636
and I'm going to tell you why.

364
00:19:25.626 --> 00:19:28.096
Attachments live with your data.

365
00:19:28.466 --> 00:19:31.046
They actually live inside
of your NSTextStorage.

366
00:19:31.286 --> 00:19:34.116
There's a character
which is interpreted

367
00:19:34.116 --> 00:19:37.456
and has the attachment
data associated with it.

368
00:19:37.456 --> 00:19:39.206
They can refer to an
image or something else.

369
00:19:39.876 --> 00:19:43.316
An exclusion path lives
inside of the text container.

370
00:19:43.406 --> 00:19:45.626
It actually changes the geometry

371
00:19:45.626 --> 00:19:48.796
that the layout manager
uses to flow text into.

372
00:19:49.006 --> 00:19:49.956
That's the difference.

373
00:19:50.996 --> 00:19:53.276
So what do you generally
use a text attachment for?

374
00:19:53.566 --> 00:19:56.546
A text attachment is usually
used for inline images.

375
00:19:57.976 --> 00:20:00.966
It affects text layout and
it's affected by text layout.

376
00:19:57.976 --> 00:20:00.966
It affects text layout and
it's affected by text layout.

377
00:20:02.426 --> 00:20:05.706
And, of course, it
contains the geometry

378
00:20:06.176 --> 00:20:10.456
for the contained data
including a baseline offset.

379
00:20:10.606 --> 00:20:13.226
NSLayoutManager is going
to use this information

380
00:20:13.556 --> 00:20:20.436
to place the text attachment in
line with the rest of your data.

381
00:20:20.616 --> 00:20:24.636
And, of course, it has another
simple interaction model.

382
00:20:25.436 --> 00:20:28.506
The user long-presses
on the picture,

383
00:20:28.746 --> 00:20:30.596
and up comes another
action sheet.

384
00:20:30.866 --> 00:20:33.006
Again, this is built
right into the system.

385
00:20:34.026 --> 00:20:36.266
To show you some of the
stuff and how you can use it

386
00:20:36.266 --> 00:20:38.976
in your app, I'm going to invite
my colleague Jordan Breeding

387
00:20:38.976 --> 00:20:40.966
to the stage to give
you guys a quick demo.

388
00:20:42.516 --> 00:20:48.416
[ Applause ]

389
00:20:48.916 --> 00:20:49.446
>> Thank you, Ian.

390
00:20:50.856 --> 00:20:51.966
The first part of the demo we'd

391
00:20:51.966 --> 00:20:54.906
like to show you today is the
show for our demo application.

392
00:20:55.726 --> 00:20:57.866
As you can see, I already have
it running in the simulator.

393
00:20:58.786 --> 00:21:00.586
What I'd like to call out is

394
00:20:58.786 --> 00:21:00.586
What I'd like to call out is

395
00:21:00.586 --> 00:21:04.186
that this collection view is
backed by collection view cells.

396
00:21:04.876 --> 00:21:07.546
They contain UILabels
and UITextViews.

397
00:21:08.336 --> 00:21:08.786
That's right.

398
00:21:09.216 --> 00:21:12.266
It's a full-blown UITextViews
in collection view cells.

399
00:21:12.996 --> 00:21:13.856
They scroll well.

400
00:21:14.236 --> 00:21:15.656
There's no synchronization
issues.

401
00:21:15.966 --> 00:21:18.366
I didn't have to deal
with any main thread

402
00:21:18.366 --> 00:21:19.966
and web thread synchronization.

403
00:21:22.136 --> 00:21:25.196
To show you that I didn't
actually do anything tricky,

404
00:21:25.806 --> 00:21:31.676
I'm going to open my storyboard,
go into my cell, and now,

405
00:21:31.676 --> 00:21:34.876
I'm showing you that inside
of my background container,

406
00:21:35.476 --> 00:21:40.436
I have a UILabel and a
UITextView, and I'd also

407
00:21:40.436 --> 00:21:43.686
like to call out a specific
feature that Ian pointed out.

408
00:21:45.006 --> 00:21:47.736
New in Xcode 5, into
interface builder,

409
00:21:48.336 --> 00:21:52.336
you can directly select the
text style that you would

410
00:21:52.336 --> 00:21:54.436
like instead of the
old system choices.

411
00:21:54.856 --> 00:21:58.886
In this case, I had selected
the text style of body

412
00:21:59.166 --> 00:22:01.916
because this represents some
body text inside of our cells.

413
00:21:59.166 --> 00:22:01.916
because this represents some
body text inside of our cells.

414
00:22:02.346 --> 00:22:06.796
Now if I build and run again --

415
00:22:11.976 --> 00:22:15.106
I can enter our first
section of the real demo.

416
00:22:15.846 --> 00:22:17.686
This is the basic
interaction demo.

417
00:22:17.686 --> 00:22:21.166
What we're showing you here
is that we have some blocks

418
00:22:21.166 --> 00:22:23.536
of texts which do not
match any data detectors.

419
00:22:24.166 --> 00:22:26.316
And if you go in right
now, you'll notice

420
00:22:26.316 --> 00:22:29.146
that neither the phone
number nor the URL is

421
00:22:29.146 --> 00:22:30.036
actually interactive.

422
00:22:30.566 --> 00:22:32.796
We'd like to make
it interactive.

423
00:22:33.876 --> 00:22:37.396
So we go back into Xcode,
into interface builder.

424
00:22:39.356 --> 00:22:42.446
We select the view that
contains that data.

425
00:22:43.036 --> 00:22:48.376
And just like in iOS 6, it's
as easy as turning on the links

426
00:22:49.156 --> 00:22:52.856
and phone numbers data
detectors which I've just done.

427
00:22:54.226 --> 00:23:00.436
Now, if I build and run,
building and running now,

428
00:22:54.226 --> 00:23:00.436
Now, if I build and run,
building and running now,

429
00:23:02.256 --> 00:23:03.856
going into basic interaction.

430
00:23:05.156 --> 00:23:09.506
You'll notice that phone
numbers and URLs work perfectly.

431
00:23:10.146 --> 00:23:14.116
Now, something that you
might have had to do

432
00:23:14.116 --> 00:23:17.686
in the past is customize that
behavior that you just saw.

433
00:23:18.476 --> 00:23:20.626
You might not want your
users to go to Safari

434
00:23:20.626 --> 00:23:22.226
when they tap on
a particular link.

435
00:23:23.096 --> 00:23:25.116
In the past, to achieve
this, many times,

436
00:23:25.116 --> 00:23:27.356
you had to layout your
content in a UIWebView

437
00:23:27.826 --> 00:23:30.706
and use the interaction
model with their delegates

438
00:23:31.166 --> 00:23:33.326
to then force it to open
in your application.

439
00:23:34.476 --> 00:23:37.396
I'd like to show you that
today, we've given you just

440
00:23:37.396 --> 00:23:40.636
that directly in
UITextViews in iOS 7.

441
00:23:41.166 --> 00:23:45.256
Going to go into the
view controller for this.

442
00:23:45.816 --> 00:23:50.836
And what I'd like to
show you is right here,

443
00:23:51.936 --> 00:23:53.226
I implement the delegate.

444
00:23:53.436 --> 00:23:54.296
I've set myself

445
00:23:54.296 --> 00:23:57.266
as the TextView's
delegate in my storyboard.

446
00:23:58.196 --> 00:23:59.306
And as you can see here,

447
00:23:59.426 --> 00:24:03.286
I just implement TextView should
interact with URL in range.

448
00:23:59.426 --> 00:24:03.286
I just implement TextView should
interact with URL in range.

449
00:24:04.356 --> 00:24:09.366
In this case, I compare the
host of the URL to www.apple.com

450
00:24:10.246 --> 00:24:11.306
and if that's what it is,

451
00:24:11.726 --> 00:24:13.876
then I open my own
WebViewController instead

452
00:24:13.876 --> 00:24:14.386
of Safari.

453
00:24:16.276 --> 00:24:18.836
Building and running
to show you that now.

454
00:24:20.586 --> 00:24:24.056
And now, when you're user
goes to the apple URL,

455
00:24:24.436 --> 00:24:26.566
you'll see that it opens
a WebViewController.

456
00:24:27.136 --> 00:24:28.946
Your user stays in
your application,

457
00:24:29.246 --> 00:24:31.036
doesn't leave your experience.

458
00:24:32.516 --> 00:24:36.356
[ Applause ]

459
00:24:36.856 --> 00:24:41.006
We thought you might like that.

460
00:24:41.216 --> 00:24:47.116
Next, our designer gave us a
spec for an exclusion path demo.

461
00:24:47.276 --> 00:24:49.686
Our designers specified
some body text upfront

462
00:24:50.166 --> 00:24:51.776
and gave us a butterfly
image to put

463
00:24:51.776 --> 00:24:53.006
on the bottom right-hand corner.

464
00:24:54.436 --> 00:24:56.876
They also specified that we
should have a pan gesture

465
00:24:56.876 --> 00:24:59.826
recognizer so that the user
could move the butterfly around.

466
00:25:01.956 --> 00:25:04.266
The issue that you
have upfront is

467
00:25:04.266 --> 00:25:07.386
that when the user moves
the butterfly, the butterfly

468
00:25:07.386 --> 00:25:10.276
and its drop shadow affect
the text and overlay it.

469
00:25:11.216 --> 00:25:13.466
We'd like to show you how
easy it is to fix that issue

470
00:25:13.796 --> 00:25:15.896
in iOS 7 with UITextViews.

471
00:25:16.446 --> 00:25:21.026
I'm going to go into my
exclusion path view controller.

472
00:25:24.456 --> 00:25:27.766
First thing I'm going
to do is drop

473
00:25:27.766 --> 00:25:29.836
in a method that
I wrote upfront.

474
00:25:30.906 --> 00:25:34.286
This grabs my precalculated
Bezier Path for my butterfly.

475
00:25:34.776 --> 00:25:36.166
In this case, I can
precalculate it

476
00:25:36.166 --> 00:25:38.286
because the image never
changes, just its position.

477
00:25:39.266 --> 00:25:45.056
I pull my plist out of my
bundle, then I need to make sure

478
00:25:45.056 --> 00:25:47.046
that my image rect
for my butterfly is

479
00:25:47.046 --> 00:25:48.336
in the correct coordinate space.

480
00:25:49.626 --> 00:25:52.966
And finally, I transform
my Bezier Path to match

481
00:25:53.026 --> 00:25:55.876
where the butterfly currently
is on screen and return

482
00:25:55.876 --> 00:25:59.376
that Bezier Path here.

483
00:25:59.596 --> 00:26:03.786
In viewDidLload, I'll use
the new one line support

484
00:25:59.596 --> 00:26:03.786
In viewDidLload, I'll use
the new one line support

485
00:26:04.256 --> 00:26:10.656
in UITextView to set the
exclusion paths then I'll handle

486
00:26:10.656 --> 00:26:13.026
the case of layout
occurring again.

487
00:26:14.076 --> 00:26:15.696
Whenever layout occurs, we know

488
00:26:15.696 --> 00:26:17.516
that the butterfly could
have moved and we need

489
00:26:17.516 --> 00:26:19.646
to match the Bezier
Path to the butterfly.

490
00:26:20.686 --> 00:26:22.796
So, I dropped in
some code there,

491
00:26:23.746 --> 00:26:26.526
do a viewDidLayout
subviews method and go ahead

492
00:26:26.526 --> 00:26:29.126
and update the exclusion
paths there as well

493
00:26:29.416 --> 00:26:33.626
on our UITextView's
text container.

494
00:26:33.706 --> 00:26:37.016
Lastly, in our pan gesture
recognizer action method,

495
00:26:37.856 --> 00:26:40.276
we know that the butterfly
has also moved in this case.

496
00:26:40.676 --> 00:26:42.696
So again, we drop
in the one liner

497
00:26:42.696 --> 00:26:44.186
to update the exclusion paths.

498
00:26:45.056 --> 00:26:46.976
Now, I'll build and run.

499
00:26:51.886 --> 00:26:56.976
And now, in the exclusion paths,
you can see how fluidly --

500
00:26:57.516 --> 00:27:03.606
[ Applause ]

501
00:26:57.516 --> 00:27:03.606
[ Applause ]

502
00:27:04.106 --> 00:27:05.276
You can see how fluidly

503
00:27:05.276 --> 00:27:07.506
that butterfly moved
throughout the text

504
00:27:07.566 --> 00:27:09.906
and let everything
flow back around it.

505
00:27:11.636 --> 00:27:14.006
So, what did you
see in that demo?

506
00:27:15.046 --> 00:27:17.366
You saw that we still
support data detectors

507
00:27:17.396 --> 00:27:20.556
for basic interaction in
TextViews but you also saw

508
00:27:20.766 --> 00:27:23.006
that now you can
provide a delegate

509
00:27:23.106 --> 00:27:25.556
and you can customize some
of your user's behavior

510
00:27:25.556 --> 00:27:27.616
when they interact
with that information.

511
00:27:29.066 --> 00:27:33.296
You saw brand new in iOS 7
that TextViews can be used

512
00:27:33.506 --> 00:27:36.316
in collection view cells and
everything worked perfectly.

513
00:27:38.936 --> 00:27:41.656
You saw how to use some
of the new text styles

514
00:27:41.656 --> 00:27:44.686
in interface builder
and in Xcode.

515
00:27:45.146 --> 00:27:48.606
You can also use them in code.

516
00:27:48.776 --> 00:27:52.806
And lastly, you saw our one
line support for exclusion paths

517
00:27:52.976 --> 00:27:54.716
so that you can make
great looking interfaces

518
00:27:54.716 --> 00:27:55.596
for your users.

519
00:27:56.846 --> 00:28:00.786
Next, I'd like to turn it back
over to my colleague, Ian Baird.

520
00:27:56.846 --> 00:28:00.786
Next, I'd like to turn it back
over to my colleague, Ian Baird.

521
00:28:01.516 --> 00:28:06.616
[ Applause ]

522
00:28:07.116 --> 00:28:08.266
>> That was a great demo.

523
00:28:09.706 --> 00:28:12.626
So now that you're faced
with all of this coolness,

524
00:28:13.526 --> 00:28:15.196
the reality is probably
starting to sink

525
00:28:15.196 --> 00:28:18.696
in that there might be some
work involved in realizing some

526
00:28:18.696 --> 00:28:21.606
of these new designs that your
designers and your clients

527
00:28:22.116 --> 00:28:24.406
and maybe even your friends
and families start throwing

528
00:28:24.406 --> 00:28:26.156
at you once they see iOS 7.

529
00:28:26.836 --> 00:28:29.156
So now we're going to tell
you a little bit about some

530
00:28:29.156 --> 00:28:31.276
of the techniques you can
employ to realize some

531
00:28:31.276 --> 00:28:32.756
of these designs
you're going to see.

532
00:28:32.966 --> 00:28:39.706
So that you can work on creating
apps like messages and mail.

533
00:28:40.606 --> 00:28:42.476
If you look at the design
of messages and mail,

534
00:28:42.776 --> 00:28:45.946
you can see that the text
is precisely positioned.

535
00:28:46.726 --> 00:28:48.866
Everything looks
balanced and clean.

536
00:28:49.156 --> 00:28:51.006
And the content is
front and center.

537
00:28:52.556 --> 00:28:56.126
Well, I'm going to tell you, you
want to get as far down the road

538
00:28:56.126 --> 00:28:58.006
as you can with Auto
Layout because it's going

539
00:28:58.006 --> 00:28:59.916
to make your life
incredibly easy.

540
00:29:01.376 --> 00:29:04.556
But, once you get past what
Auto Layout can do for you,

541
00:29:04.886 --> 00:29:05.476
you're going to need

542
00:29:05.476 --> 00:29:07.746
to understand a few
more tips and tricks.

543
00:29:08.536 --> 00:29:09.676
Let's start with an example.

544
00:29:11.136 --> 00:29:17.716
The new mail view is
broken up into sections.

545
00:29:17.796 --> 00:29:19.746
You can see there are a
couple of header sections

546
00:29:19.746 --> 00:29:21.536
and then there's a body section.

547
00:29:22.126 --> 00:29:27.816
Each section is separated
by a gray key line,

548
00:29:28.446 --> 00:29:32.496
and this key line is
important, it's very important

549
00:29:32.496 --> 00:29:36.946
to get our text spaced
exactly in the perfect place

550
00:29:38.196 --> 00:29:41.156
with respect to the
positioning of the key line.

551
00:29:41.726 --> 00:29:44.376
And our designer has driven
this home by saying that we need

552
00:29:44.376 --> 00:29:45.596
to put the first line

553
00:29:45.596 --> 00:29:49.636
of the body text 0.8
times the cap height away

554
00:29:49.756 --> 00:29:50.606
from the key line.

555
00:29:51.026 --> 00:29:52.286
You may ask, "What is this?"

556
00:29:52.696 --> 00:29:54.666
To understand some
of these new designs,

557
00:29:55.116 --> 00:29:57.816
you need to understand a few
things about font metrics.

558
00:29:58.306 --> 00:30:00.986
So again, if you have a detailed
spec like the one we showed you

559
00:29:58.306 --> 00:30:00.986
So again, if you have a detailed
spec like the one we showed you

560
00:30:00.986 --> 00:30:03.426
in Mail, you'll need
to become familiarized

561
00:30:03.426 --> 00:30:04.976
with things like line height.

562
00:30:06.016 --> 00:30:09.406
This encompasses the
ascender and descender

563
00:30:09.946 --> 00:30:11.306
of each glyph on the line.

564
00:30:11.306 --> 00:30:13.536
As a matter of fact, it's
called the typographic balance

565
00:30:13.536 --> 00:30:15.506
in this case of the line.

566
00:30:15.506 --> 00:30:19.876
And you can get this
from the font

567
00:30:20.666 --> 00:30:22.706
by asking for its line height.

568
00:30:23.356 --> 00:30:24.666
The next thing you're
going to want

569
00:30:24.666 --> 00:30:26.616
to understand is cap height.

570
00:30:27.406 --> 00:30:30.246
Cap height is the distance
from the bottom of the baseline

571
00:30:30.616 --> 00:30:33.676
to the top -- the capital letter
in this case like the flat line

572
00:30:33.676 --> 00:30:35.906
of the A or the -- if
you have a capital H,

573
00:30:35.906 --> 00:30:39.376
it's basically the two top
parts, and that was the distance

574
00:30:39.426 --> 00:30:40.906
that our designers specified

575
00:30:40.906 --> 00:30:43.686
that we should position
our text relative to.

576
00:30:45.666 --> 00:30:47.886
Next, you're going to want
to understand leading.

577
00:30:48.186 --> 00:30:50.536
Leading is the space
between the lines of text,

578
00:30:51.016 --> 00:30:54.086
and using Dynamic Type, remember

579
00:30:54.086 --> 00:30:58.096
that this leading can be
negative to drive the lines

580
00:30:58.096 --> 00:30:59.416
of text closer together.

581
00:31:00.336 --> 00:31:04.276
This causes the descenders
from the line above to overlap

582
00:31:04.566 --> 00:31:06.796
with the ascenders
from the line below.

583
00:31:08.316 --> 00:31:11.906
Now, all of these designs
need to be responsive

584
00:31:11.906 --> 00:31:13.746
and the user gets
to derive the size.

585
00:31:14.076 --> 00:31:14.926
How do you do this?

586
00:31:15.396 --> 00:31:18.986
We're going to want to listen
for UIContentSizeCategoryDid

587
00:31:18.986 --> 00:31:20.176
ChangeNotification.

588
00:31:20.676 --> 00:31:21.866
Thankfully, we have
auto complete,

589
00:31:22.846 --> 00:31:27.586
and this will be omitted when
the users selects new size.

590
00:31:28.216 --> 00:31:30.946
You want to setup this
observation probably inside

591
00:31:30.946 --> 00:31:33.496
of your view controller,
and maybe your app,

592
00:31:33.496 --> 00:31:34.976
and probably your
view controller.

593
00:31:35.696 --> 00:31:38.726
And you want to re-layout
your UI when you receive this.

594
00:31:39.076 --> 00:31:41.336
Well, if you're using Auto
Layout, again, as we told you,

595
00:31:41.336 --> 00:31:42.286
you should probably do,

596
00:31:43.756 --> 00:31:46.386
you'll need to invalidate
the intrinsic content size

597
00:31:46.386 --> 00:31:48.876
of your UIKitViews
positioned by Auto Layout.

598
00:31:48.876 --> 00:31:52.346
And this is a mouthful and
it really boils down to,

599
00:31:52.346 --> 00:31:55.916
if it's a UITextView, or a
text field, or a UILabel,

600
00:31:56.096 --> 00:31:57.786
simply resetting the font

601
00:31:58.696 --> 00:32:02.106
on that view will invalidate
the intrinsic content size

602
00:31:58.696 --> 00:32:02.106
on that view will invalidate
the intrinsic content size

603
00:32:02.106 --> 00:32:04.196
and Auto Layout will just
layout everything for you.

604
00:32:04.196 --> 00:32:04.816
It's that simple.

605
00:32:06.106 --> 00:32:08.706
However, if you're doing
pixel perfect positioning

606
00:32:08.896 --> 00:32:10.546
like the stuff I was
talking about earlier,

607
00:32:11.256 --> 00:32:13.136
you'll want to call
setNeedsLayout

608
00:32:13.216 --> 00:32:14.616
on probably a parent view

609
00:32:15.026 --> 00:32:18.136
to reposition all the child
views using whatever magic

610
00:32:18.136 --> 00:32:20.586
formula you and your
designer have come up with

611
00:32:20.736 --> 00:32:22.486
to position these views.

612
00:32:23.056 --> 00:32:25.936
Another key thing to
remember is that you need

613
00:32:25.936 --> 00:32:28.416
to invalidate any
cached preferred fonts

614
00:32:28.416 --> 00:32:31.726
or font descriptors because
these guys are no longer valid

615
00:32:31.966 --> 00:32:35.126
in the context of your
user's new chosen font size.

616
00:32:36.826 --> 00:32:40.456
So, there's a lot there but
it's actually pretty simple.

617
00:32:40.816 --> 00:32:42.226
It shouldn't be too
intimidating.

618
00:32:42.226 --> 00:32:44.086
And to show you just
how easy it is,

619
00:32:44.416 --> 00:32:46.896
I'd like to invite my
colleague Jordan Breeding

620
00:32:47.036 --> 00:32:49.626
up to the stage again to
give you another demo.

621
00:32:50.516 --> 00:32:55.496
[ Applause ]

622
00:32:55.996 --> 00:32:56.486
>> Thank you, Ian.

623
00:32:57.226 --> 00:33:00.356
The next thing we'd like to show
you in this demo is how to deal

624
00:32:57.226 --> 00:33:00.356
The next thing we'd like to show
you in this demo is how to deal

625
00:33:00.356 --> 00:33:04.836
with some of these complex
designs and also how to account

626
00:33:04.836 --> 00:33:07.576
for your user changing their
preferred content size.

627
00:33:08.126 --> 00:33:13.306
Now, the first thing I'd like
to show you is a user changing

628
00:33:13.306 --> 00:33:14.566
their preferred content size.

629
00:33:15.156 --> 00:33:18.496
In this case, you can see what
our current collection view

630
00:33:18.496 --> 00:33:18.916
looks like.

631
00:33:19.616 --> 00:33:24.236
And as the user goes
over to settings

632
00:33:24.766 --> 00:33:26.736
and changes their
preferred content size --

633
00:33:32.766 --> 00:33:35.336
-- going back to our
demo, you'll notice

634
00:33:35.336 --> 00:33:36.066
that nothing happened.

635
00:33:37.466 --> 00:33:41.416
Now, that's a very
inconsistent user experience.

636
00:33:42.086 --> 00:33:44.036
Your users expect
their content to change

637
00:33:44.036 --> 00:33:45.486
when they change
the content size.

638
00:33:46.626 --> 00:33:49.146
So in this case, I'm going to go

639
00:33:49.146 --> 00:33:51.516
to my collection
view cells instead

640
00:33:51.516 --> 00:33:53.166
of the collection
view controller

641
00:33:53.316 --> 00:33:54.966
because the cells
themselves know

642
00:33:54.966 --> 00:33:56.676
about which content
needs to change.

643
00:33:57.276 --> 00:34:01.726
First thing I'm going to
do is declare a method

644
00:33:57.276 --> 00:34:01.726
First thing I'm going to
do is declare a method

645
00:34:02.656 --> 00:34:05.176
that our notification
can call when it happens.

646
00:34:06.446 --> 00:34:09.346
In this case, I'm calling it
PreferredContentSizeChanged.

647
00:34:11.356 --> 00:34:15.025
Next, while I'm setting up
our initial layout and state,

648
00:34:15.856 --> 00:34:18.906
I'll actually listen
for that notification

649
00:34:18.906 --> 00:34:19.896
that Ian mentioned earlier.

650
00:34:21.636 --> 00:34:24.646
UIContentCategory -- sorry.

651
00:34:25.295 --> 00:34:27.636
UIContentSizeCategoryDid

652
00:34:27.636 --> 00:34:28.656
ChangeNotification.

653
00:34:29.196 --> 00:34:32.235
When that notification fires,

654
00:34:32.516 --> 00:34:34.815
it will call our
PreferredContentSizeChanged

655
00:34:35.616 --> 00:34:35.766
method.

656
00:34:36.696 --> 00:34:39.025
Lastly, I'll drop
in an implementation

657
00:34:39.356 --> 00:34:41.036
of PreferredContentSizeChanged.

658
00:34:42.016 --> 00:34:43.985
In this case, I wrote
a method upfront

659
00:34:44.076 --> 00:34:48.025
that just grabs the new fonts,
places them on the views.

660
00:34:48.446 --> 00:34:49.176
Everything is happy.

661
00:34:49.985 --> 00:34:50.976
So I'll build and run.

662
00:34:56.416 --> 00:34:58.766
Now, you'll see that
things are laid

663
00:34:58.766 --> 00:35:01.426
out a little bit differently.

664
00:34:58.766 --> 00:35:01.426
out a little bit differently.

665
00:35:01.426 --> 00:35:06.056
And again, when your users goes
to change their text size --

666
00:35:06.666 --> 00:35:09.306
oh, actually, I think I --

667
00:35:09.306 --> 00:35:15.166
yeah, I did build instead
of a build and run.

668
00:35:15.386 --> 00:35:19.726
Now we'll see that the
content is different.

669
00:35:19.726 --> 00:35:24.646
And as we go back down,

670
00:35:24.846 --> 00:35:26.356
everything lays out
automatically.

671
00:35:27.066 --> 00:35:27.876
In this case --

672
00:35:28.516 --> 00:35:31.816
[ Applause ]

673
00:35:32.316 --> 00:35:34.886
In this case, another thing we'd
like to point out is that each

674
00:35:34.886 --> 00:35:38.406
of these UITextViews was
actually positioned inside

675
00:35:38.406 --> 00:35:39.956
of the cell using Auto Layout.

676
00:35:40.436 --> 00:35:43.686
So all we did was set the
font on the UITextView

677
00:35:43.966 --> 00:35:46.866
and it automatically invalidated
the intrinsic content size

678
00:35:46.866 --> 00:35:50.126
and caused layout to happen.

679
00:35:50.226 --> 00:35:54.346
The next thing we'd like to show
you is a design specification

680
00:35:54.476 --> 00:35:55.096
from a designer.

681
00:35:56.496 --> 00:36:00.206
In this case, our designer
wanted a profile picture

682
00:35:56.496 --> 00:36:00.206
In this case, our designer
wanted a profile picture

683
00:36:00.206 --> 00:36:01.526
in the upper left
as you can see.

684
00:36:02.726 --> 00:36:07.346
A name, some text, and then
a large run of text below it.

685
00:36:08.636 --> 00:36:10.316
I'd like to show you
how we actually achieved

686
00:36:10.316 --> 00:36:11.666
that using Auto Layout.

687
00:36:12.196 --> 00:36:18.796
In Xcode 5, we were able
to select the picture

688
00:36:18.796 --> 00:36:20.226
which was the most
important element.

689
00:36:20.676 --> 00:36:22.956
Our designer had told us
that the element needed

690
00:36:22.956 --> 00:36:25.756
to be exactly eight
points from the key line

691
00:36:25.756 --> 00:36:27.036
and from the left-hand margin.

692
00:36:27.556 --> 00:36:31.026
And if I show you here, you can
see some of these constraints.

693
00:36:32.516 --> 00:36:35.116
Then the label flows from that,

694
00:36:36.206 --> 00:36:37.926
it's eight points
from the image view.

695
00:36:38.476 --> 00:36:42.296
And then some of the rest of
the layout flows from there.

696
00:36:42.846 --> 00:36:46.186
This container is positioned
based on the left-hand side

697
00:36:46.186 --> 00:36:48.206
of the label above it
and the right-hand side

698
00:36:48.206 --> 00:36:49.076
of the label above it.

699
00:36:49.076 --> 00:36:52.636
And the final TextView is eight
points from the things above it,

700
00:36:52.896 --> 00:36:54.796
and it's left and right
margins are aligned

701
00:36:54.796 --> 00:36:55.836
with the items above it.

702
00:36:57.176 --> 00:36:58.616
The reason that we did this is

703
00:36:58.616 --> 00:37:01.676
that you can adjust just a
few things at the top and all

704
00:36:58.616 --> 00:37:01.676
that you can adjust just a
few things at the top and all

705
00:37:01.676 --> 00:37:03.506
of the rest of your layout
will flow from there.

706
00:37:04.816 --> 00:37:10.066
So, if we build and run again
just to show you, all right.

707
00:37:10.936 --> 00:37:14.426
And in this case, I
could show you that --

708
00:37:14.876 --> 00:37:17.206
if I go in and set the
preferred content size,

709
00:37:17.406 --> 00:37:18.676
it's not currently responding.

710
00:37:18.866 --> 00:37:22.406
So we need to make that happen.

711
00:37:22.616 --> 00:37:27.076
What I do there is I go into
my view controller superclass

712
00:37:28.406 --> 00:37:31.596
and I implement the same
PreferredContentSizeChanged

713
00:37:31.596 --> 00:37:31.956
method.

714
00:37:32.546 --> 00:37:36.686
In viewDidLoad, I know
that I need to listen

715
00:37:36.686 --> 00:37:37.776
for the notification again

716
00:37:38.156 --> 00:37:40.096
and call
PreferredContentSizeChanged,

717
00:37:41.256 --> 00:37:44.836
and have a base implementation
of that.

718
00:37:45.086 --> 00:37:48.666
Lastly, in the view controller
for our designed part,

719
00:37:50.036 --> 00:37:53.026
we know that we need
to override that method

720
00:37:53.466 --> 00:37:55.656
and do some extra setting
of fonts and things.

721
00:37:56.716 --> 00:37:57.976
So, I build and run.

722
00:38:04.446 --> 00:38:09.846
And now you'll see that if I go
in and change my content size,

723
00:38:12.376 --> 00:38:14.096
everything lays out
automatically.

724
00:38:16.516 --> 00:38:20.276
[ Applause ]

725
00:38:20.776 --> 00:38:21.066
Thank you.

726
00:38:21.246 --> 00:38:25.426
The one thing that you might
notice is that the short block

727
00:38:25.426 --> 00:38:27.746
of description text
truncated in a way

728
00:38:27.746 --> 00:38:29.406
that wasn't very
pleasing to our user.

729
00:38:30.556 --> 00:38:32.346
We didn't like this and
neither did our designer.

730
00:38:33.456 --> 00:38:36.676
So we're going to implement one
last thing, brand new in iOS 7.

731
00:38:37.356 --> 00:38:43.396
We can now set the line break
mode on the text container

732
00:38:43.396 --> 00:38:45.896
of the TextView to
get truncation

733
00:38:46.156 --> 00:38:49.226
by the text container instead
of by the line or paragraph.

734
00:38:50.226 --> 00:38:52.076
So instead of truncating
to a single line

735
00:38:52.076 --> 00:38:53.296
or even a single paragraph,

736
00:38:53.296 --> 00:38:55.136
I've inserted this
single line of code.

737
00:38:55.966 --> 00:38:56.826
I'll build and run.

738
00:39:02.616 --> 00:39:06.136
And this time, you'll notice
that we truncated nicely

739
00:39:06.746 --> 00:39:08.746
at the end of the
text container itself.

740
00:39:09.906 --> 00:39:14.626
So, going back over to
what we saw in that demo,

741
00:39:14.826 --> 00:39:17.606
we saw how you can realize
fairly complex designs still

742
00:39:17.606 --> 00:39:20.846
using Auto Layout in Xcode
5 with interface builder.

743
00:39:22.336 --> 00:39:25.616
We saw how you can respond
to the change notification

744
00:39:25.816 --> 00:39:28.006
when your user changes
their preferred content size

745
00:39:28.436 --> 00:39:32.216
and cause layout to occur again.

746
00:39:32.436 --> 00:39:36.476
And we saw how in iOS 7, you
can now customize the text

747
00:39:36.476 --> 00:39:38.726
containers line break
mode instead of having

748
00:39:38.726 --> 00:39:41.156
to do it yourself by
line or paragraph.

749
00:39:42.416 --> 00:39:45.126
Next, I'd like to bring out my
colleague, Johannes Fortmann.

750
00:39:46.516 --> 00:39:51.166
[ Applause ]

751
00:39:51.666 --> 00:39:52.226
>> Thanks, Jordan.

752
00:39:53.796 --> 00:39:57.946
Hi, I'm here to talk to you
about Interactive Rich Text.

753
00:39:59.256 --> 00:40:00.616
Now, what do I mean by that?

754
00:39:59.256 --> 00:40:00.616
Now, what do I mean by that?

755
00:40:01.976 --> 00:40:07.536
If you've used the UITextView
on iOS 6 before, you may recall

756
00:40:07.536 --> 00:40:10.296
that there, we provided
the new attribute

757
00:40:11.396 --> 00:40:14.856
to set the attributed
text on a UITextView.

758
00:40:16.346 --> 00:40:24.186
Now, this attribute means that
when you set it, the entire text

759
00:40:24.516 --> 00:40:27.576
in this UITextView
will get replaced

760
00:40:27.856 --> 00:40:33.736
by the new NSAttributedString
that you set the attributes to.

761
00:40:34.756 --> 00:40:40.006
In iOS 7, we now provide a
new attribute, text storage,

762
00:40:40.156 --> 00:40:46.306
that allows you to directly
modify the attributed text

763
00:40:46.806 --> 00:40:47.806
on the TextView.

764
00:40:49.146 --> 00:40:52.436
The text storage is a subclass
of NSMutableAttributedString

765
00:40:52.686 --> 00:40:56.216
which means that you can
get it from the TextView

766
00:40:56.666 --> 00:40:58.366
and modify it in place.

767
00:40:59.866 --> 00:41:01.816
We send change notifications

768
00:40:59.866 --> 00:41:01.816
We send change notifications

769
00:41:02.606 --> 00:41:07.516
that will inform the
LayoutManager about the changes

770
00:41:07.516 --> 00:41:11.806
that you performed
on the text storage

771
00:41:12.586 --> 00:41:18.326
and performed very specific
invalidation on only the parts

772
00:41:18.326 --> 00:41:20.766
of the text storage
that you've changed.

773
00:41:22.206 --> 00:41:25.266
That's a big, big, big
performance win, since now,

774
00:41:25.266 --> 00:41:27.636
we don't have to
invalidate everything

775
00:41:28.196 --> 00:41:32.116
when just a single
character has changed.

776
00:41:32.666 --> 00:41:35.606
Let's walk through how one
of these changes works.

777
00:41:36.156 --> 00:41:44.566
As I said, since the
NSTextStorage is simply a

778
00:41:44.566 --> 00:41:46.286
MutableAttributedString
subclass,

779
00:41:47.006 --> 00:41:50.556
we can use the standard
modifications

780
00:41:50.556 --> 00:41:53.886
on the MutableAttributedString
to perform changes.

781
00:41:55.096 --> 00:41:58.366
So, assume that we have
a TextView already here,

782
00:41:59.506 --> 00:42:04.196
and in this case, we have the
beginning of the story "Alice

783
00:41:59.506 --> 00:42:04.196
and in this case, we have the
beginning of the story "Alice

784
00:42:04.196 --> 00:42:09.856
and Wonderland" and we want
to modify the name Alice

785
00:42:09.856 --> 00:42:14.646
for example to be read,
to call it out in a way.

786
00:42:14.846 --> 00:42:19.566
What we do since we
have multiple occasions

787
00:42:19.566 --> 00:42:22.936
by the name Alice comes up, it's
about her, the story, anyway.

788
00:42:23.926 --> 00:42:27.366
So, it happens often.

789
00:42:27.366 --> 00:42:31.866
We don't want to perform
an invalidation for each

790
00:42:31.906 --> 00:42:34.806
of these cases why we
modify the text storage.

791
00:42:35.816 --> 00:42:38.016
So what we do is we
bracket the changes.

792
00:42:38.666 --> 00:42:43.636
Let me show you how that works.

793
00:42:44.296 --> 00:42:49.766
First, we call the Begin Editing
method on the text storage.

794
00:42:50.816 --> 00:42:53.456
That informs our text
storage that we're going

795
00:42:53.456 --> 00:42:55.776
to perform a batch
of changes now.

796
00:42:57.506 --> 00:43:01.956
Next, what we're doing is
we modify each instance.

797
00:42:57.506 --> 00:43:01.956
Next, what we're doing is
we modify each instance.

798
00:43:01.956 --> 00:43:05.046
For example, we loop over the
string, find out the ranges,

799
00:43:05.046 --> 00:43:08.746
and set the foreground color on
each instance of the word Alice.

800
00:43:10.386 --> 00:43:13.386
And finally, once we're
done with all our changes

801
00:43:13.386 --> 00:43:18.696
and are happy with them, we
call the End Editing method

802
00:43:18.696 --> 00:43:19.646
on the text storage.

803
00:43:20.926 --> 00:43:24.296
Now, until now, nothing
has yet changed

804
00:43:24.296 --> 00:43:27.616
on the actual visual
representation, the TextView.

805
00:43:29.166 --> 00:43:33.086
Only after the End Editing
method has been called,

806
00:43:34.056 --> 00:43:39.166
the text storage will
process each and every edit

807
00:43:40.166 --> 00:43:44.376
and inform the LayoutManager
which then is able

808
00:43:44.376 --> 00:43:47.216
to recompute the areas
that have actually changed

809
00:43:48.176 --> 00:43:52.776
and redraw the actual changes.

810
00:43:53.286 --> 00:43:58.866
Next, I'd like to talk to you
about subclassing NSTextStorage.

811
00:44:00.406 --> 00:44:01.896
Now, why would we
want to do that?

812
00:44:02.776 --> 00:44:07.666
Well, as Ian showed you before,
we might be writing an app

813
00:44:07.716 --> 00:44:13.776
for a popular messaging
system, and in that case,

814
00:44:13.836 --> 00:44:18.906
we want to call out a
person by their identifier.

815
00:44:19.636 --> 00:44:21.786
We do know that these
identifiers have a

816
00:44:21.786 --> 00:44:22.876
certain formatting.

817
00:44:23.656 --> 00:44:26.646
So, in that case,
we already know what

818
00:44:26.646 --> 00:44:28.836
to do once we see
these identifiers.

819
00:44:31.086 --> 00:44:36.406
After the user has
entered the identifier,

820
00:44:36.486 --> 00:44:38.806
we want to immediately,
and I mean,

821
00:44:38.806 --> 00:44:43.316
immediately change the truth,
effectively the contents

822
00:44:43.316 --> 00:44:44.536
of our text storage

823
00:44:45.056 --> 00:44:50.746
to for example change the
colors of this identifier.

824
00:44:52.096 --> 00:44:56.726
To do that, we modify the
methods on the text storage

825
00:44:56.726 --> 00:44:59.596
that actually change
text on the text storage.

826
00:45:00.706 --> 00:45:03.836
Now, NSTextStorage
is class cluster.

827
00:45:07.536 --> 00:45:13.356
That means that we as Apple
provide an implementation

828
00:45:13.356 --> 00:45:16.366
of a superclass, that's
the NSTextStorage class

829
00:45:16.786 --> 00:45:18.166
that is public in the SDK.

830
00:45:19.236 --> 00:45:21.596
And we also provide
an implementation

831
00:45:21.596 --> 00:45:25.326
of that superclass, a
subclass, that is private

832
00:45:26.116 --> 00:45:29.416
but that's still vended
out to you, the developer,

833
00:45:30.026 --> 00:45:32.216
if you initialize
one of these objects.

834
00:45:33.916 --> 00:45:37.176
This subclass provides
the actual storage

835
00:45:37.226 --> 00:45:39.946
and attribute modification
parts of the text storage.

836
00:45:41.406 --> 00:45:44.446
Now, if you as a
third-party developer want

837
00:45:44.446 --> 00:45:46.826
to provide your own
custom implementation

838
00:45:46.826 --> 00:45:48.956
of a text storage, what you need

839
00:45:48.956 --> 00:45:53.396
to do is provide
certain primitive methods

840
00:45:53.396 --> 00:45:54.596
on the text storage.

841
00:45:55.586 --> 00:45:56.946
There are four primitive
methods.

842
00:45:58.056 --> 00:46:01.726
Two of them deal with
actual static storage.

843
00:45:58.056 --> 00:46:01.726
Two of them deal with
actual static storage.

844
00:46:01.976 --> 00:46:04.696
You can inquire the string
and inquire about attributes,

845
00:46:05.646 --> 00:46:09.656
and the next two deal
with actual modifications.

846
00:46:10.536 --> 00:46:12.306
To show you how to
actually implement this,

847
00:46:12.376 --> 00:46:16.596
I'm going to do a demo.

848
00:46:16.876 --> 00:46:24.746
I've already setup in the
same demo app here a TextView

849
00:46:24.996 --> 00:46:28.816
that has the text we saw in
the slides and already entered.

850
00:46:29.876 --> 00:46:32.736
I've also already created
an empty implementation

851
00:46:32.736 --> 00:46:34.176
for custom text storage.

852
00:46:35.506 --> 00:46:38.556
We're now going to try to use
this empty implementation.

853
00:46:38.746 --> 00:46:41.236
Well, we're going to fill it
before we use it of course.

854
00:46:42.176 --> 00:46:46.136
First, I need to actually make
on my view controller an outlet

855
00:46:46.136 --> 00:46:50.906
for the custom text
storage and, of course,

856
00:46:50.906 --> 00:46:53.916
I need to create an instance
of my implementation.

857
00:46:55.586 --> 00:46:59.566
Now, I'm going to do something
slightly complicated here.

858
00:47:00.526 --> 00:47:02.916
In Ian's -- in one
of Ian's slides,

859
00:47:03.006 --> 00:47:07.466
you've seen that the TextView
is backed by a text container

860
00:47:07.996 --> 00:47:10.066
which in turn is backed
by a LayoutManager

861
00:47:10.066 --> 00:47:12.076
which in turn his
backed by a text storage.

862
00:47:13.556 --> 00:47:16.906
That means that I have to
recreate this entire hierarchy

863
00:47:17.466 --> 00:47:21.196
to be able to put my custom
text storage in there.

864
00:47:22.456 --> 00:47:25.866
This is really quite
simple since we're not going

865
00:47:25.866 --> 00:47:28.466
to do anything custom
with these LayoutManagers

866
00:47:28.466 --> 00:47:29.336
or text containers.

867
00:47:29.886 --> 00:47:32.936
So I'm just going to create
a stock LayoutManager.

868
00:47:33.916 --> 00:47:38.736
I'm going to also create stock
text container within the size

869
00:47:38.736 --> 00:47:41.176
of our TextView in
an infinite height.

870
00:47:43.086 --> 00:47:45.026
I'm going to setup
the text container

871
00:47:45.026 --> 00:47:47.426
such that its width
tracks that TextView

872
00:47:47.426 --> 00:47:50.646
in case we resize the TextView.

873
00:47:51.796 --> 00:47:54.126
And finally, I'm going
to hook these two app.

874
00:47:54.126 --> 00:47:57.246
I'm going to add the text
container to the LayoutManager

875
00:47:57.906 --> 00:48:00.866
and add the LayoutManager
to the text storage.

876
00:47:57.906 --> 00:48:00.866
and add the LayoutManager
to the text storage.

877
00:48:02.346 --> 00:48:07.296
Finally, instead of creating
a simple TextView here,

878
00:48:08.026 --> 00:48:12.606
I'm going to use the new in
iOS 7, designated initializer

879
00:48:12.606 --> 00:48:15.986
for your TextView that takes
it to custom text container.

880
00:48:16.926 --> 00:48:20.006
So, I'm creating the TextView

881
00:48:20.006 --> 00:48:22.506
with this specific text
container that I just made,

882
00:48:23.526 --> 00:48:26.186
and I assign and add it.

883
00:48:26.436 --> 00:48:30.116
If I were to run this now,
we would have a TextView

884
00:48:30.116 --> 00:48:31.706
that is backed by text storage

885
00:48:31.706 --> 00:48:33.976
that does not actually
store anything

886
00:48:34.476 --> 00:48:37.306
because we have not implemented
any of the primitive methods.

887
00:48:38.426 --> 00:48:39.076
So let's do that.

888
00:48:39.076 --> 00:48:42.156
I'm switching over to the text
storage implementation here.

889
00:48:43.136 --> 00:48:47.036
And what we want to --
what we need first is an

890
00:48:47.036 --> 00:48:51.986
NSMutableAttributedString
that actually stores the data.

891
00:48:52.066 --> 00:48:56.036
We need something to store
attributes and strings.

892
00:48:56.356 --> 00:48:59.496
So I'm creating an instance
variable for my backing store.

893
00:49:00.586 --> 00:49:04.396
In my initializer, I create
a new MutableAttributedString

894
00:49:04.476 --> 00:49:06.926
for that backing
store, and that's it.

895
00:49:07.986 --> 00:49:12.336
Next, I'm going to implement
the static methods string,

896
00:49:12.336 --> 00:49:15.876
it just returns the backing
store string, and attributes

897
00:49:15.876 --> 00:49:17.836
at index returns
the back attributes

898
00:49:17.926 --> 00:49:19.136
at the specific index.

899
00:49:20.526 --> 00:49:22.336
The mutable methods
look similar.

900
00:49:22.456 --> 00:49:25.006
They just fall back
to the backing store,

901
00:49:25.746 --> 00:49:27.316
but there is something
different here.

902
00:49:27.316 --> 00:49:29.916
We also need to inform
our superclass,

903
00:49:30.376 --> 00:49:33.366
the NSTextStorage class, that
we actually did some edits.

904
00:49:34.026 --> 00:49:37.726
So I'm going to do that
calling the Edit method on --

905
00:49:37.886 --> 00:49:42.926
or myself to inform my
superclass about the range

906
00:49:42.926 --> 00:49:43.986
that has been changed.

907
00:49:45.746 --> 00:49:49.276
Now, next, I want to -- if
I've changed characters,

908
00:49:50.386 --> 00:49:53.866
I want to remember that

909
00:49:54.076 --> 00:49:56.546
and perform modifications
on those characters.

910
00:49:57.146 --> 00:49:59.826
So implement a flag to
remember if I changed something.

911
00:50:00.186 --> 00:50:05.376
In my replace characters and
range method, I set that flag

912
00:50:06.686 --> 00:50:09.606
and then I'm going to implement
the process editing method

913
00:50:09.606 --> 00:50:13.416
that gets called when the final
end editing call has been sent

914
00:50:13.526 --> 00:50:14.586
to the text storage.

915
00:50:16.216 --> 00:50:19.496
I'm going to call super in
there, and if the flag is set,

916
00:50:20.306 --> 00:50:22.566
I'm going to perform
certain replacements.

917
00:50:23.566 --> 00:50:24.626
These replacements are simple.

918
00:50:24.626 --> 00:50:27.356
I'm going to find
the range of the line

919
00:50:27.356 --> 00:50:30.866
that has just been edited and
I'm going to apply some tokens

920
00:50:30.946 --> 00:50:35.836
to those -- to this range
depending on the words in there.

921
00:50:37.236 --> 00:50:39.396
These tokens are
just dictionary of --

922
00:50:39.816 --> 00:50:44.376
dictionaries in fact that
apply attributes to the string.

923
00:50:45.026 --> 00:50:47.806
Finally, in my view
controller, I set the tokens.

924
00:50:48.586 --> 00:50:50.666
I'm going to choose
the word Alice

925
00:50:50.666 --> 00:50:54.496
to get the program color
red and the word rabbit

926
00:50:54.606 --> 00:50:56.256
to get the program color orange.

927
00:50:58.456 --> 00:51:01.776
Let's run this.

928
00:50:58.456 --> 00:51:01.776
Let's run this.

929
00:51:01.986 --> 00:51:05.526
And now, if I type,
you can already see

930
00:51:05.526 --> 00:51:08.706
without me typing the
word Alice is red,

931
00:51:08.746 --> 00:51:12.926
the word rabbit is
orange, and if I type,

932
00:51:13.726 --> 00:51:19.046
as soon as I'm finished typing,
the word turns red immediately,

933
00:51:19.486 --> 00:51:23.296
same for rabbit of course.

934
00:51:23.476 --> 00:51:25.936
What you've seen
in this demo is how

935
00:51:25.936 --> 00:51:28.276
to assemble the text
system by hand.

936
00:51:29.216 --> 00:51:31.026
We've assembled the
stock classes

937
00:51:31.766 --> 00:51:35.496
and inserted custom
text storage.

938
00:51:36.296 --> 00:51:40.366
We subclass the NSTextStorage
to perform certain --

939
00:51:41.626 --> 00:51:45.416
well, first of all, to
actually work, and then finally,

940
00:51:45.596 --> 00:51:49.446
to use the subclass
of the text storage,

941
00:51:49.446 --> 00:51:51.596
specifically the process
editing method element

942
00:51:52.186 --> 00:51:55.566
to perform interactive
modifications

943
00:51:55.606 --> 00:51:59.266
on the content while
the user is editing it.

944
00:51:59.826 --> 00:52:01.926
And with that, let's
wrap this up.

945
00:51:59.826 --> 00:52:01.926
And with that, let's
wrap this up.

946
00:52:04.256 --> 00:52:07.246
Text Kit is an extremely
powerful

947
00:52:07.246 --> 00:52:08.716
and new feature of iOS 7.

948
00:52:10.196 --> 00:52:13.136
UITextViews as well
as UITextFields

949
00:52:13.136 --> 00:52:17.236
and labels are first
class citizens of UIKit.

950
00:52:18.076 --> 00:52:22.716
They are usable in table
views and collection views.

951
00:52:23.186 --> 00:52:25.866
They support all the
attributes that previously

952
00:52:25.866 --> 00:52:30.116
in iOS 6 NSString supported,
plus a few more like links.

953
00:52:32.026 --> 00:52:37.776
Using exclusion paths and
simple overrides on --

954
00:52:38.396 --> 00:52:43.026
in this case for the exclusion
path, the text container,

955
00:52:43.436 --> 00:52:46.936
but also on NSLayoutManager
or text storage,

956
00:52:47.016 --> 00:52:53.886
we are able to provide very
pleasing UI for our users.

957
00:52:54.266 --> 00:52:58.356
And finally, we've
seen how customizable

958
00:52:58.356 --> 00:52:59.306
and extensible it is.

959
00:53:00.616 --> 00:53:03.266
We were able to, in just
a few lines of code,

960
00:53:04.096 --> 00:53:08.716
provide an implementation
for one of the classes here

961
00:53:09.306 --> 00:53:11.946
and leverage that
to perform something

962
00:53:11.946 --> 00:53:15.196
that was not possible
frankly in iOS 6 before

963
00:53:15.196 --> 00:53:16.986
at least not in a
performance way.

964
00:53:17.506 --> 00:53:22.486
With that, if you
have any questions,

965
00:53:22.486 --> 00:53:25.506
we have our frameworks
evangelist,

966
00:53:25.716 --> 00:53:27.106
Jake Behrens around here.

967
00:53:27.106 --> 00:53:29.966
I think he's sitting down there.

968
00:53:30.906 --> 00:53:32.556
He's -- yeah.

969
00:53:32.556 --> 00:53:35.306
We've got extensive
documentation already out,

970
00:53:35.306 --> 00:53:35.746
I believe.

971
00:53:36.606 --> 00:53:40.846
And finally, all of us text guys
are regularly reading the forums

972
00:53:40.956 --> 00:53:42.976
and are happy to
answer questions.

973
00:53:44.636 --> 00:53:46.656
We've got three more sessions.

974
00:53:46.946 --> 00:53:49.816
Well, one of them
is already over

975
00:53:50.806 --> 00:53:57.596
but the Advanced Text Layout
session tomorrow where Aki

976
00:53:57.596 --> 00:54:01.156
and Peter will show you how
to override certain things

977
00:53:57.596 --> 00:54:01.156
and Peter will show you how
to override certain things

978
00:54:01.156 --> 00:54:03.536
on NSLayoutManager
and use delegation

979
00:54:03.966 --> 00:54:07.056
to customize your text
layouts even further.

980
00:54:08.046 --> 00:54:09.626
And on Friday, we've
got a session

981
00:54:09.676 --> 00:54:11.616
on Using Fonts with Text Kit.

982
00:54:12.196 --> 00:54:15.336
We've got awesome new Core
Text features providing

983
00:54:15.656 --> 00:54:17.956
for interesting modifications
on fonts.

984
00:54:18.846 --> 00:54:24.586
And the last one on Tuesday,
we had a session about the --

985
00:54:25.256 --> 00:54:30.126
among other things, the
new CSS Style Values.

986
00:54:30.956 --> 00:54:31.316
Thank you.

987
00:54:32.516 --> 00:54:35.516
[ Applause ]

988
00:54:36.016 --> 00:54:40.736
[ Silence ]
