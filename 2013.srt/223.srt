
1
00:00:00.506 --> 00:00:08.516
[ Silence ]

2
00:00:09.016 --> 00:00:14.000
[ Applause ]

3
00:00:14.786 --> 00:00:15.206
>> Thank you.

4
00:00:15.206 --> 00:00:15.826
Good morning.

5
00:00:16.476 --> 00:00:20.626
I'm Ned Holbrook and this
is Session 223 Using Fonts

6
00:00:20.626 --> 00:00:21.186
of Text Kit.

7
00:00:21.886 --> 00:00:23.296
So let me give you an
overview of what we're going

8
00:00:23.296 --> 00:00:24.726
to be talking about
during this session.

9
00:00:25.716 --> 00:00:27.256
First we're going
to talk about how

10
00:00:27.256 --> 00:00:28.636
to specify fonts in your app.

11
00:00:30.706 --> 00:00:32.606
We're going to be
talking in particular

12
00:00:32.606 --> 00:00:35.926
about the new Dynamic
Type technology in iOS 7.

13
00:00:35.996 --> 00:00:39.016
We're going to be talking
about font descriptors.

14
00:00:39.766 --> 00:00:41.796
We're going to be talking
about the techniques

15
00:00:41.906 --> 00:00:44.236
for adding fonts to
your application.

16
00:00:45.266 --> 00:00:48.356
And we're also going to be
talking about a couple of topics

17
00:00:48.476 --> 00:00:50.226
that are going to be
particularly relevant

18
00:00:50.476 --> 00:00:52.836
to developers of
multilingual applications.

19
00:00:53.766 --> 00:00:56.246
Language tagging, a
new mechanism available

20
00:00:56.246 --> 00:01:00.316
in both iOS X and iOS 7,
and modifying fallbacks,

21
00:00:56.246 --> 00:01:00.316
in both iOS X and iOS 7,
and modifying fallbacks,

22
00:01:00.606 --> 00:01:03.826
also available on
both platforms.

23
00:01:03.826 --> 00:01:07.376
Now, some of the material for
specifying fonts is also going

24
00:01:07.376 --> 00:01:10.616
to be relevant for OS X as well.

25
00:01:10.616 --> 00:01:12.546
So if you manage to
straggle in with --

26
00:01:13.026 --> 00:01:14.706
in hopes of hearing
something about OS X,

27
00:01:15.006 --> 00:01:18.396
you came to the right place.

28
00:01:18.576 --> 00:01:22.566
First, I'd like to
talk about Text Kit.

29
00:01:22.766 --> 00:01:24.046
I hope you've gone to some

30
00:01:24.046 --> 00:01:26.356
of the other sessions
introducing you

31
00:01:26.356 --> 00:01:29.156
to this great new
technology available in iOS 7.

32
00:01:29.776 --> 00:01:31.686
But since this Friday
morning after the beer bash,

33
00:01:31.736 --> 00:01:33.446
let's have a quick review.

34
00:01:33.946 --> 00:01:40.096
Text Kit is the great new text
framework based on Cocoa text

35
00:01:40.666 --> 00:01:42.006
and brand new to iOS 7.

36
00:01:42.636 --> 00:01:47.616
It allows you to get
amazing control and precision

37
00:01:48.016 --> 00:01:50.086
when it comes to
typography in your app.

38
00:01:51.686 --> 00:01:53.946
And what's most interesting
for this session is

39
00:01:53.996 --> 00:01:57.286
that both Text Kit and
WebKit are built in Core Text

40
00:01:57.926 --> 00:02:01.916
which is our low level unit
code layout engine available

41
00:01:57.926 --> 00:02:01.916
which is our low level unit
code layout engine available

42
00:02:02.186 --> 00:02:04.976
on both iOS and OS X.

43
00:02:05.196 --> 00:02:07.886
Now, Core Text is
still available to you

44
00:02:08.006 --> 00:02:11.576
if you've been making
use of it in the past.

45
00:02:11.576 --> 00:02:14.646
And in particular, we think it's
best for very specialized tasks.

46
00:02:15.846 --> 00:02:18.436
In fact, there's one task
that it was built for

47
00:02:18.436 --> 00:02:20.856
and that was enabling
the development

48
00:02:20.916 --> 00:02:24.506
of higher level Text Kit --
text frameworks like Text Kit

49
00:02:24.506 --> 00:02:27.536
and WebKit, maybe you've
even have to build your own.

50
00:02:28.086 --> 00:02:31.356
But really when it comes
down to it, we encourage you

51
00:02:31.356 --> 00:02:34.176
to use the highest level
framework available

52
00:02:34.846 --> 00:02:35.676
that suits your needs.

53
00:02:36.406 --> 00:02:40.946
And particularly with iOS 7,
we hope that will be Text Kit.

54
00:02:41.166 --> 00:02:43.296
Now, no matter which
framework you're making use

55
00:02:43.296 --> 00:02:46.636
of for advanced typography
in your app.

56
00:02:47.356 --> 00:02:49.646
At the heart of it
all, we're dealing

57
00:02:49.646 --> 00:02:50.826
with Unicode text layout.

58
00:02:51.896 --> 00:02:53.736
Now, this is represented

59
00:02:53.736 --> 00:02:58.266
by the equation String
plus Font equals Glyphs.

60
00:02:58.406 --> 00:03:02.996
And when dealing with user
content, there's really only one

61
00:02:58.406 --> 00:03:02.996
And when dealing with user
content, there's really only one

62
00:03:02.996 --> 00:03:05.006
of those variables
that you have control

63
00:03:05.006 --> 00:03:05.986
over and that's the font.

64
00:03:06.546 --> 00:03:08.866
The string is likely going
to be the user's content.

65
00:03:09.716 --> 00:03:13.766
But we're going to talk
about how you can choose

66
00:03:13.766 --> 00:03:17.286
that font correctly in order

67
00:03:17.286 --> 00:03:20.986
to get the best possible
display of text in your app.

68
00:03:22.596 --> 00:03:25.956
So let's find out
how to do that.

69
00:03:26.106 --> 00:03:27.736
Well you've got a number
of choices when it comes

70
00:03:27.766 --> 00:03:32.146
to choosing a font
for use in your app.

71
00:03:32.456 --> 00:03:34.596
The most exciting one
to me and I hope to you

72
00:03:34.596 --> 00:03:36.986
as well is dynamic
type which is available

73
00:03:37.366 --> 00:03:39.156
for the first time in iOS 7.

74
00:03:40.516 --> 00:03:44.046
There's also the system font
that you are probably familiar

75
00:03:44.046 --> 00:03:48.756
with and you may still may
need to make use of in iOS 7.

76
00:03:49.746 --> 00:03:51.526
We're going to be talking
about UIFontDescriptor

77
00:03:51.526 --> 00:03:56.906
which is the class I use to
identify fonts on the system.

78
00:03:57.896 --> 00:04:00.226
And as I mentioned, we're
also going to talk about how

79
00:03:57.896 --> 00:04:00.226
And as I mentioned, we're
also going to talk about how

80
00:04:00.226 --> 00:04:05.586
to bring your own apps to your
application or fonts, excuse me.

81
00:04:06.396 --> 00:04:08.366
First, I'd like to
show you an example

82
00:04:08.616 --> 00:04:12.806
of the new dynamic type
technology in iOS 7.

83
00:04:12.956 --> 00:04:16.875
I hope you've seen some really
wonderful examples of this

84
00:04:16.986 --> 00:04:20.446
in previous sessions, but
since I'm going to be talking

85
00:04:20.446 --> 00:04:22.506
about some of the more
technical aspects,

86
00:04:22.506 --> 00:04:25.596
so I thought I'd give you a
quick refresher of this as well.

87
00:04:26.386 --> 00:04:32.556
Here we see the same Mailbox
presented in mail on iOS 7

88
00:04:32.856 --> 00:04:35.736
in three different
content sizes.

89
00:04:37.426 --> 00:04:41.036
Now, this is just three
out of a total of seven

90
00:04:41.606 --> 00:04:43.186
that a user can choose from.

91
00:04:44.096 --> 00:04:46.786
But I wanted to point out here

92
00:04:46.786 --> 00:04:48.696
that on the left I
have the smallest size,

93
00:04:49.476 --> 00:04:51.026
in the middle I have
the middle size,

94
00:04:51.206 --> 00:04:52.536
and then on the right
we're looking

95
00:04:52.536 --> 00:04:56.626
at the largest user
selectable dynamic type size.

96
00:04:57.746 --> 00:05:01.486
So, as we can see, mail is a
very text heavy application.

97
00:04:57.746 --> 00:05:01.486
So, as we can see, mail is a
very text heavy application.

98
00:05:02.486 --> 00:05:04.816
But it still has what
we'd like to display

99
00:05:04.886 --> 00:05:09.236
as sort of hierarchy of type.

100
00:05:09.296 --> 00:05:14.456
So, you'll note that there're
several different weights

101
00:05:14.866 --> 00:05:18.556
of type visible in
this situation.

102
00:05:19.366 --> 00:05:22.306
But you'll note that regardless
of the size of that type,

103
00:05:22.826 --> 00:05:24.476
there's a very clear
relationship

104
00:05:24.476 --> 00:05:28.576
between the different
pieces of text on screen.

105
00:05:28.756 --> 00:05:31.146
And one of the great
things about dynamic type is

106
00:05:31.206 --> 00:05:34.436
that it gives you the
tools you need in order

107
00:05:34.436 --> 00:05:38.906
to present information
using the same types

108
00:05:38.906 --> 00:05:43.486
of semantic distinctions in
the text, and we'll be talking

109
00:05:43.486 --> 00:05:46.136
about exactly how to do that.

110
00:05:46.356 --> 00:05:51.546
Note also that as the type size
changes, it's not all being fit

111
00:05:51.546 --> 00:05:52.736
into the same size box.

112
00:05:53.436 --> 00:05:55.666
Mail has a really great
dynamic type citizen

113
00:05:55.666 --> 00:05:58.426
and it's actually
reacting to the size

114
00:05:58.606 --> 00:06:00.506
of the user's preference

115
00:05:58.606 --> 00:06:00.506
of the user's preference

116
00:06:01.046 --> 00:06:05.116
and resizing the table
view cells to match.

117
00:06:05.976 --> 00:06:09.896
So even though by its very
nature as the type gets larger,

118
00:06:10.406 --> 00:06:12.066
the information density
decreases.

119
00:06:13.336 --> 00:06:16.346
Mail itself is reacting to that

120
00:06:16.566 --> 00:06:18.196
and responding to
the user's choice.

121
00:06:19.296 --> 00:06:21.646
Note also that in
addition to the seven sizes

122
00:06:21.646 --> 00:06:23.676
that are available, three
of which I've shown here,

123
00:06:24.166 --> 00:06:31.376
there's also a switch that
can add a bit of weight

124
00:06:31.376 --> 00:06:36.386
to those type styles,
and that's available via

125
00:06:36.386 --> 00:06:37.986
accessibility settings.

126
00:06:39.756 --> 00:06:45.796
So dynamic type is organized by
what we consider to be usage.

127
00:06:46.346 --> 00:06:52.526
Each one of these is a text
style as we like to call it.

128
00:06:52.716 --> 00:06:56.876
As you've seen in the previous
session, there are, I believe,

129
00:06:56.876 --> 00:07:00.546
eight of these different
usage categories

130
00:06:56.876 --> 00:07:00.546
eight of these different
usage categories

131
00:07:00.726 --> 00:07:01.966
for use with text styles.

132
00:07:02.516 --> 00:07:06.826
These are things like
Body, Headline 1, Caption.

133
00:07:07.386 --> 00:07:12.746
And every one of these different
text styles is optimized

134
00:07:12.746 --> 00:07:13.466
for legibility.

135
00:07:14.306 --> 00:07:16.916
We'll be showing you an example
of one of this in particular.

136
00:07:18.196 --> 00:07:20.866
But, again, remember that
the user is responsible

137
00:07:20.866 --> 00:07:22.956
for picking the size
of these text styles.

138
00:07:23.906 --> 00:07:27.996
So, for any given text
style, you're going to see it

139
00:07:28.276 --> 00:07:30.546
in a number of different sizes.

140
00:07:30.666 --> 00:07:32.316
The metrics are going
to change based

141
00:07:32.316 --> 00:07:34.226
on something that's
out of your control.

142
00:07:34.346 --> 00:07:35.606
That is the user
is going to choose.

143
00:07:36.556 --> 00:07:38.436
And so, of course,
we highly encourage

144
00:07:38.516 --> 00:07:44.416
that you adopt auto layout
constraints for resizing your UI

145
00:07:44.646 --> 00:07:48.326
to adapt to the user's content.

146
00:07:48.546 --> 00:07:51.196
But even if you're
not doing that,

147
00:07:51.196 --> 00:07:52.446
you may have some
other techniques.

148
00:07:53.076 --> 00:07:56.226
You should be aware that these
metrics are going to change.

149
00:07:57.486 --> 00:08:00.416
And as I'm sure you've
already seen Interface Builder

150
00:07:57.486 --> 00:08:00.416
And as I'm sure you've
already seen Interface Builder

151
00:08:00.416 --> 00:08:03.136
with Xcode 5 has a great
support for these text styles,

152
00:08:03.136 --> 00:08:04.786
so you can specify
them right in line

153
00:08:05.106 --> 00:08:06.546
where you're designing
your user interface.

154
00:08:06.706 --> 00:08:11.056
Now, let's take a look at one of
these text styles in particular.

155
00:08:12.126 --> 00:08:15.796
On the slide, I've chosen one
of the subhead text styles

156
00:08:16.486 --> 00:08:20.066
and what I have here is what's
called the waterfall chart

157
00:08:20.636 --> 00:08:25.416
which is simply the same
sample text set in all

158
00:08:25.416 --> 00:08:27.036
of the different user
selectable sizes.

159
00:08:27.586 --> 00:08:31.616
Now, you don't have to
be a typographer to see

160
00:08:31.616 --> 00:08:34.785
that this text is
clearly related,

161
00:08:34.785 --> 00:08:37.676
all these different sizes
probably meaning the same thing.

162
00:08:38.366 --> 00:08:41.006
But again, not just sizes.

163
00:08:41.436 --> 00:08:43.506
We have a type system involved

164
00:08:43.856 --> 00:08:48.976
where this particular text style
subhead is related visually

165
00:08:48.976 --> 00:08:53.226
to the other text styles and
so one of these in conjunction

166
00:08:53.226 --> 00:08:57.266
with other text styles
allows you to present a very,

167
00:08:57.266 --> 00:09:01.316
very rich information hierarchy.

168
00:08:57.266 --> 00:09:01.316
very rich information hierarchy.

169
00:09:02.426 --> 00:09:05.456
You'll also note that this
particular text style --

170
00:09:05.716 --> 00:09:07.606
all these different sizes
have a very consistent --

171
00:09:07.656 --> 00:09:09.306
what typographers call color.

172
00:09:10.656 --> 00:09:14.736
But let's zoom in and take a
look at what I mean when I say

173
00:09:14.736 --> 00:09:16.606
that these are optimized
for legibility.

174
00:09:17.246 --> 00:09:21.386
So, we're going take
a look at the smallest

175
00:09:21.896 --> 00:09:25.666
and the largest text
styles sizes zoomed

176
00:09:25.666 --> 00:09:27.626
in to the same point size.

177
00:09:28.206 --> 00:09:32.476
And here I've taken the liberty
of annotating the white space

178
00:09:32.956 --> 00:09:37.926
in this example to show you that
besides having different weights

179
00:09:38.496 --> 00:09:40.906
of type in this particular
example,

180
00:09:41.886 --> 00:09:43.746
we've also adjusted
the letter spacing

181
00:09:44.226 --> 00:09:48.626
because a smaller text needs
more room to breathe in order

182
00:09:48.626 --> 00:09:52.306
for us to ingest it
with our brains and eyes

183
00:09:52.656 --> 00:09:55.326
to really dig into the context.

184
00:09:55.476 --> 00:09:57.586
These sizes adjust
both the letter spacing

185
00:09:57.936 --> 00:10:01.156
and also the line spacing
which is hard to show

186
00:09:57.936 --> 00:10:01.156
and also the line spacing
which is hard to show

187
00:10:01.156 --> 00:10:01.976
on this particular example.

188
00:10:03.296 --> 00:10:06.846
But -- So, if you can
consider that we have this grid

189
00:10:06.846 --> 00:10:09.866
of these different sizes,
these different styles,

190
00:10:09.906 --> 00:10:12.346
there's really a huge amount
of design effort that went

191
00:10:12.346 --> 00:10:15.586
into these typefaces
and the great part is

192
00:10:15.686 --> 00:10:18.106
that they're all
available to you.

193
00:10:18.666 --> 00:10:24.326
So in order to make use of these
text styles, this huge amount

194
00:10:24.326 --> 00:10:28.026
of design for this
beautiful type,

195
00:10:28.026 --> 00:10:29.416
you'll probably been making use

196
00:10:29.416 --> 00:10:32.036
of UIFont
preferredFontForTextStyle

197
00:10:33.046 --> 00:10:35.236
which is a class
factory method on UIFont

198
00:10:35.476 --> 00:10:38.346
that takes a single
argument which is one

199
00:10:38.346 --> 00:10:40.056
of those text style identifiers

200
00:10:40.296 --> 00:10:42.256
that you can find
in UIFontDescriptor.

201
00:10:44.496 --> 00:10:48.126
Besides the base text
style categories,

202
00:10:48.126 --> 00:10:51.376
you can also make
some changes to those

203
00:10:51.466 --> 00:10:54.036
by modifying them
with symbolic traits.

204
00:10:54.816 --> 00:10:57.226
So the ones in particular
that you're likely

205
00:10:57.226 --> 00:11:00.546
to find useful are Bold, Italic,
and we also have special traits

206
00:10:57.226 --> 00:11:00.546
to find useful are Bold, Italic,
and we also have special traits

207
00:11:00.616 --> 00:11:02.326
for adjusting the line spacing.

208
00:11:02.856 --> 00:11:07.796
So depending on the content
being presented, you may be able

209
00:11:07.906 --> 00:11:12.586
to tighten the line spacing
a bit if you're dealing

210
00:11:12.586 --> 00:11:14.746
with say a single label.

211
00:11:16.066 --> 00:11:19.596
Or for longer line lengths,
you may find it necessary

212
00:11:19.596 --> 00:11:21.926
to actually loosen the line
spacing to give a bit more

213
00:11:21.926 --> 00:11:25.206
of that white space that's
needed for best legibility,

214
00:11:25.886 --> 00:11:27.286
and we'll be showing
you an example of how

215
00:11:27.286 --> 00:11:28.626
to do that in code shortly.

216
00:11:29.946 --> 00:11:33.006
Note also that all of this
amazing technology is available

217
00:11:33.556 --> 00:11:34.766
in CSS as well.

218
00:11:35.426 --> 00:11:38.346
One of the earlier sessions,
the Intro to Text Kit Session

219
00:11:38.896 --> 00:11:41.096
and you may have also heard
in the WebKit session,

220
00:11:41.436 --> 00:11:44.506
there are properties
corresponding to each one

221
00:11:44.506 --> 00:11:48.096
of these type styles -- text
styles, they're prefixed

222
00:11:48.096 --> 00:11:51.516
with -apple-system, and
so you can find the list

223
00:11:51.516 --> 00:11:53.546
of those elsewhere, but --

224
00:11:54.086 --> 00:11:58.416
so if any part of your UI is
still built using a WebView,

225
00:11:58.686 --> 00:11:59.966
that's all right.

226
00:12:00.486 --> 00:12:00.886
That's great.

227
00:12:00.886 --> 00:12:03.006
You can still access
this great technology.

228
00:12:03.626 --> 00:12:12.706
Now, text styles are part of a
larger category of fonts that I

229
00:12:13.186 --> 00:12:15.486
like to think of as
being sort of a metafont.

230
00:12:16.496 --> 00:12:19.716
So, you'll note that with
text styles in particular,

231
00:12:20.296 --> 00:12:24.826
as you may have seen in that
example, I know that the weight

232
00:12:24.926 --> 00:12:27.086
of the type was actually
changing in response

233
00:12:27.186 --> 00:12:29.546
to the user preference.

234
00:12:29.786 --> 00:12:34.346
And so naturally, you can assume
that for a given text style,

235
00:12:34.396 --> 00:12:38.386
the actual font that's
used to render that text

236
00:12:38.926 --> 00:12:42.186
to screen may not be the
same in all situations.

237
00:12:42.646 --> 00:12:46.456
And so, we've also
seen this on OS X

238
00:12:47.356 --> 00:12:52.756
where Mavericks brings a new
system UIFont that's optimized

239
00:12:52.756 --> 00:12:55.146
for Retina Displays.

240
00:12:55.716 --> 00:12:59.726
And so, as OS X developers,
those of you in the audience

241
00:12:59.726 --> 00:13:03.186
who have done programming
in OS X, you may be familiar

242
00:12:59.726 --> 00:13:03.186
who have done programming
in OS X, you may be familiar

243
00:13:03.186 --> 00:13:06.846
with the various NSFont class
factory methods for getting

244
00:13:06.886 --> 00:13:10.686
at what I would consider
to be this system font,

245
00:13:10.746 --> 00:13:13.466
this semantic notions
of what a font may be.

246
00:13:14.096 --> 00:13:17.326
You may have seen menu font
of size, control font of size,

247
00:13:17.326 --> 00:13:17.976
these types of things.

248
00:13:18.766 --> 00:13:21.826
But, many of you may
have also noticed

249
00:13:21.896 --> 00:13:24.106
that in the past whenever
you used one of these,

250
00:13:24.106 --> 00:13:28.176
you typically got back the same
thing every time, Lucida Grande.

251
00:13:29.946 --> 00:13:32.446
And so you may have said, "well,
you know, I mean this is great,

252
00:13:32.496 --> 00:13:35.376
but I know it's just
going to end

253
00:13:35.376 --> 00:13:36.536
up being the same
thing in the end.

254
00:13:36.976 --> 00:13:40.086
So I may as well just
specify that in my code

255
00:13:40.086 --> 00:13:42.016
or in my zeb [phonetic]
or whatever".

256
00:13:43.456 --> 00:13:50.826
But by doing so, you lose the
ability to adapt to improvements

257
00:13:50.826 --> 00:13:54.596
that are made in the
system font technologies.

258
00:13:55.936 --> 00:13:58.736
You'll note that this is
particularly so when it comes

259
00:13:58.776 --> 00:14:01.656
to text styles because
it's not just

260
00:13:58.776 --> 00:14:01.656
to text styles because
it's not just

261
00:14:01.696 --> 00:14:04.296
that the font may be changing
across releases, they're going

262
00:14:04.296 --> 00:14:07.056
to be changing dynamically
and in the Intro

263
00:14:07.056 --> 00:14:10.446
to Text Kit Session, you saw how
to adapt to that dynamically.

264
00:14:11.486 --> 00:14:17.416
But one thing that's shared
with all of these fonts is

265
00:14:17.416 --> 00:14:20.856
that when you poke around, you
may end up seeing font names

266
00:14:20.966 --> 00:14:21.966
that start with a period.

267
00:14:23.556 --> 00:14:26.386
And, as we all know from
our grand UNIX history,

268
00:14:26.746 --> 00:14:29.896
something that begins with a
period is not meant to be seen.

269
00:14:30.916 --> 00:14:34.296
And so when you're dealing
with these system fonts,

270
00:14:34.676 --> 00:14:38.756
if you find one of these, that's
a sign to you, the developer,

271
00:14:38.756 --> 00:14:41.656
that not only are you not
be presenting those names

272
00:14:42.126 --> 00:14:45.336
to the user directly,
but it's also a note

273
00:14:45.966 --> 00:14:47.696
that there's magic involved.

274
00:14:48.566 --> 00:14:51.076
And so really you should
be dealing with these

275
00:14:51.136 --> 00:14:55.326
by identifying these system
fonts using their semantic

276
00:14:55.326 --> 00:14:57.946
identifiers, this class factory
methods, these text styles.

277
00:14:58.666 --> 00:15:02.366
And never -- would it be
appropriate to drop down

278
00:14:58.666 --> 00:15:02.366
And never -- would it be
appropriate to drop down

279
00:15:02.836 --> 00:15:08.016
and grab a CD font and deal
with that moving onwards.

280
00:15:08.826 --> 00:15:12.786
So, UIFont does have one of
these class factory methods

281
00:15:13.126 --> 00:15:15.486
that you've seen
before, systemFontOfSize,

282
00:15:15.836 --> 00:15:19.396
also Bold and Italic variants.

283
00:15:19.846 --> 00:15:22.346
But this is -- there's
a clear distinction

284
00:15:22.346 --> 00:15:23.756
to be made now in iOS 7.

285
00:15:24.416 --> 00:15:26.986
The system font is not meant
to be used for user content,

286
00:15:27.576 --> 00:15:30.066
that's what text styles are for.

287
00:15:30.126 --> 00:15:33.146
And in addition, only if
you recompiled your app

288
00:15:33.386 --> 00:15:37.966
for iOS 7 will that
system font be adopting any

289
00:15:37.966 --> 00:15:41.936
of the new improvements
made to the typography.

290
00:15:42.936 --> 00:15:46.216
So, keep this in mind when
you're designing your app

291
00:15:46.216 --> 00:15:48.196
and your users will thank you.

292
00:15:49.576 --> 00:15:56.076
So UIFontDescriptor or -- also a
very similar technology on OS X,

293
00:15:56.076 --> 00:15:58.546
NSFont Descriptor, is the class

294
00:15:58.546 --> 00:16:02.456
that we use for describing
fonts.

295
00:15:58.546 --> 00:16:02.456
that we use for describing
fonts.

296
00:16:02.456 --> 00:16:04.766
It's a very, very
lightweight mechanism.

297
00:16:05.186 --> 00:16:09.196
It doesn't involve spooling up
any rendering system in order

298
00:16:09.196 --> 00:16:10.926
to have an actual font on hand.

299
00:16:11.386 --> 00:16:14.436
It's simply the mechanism we
use for getting up that font.

300
00:16:15.366 --> 00:16:16.536
It allows you to access

301
00:16:16.536 --> 00:16:18.586
and in some cases
modify font properties.

302
00:16:18.586 --> 00:16:20.016
We'll be showing
you that as well.

303
00:16:20.756 --> 00:16:24.086
UIFontDescriptor is the
base technology for finding

304
00:16:24.086 --> 00:16:27.126
out what fonts are
available to your app

305
00:16:27.626 --> 00:16:29.146
and it's also the mechanism

306
00:16:29.146 --> 00:16:30.886
by which you can
specify your own fonts

307
00:16:31.046 --> 00:16:34.846
if you've licensed them for
use in your user interface.

308
00:16:35.966 --> 00:16:41.606
So the way we use a descriptor
is by noting that it looks a lot

309
00:16:41.606 --> 00:16:44.986
like a dictionary
with key value pairs.

310
00:16:46.166 --> 00:16:48.866
In this case, those key
value pairs are called

311
00:16:48.866 --> 00:16:50.066
font attributes.

312
00:16:50.876 --> 00:16:53.456
They correspond to any number

313
00:16:53.456 --> 00:16:56.216
of particular properties
that fonts have.

314
00:16:56.496 --> 00:16:58.686
It bears the names, the size,

315
00:16:59.086 --> 00:17:01.116
what typographic
features might be enabled.

316
00:16:59.086 --> 00:17:01.116
what typographic
features might be enabled.

317
00:17:01.886 --> 00:17:06.056
And you'll note that using
a descriptor, it's very easy

318
00:17:06.056 --> 00:17:09.685
to create one for a
font that doesn't exist.

319
00:17:10.906 --> 00:17:13.955
For instance, I could use
a descriptor to specify

320
00:17:13.955 --> 00:17:19.596
that I want a font that's
in the Helvetica family

321
00:17:20.796 --> 00:17:26.836
and that its style is purp --
well, until type designers sort

322
00:17:27.046 --> 00:17:30.576
of embrace their
synesthetic side when it comes

323
00:17:30.576 --> 00:17:32.466
to designing fonts,
I doubt we're going

324
00:17:32.466 --> 00:17:36.616
to see purple being a
commonly use style for a font.

325
00:17:37.196 --> 00:17:40.716
But, we're going to need
a mechanism for finding

326
00:17:40.716 --> 00:17:42.546
out whether or not these
descriptors correspond

327
00:17:42.546 --> 00:17:45.866
to actual fonts in the system,
and then the mechanism we use

328
00:17:45.866 --> 00:17:47.446
for that is called matching.

329
00:17:48.026 --> 00:17:53.136
So there's two types of
descriptor matching when we want

330
00:17:53.196 --> 00:17:55.926
to take an abstract
descriptor and turn

331
00:17:55.926 --> 00:17:57.096
into something more concrete,

332
00:17:57.096 --> 00:17:59.226
that is something that's
based on the real font.

333
00:17:59.746 --> 00:18:04.446
And the first is
explicit matching.

334
00:17:59.746 --> 00:18:04.446
And the first is
explicit matching.

335
00:18:05.356 --> 00:18:07.456
You can invoke
matchingFontDescriptors

336
00:18:07.456 --> 00:18:09.236
WithMandatoryKeys
on a descriptor.

337
00:18:10.096 --> 00:18:13.366
And you'll get back an
array of potentially many --

338
00:18:13.366 --> 00:18:18.106
potentially no font descriptors
that correspond to fonts

339
00:18:18.106 --> 00:18:20.046
that are actually
available to your application

340
00:18:20.046 --> 00:18:20.866
at the time of that call.

341
00:18:21.686 --> 00:18:26.746
There're also various methods
that perform this matching

342
00:18:26.796 --> 00:18:29.406
on your behalf and so this I

343
00:18:29.406 --> 00:18:32.036
like to consider
implicit matching.

344
00:18:32.976 --> 00:18:35.976
So, for instance,
fontDescriptorWithSymbolicTraits

345
00:18:36.456 --> 00:18:39.736
which we'll have a code
example of in just a moment,

346
00:18:39.736 --> 00:18:41.616
when you invoke this method,

347
00:18:42.116 --> 00:18:44.086
it will be using
matchingFontDescriptors

348
00:18:44.086 --> 00:18:46.726
WithMandatoryKeys under the hood

349
00:18:47.366 --> 00:18:51.176
and so the results you get
back will correspond to fonts

350
00:18:51.176 --> 00:18:53.806
that are actually available,
and so in that sense,

351
00:18:54.016 --> 00:18:56.816
it's being done implicitly
on your behalf.

352
00:18:57.426 --> 00:18:58.966
In addition, you
can create a font

353
00:18:58.966 --> 00:19:02.476
from a descriptor directly
because, of course, when we want

354
00:18:58.966 --> 00:19:02.476
from a descriptor directly
because, of course, when we want

355
00:19:02.476 --> 00:19:04.836
to materialize that
descriptor into a font,

356
00:19:05.256 --> 00:19:07.836
we need to have something
to use in that case.

357
00:19:08.416 --> 00:19:12.816
And so this method will also
perform matching on your behalf

358
00:19:13.336 --> 00:19:16.566
but it also means that if
you didn't explicitly make

359
00:19:16.596 --> 00:19:20.976
that match before hand, it might
not be exactly what you expected

360
00:19:21.556 --> 00:19:24.926
due to having specified a
font that doesn't exist.

361
00:19:25.916 --> 00:19:28.326
So let's go ahead
and make a match.

362
00:19:28.656 --> 00:19:32.036
On this code example, I'm
creating a UIFrontDescriptor

363
00:19:32.426 --> 00:19:34.416
from a dictionary
of font attributes.

364
00:19:34.886 --> 00:19:39.246
In this case, I'm specifying the
family attribute with the value

365
00:19:39.246 --> 00:19:42.776
of Helvetica Neue, and I want
to see what's available to me.

366
00:19:44.156 --> 00:19:46.516
So, as I mentioned, I invoked
matchingFontDescriptors

367
00:19:46.516 --> 00:19:47.466
WithMandatoryKeys.

368
00:19:48.406 --> 00:19:50.006
In this case, I'm
going to pass nill.

369
00:19:50.006 --> 00:19:52.426
This is the most common
situation, passing nill means

370
00:19:52.426 --> 00:19:55.476
to use all of the keys,
all of the font attributes

371
00:19:55.476 --> 00:19:56.176
in the dictionary

372
00:19:56.596 --> 00:19:58.886
when considering what
constitutes a match.

373
00:19:59.196 --> 00:20:03.556
But if you would like to only
consider certain attributes

374
00:19:59.196 --> 00:20:03.556
But if you would like to only
consider certain attributes

375
00:20:03.786 --> 00:20:06.646
in the font descriptor, you
can use the mandatory keys

376
00:20:06.696 --> 00:20:07.586
to narrow that down.

377
00:20:07.806 --> 00:20:09.846
But, as I mentioned,
in most cases,

378
00:20:09.846 --> 00:20:11.346
we'll just be passing
nill to use all.

379
00:20:12.076 --> 00:20:14.386
If I run this on iOS 7,
I'll get back an array

380
00:20:14.826 --> 00:20:19.246
with the number descriptors, 14,
I believe, for various members

381
00:20:19.296 --> 00:20:20.986
of the Helvetica Neue family.

382
00:20:21.906 --> 00:20:24.126
I mentioned also that
we can use descriptors

383
00:20:24.626 --> 00:20:28.836
to modify text styles
and other fonts as well.

384
00:20:29.596 --> 00:20:34.646
So in this case, I'd like to
get at a Bold body text style

385
00:20:35.896 --> 00:20:37.616
and there's no category,

386
00:20:37.736 --> 00:20:41.376
no constant for specifying
a Bold body text style,

387
00:20:42.196 --> 00:20:45.786
but I can apply the
Bold symbolic trait

388
00:20:46.416 --> 00:20:48.756
to the standard body text style

389
00:20:48.756 --> 00:20:51.926
if I need some emphasis
in my body text.

390
00:20:52.716 --> 00:20:55.626
In this particular example,
since I'm not starting

391
00:20:55.626 --> 00:20:59.816
from a UIFont, I don't need to
spend everything up just to get

392
00:20:59.816 --> 00:21:02.706
at a font -- just to get another
font, so I'm going to start

393
00:20:59.816 --> 00:21:02.706
at a font -- just to get another
font, so I'm going to start

394
00:21:02.706 --> 00:21:05.946
by getting a UIFontDescriptor
using preferredFontDescriptor

395
00:21:05.946 --> 00:21:06.716
WithTextStyle.

396
00:21:07.696 --> 00:21:09.686
I'm passing in the
relevant constant,

397
00:21:09.816 --> 00:21:11.556
in this case, text style body.

398
00:21:12.126 --> 00:21:14.656
And then we're going
to modify it

399
00:21:14.656 --> 00:21:16.296
with the symbolic
trait for Bold.

400
00:21:16.296 --> 00:21:18.436
In this case, I know
that there's going

401
00:21:18.436 --> 00:21:21.226
to be Bold variant available
but, again, if there's --

402
00:21:21.476 --> 00:21:23.816
if I were using a different font

403
00:21:23.816 --> 00:21:26.246
and they weren't a Bold
style available to me,

404
00:21:26.246 --> 00:21:29.976
then I would be left with
the original descriptor,

405
00:21:29.976 --> 00:21:33.076
but that's OK because
then I'll go ahead

406
00:21:33.076 --> 00:21:36.416
and create the relevant font, in
this case, from that descriptor.

407
00:21:37.176 --> 00:21:40.036
You'll note also that
the size parameter

408
00:21:40.546 --> 00:21:42.826
that I'm passing in is zero.

409
00:21:44.086 --> 00:21:47.846
And that indicates that
when using the descriptor,

410
00:21:47.906 --> 00:21:52.166
I'd like to not override the
size that it itself specified.

411
00:21:53.046 --> 00:21:56.126
So, in this case, zero
simply means don't change.

412
00:21:56.426 --> 00:22:01.436
And now I have my Bold text
style for use in bodies.

413
00:21:56.426 --> 00:22:01.436
And now I have my Bold text
style for use in bodies.

414
00:22:03.016 --> 00:22:05.436
Descriptors are also
the preferred mechanism

415
00:22:05.536 --> 00:22:07.446
for serializing font data.

416
00:22:08.026 --> 00:22:10.656
So, of course, from a font
descriptor, we can coerce

417
00:22:10.656 --> 00:22:12.856
to a font and for
any given font,

418
00:22:13.036 --> 00:22:15.066
we can get a font
descriptor that describes it.

419
00:22:15.676 --> 00:22:19.346
So this is relevant when
we have a font that we'd

420
00:22:19.346 --> 00:22:21.116
like to serialize, we'll
use this descriptor.

421
00:22:21.626 --> 00:22:25.966
This is very easy since
font descriptors can form

422
00:22:25.966 --> 00:22:28.806
to the UI -- to the
NSCoding protocol,

423
00:22:29.876 --> 00:22:34.736
but you may have a
mechanism for archiving

424
00:22:35.096 --> 00:22:37.636
and unarchiving objects
that doesn't use NSCoding.

425
00:22:38.146 --> 00:22:40.726
In this case, you should
be accessing the dictionary

426
00:22:40.726 --> 00:22:42.616
of font attributes
on a descriptor.

427
00:22:43.376 --> 00:22:47.646
But note that because of all
of the various possibilities

428
00:22:47.646 --> 00:22:48.546
when describing fonts,

429
00:22:48.546 --> 00:22:52.516
you should be using those
attributes as an atomic entity.

430
00:22:52.516 --> 00:22:55.726
You shouldn't be trying to pick
various attributes out of it

431
00:22:55.726 --> 00:23:00.206
and assume that that's going to
be able to reconstitute a font

432
00:22:55.726 --> 00:23:00.206
and assume that that's going to
be able to reconstitute a font

433
00:23:00.636 --> 00:23:02.916
on the other end, so
just use all of these

434
00:23:02.916 --> 00:23:05.906
and serialize them as necessary.

435
00:23:05.906 --> 00:23:08.456
Descriptors can also be used
to modify font instances.

436
00:23:09.396 --> 00:23:13.076
Now, when I say modify, it don't
mean that you're able to go in

437
00:23:13.076 --> 00:23:14.476
and change the font
data on disk.

438
00:23:15.166 --> 00:23:18.566
But what you can do is
change the behavior of a font

439
00:23:18.566 --> 00:23:22.126
when you make use
of it in your app.

440
00:23:22.126 --> 00:23:25.316
Two examples in particular
that we're going to see are how

441
00:23:25.316 --> 00:23:27.956
to activate typographic
features and how

442
00:23:27.956 --> 00:23:29.976
to remove unwanted characters

443
00:23:30.016 --> 00:23:31.786
to limit the character
coverage of a font.

444
00:23:32.636 --> 00:23:34.436
So, as I mentioned
earlier, of course,

445
00:23:34.616 --> 00:23:37.936
String plus Font equals
Glyphs, Unicode text layout.

446
00:23:39.226 --> 00:23:41.066
Well one of the neat
things about fonts is

447
00:23:41.126 --> 00:23:46.206
that they can often implement
special features that modify

448
00:23:46.206 --> 00:23:47.206
that process in somehow

449
00:23:47.776 --> 00:23:53.576
and these features are
called typographic features,

450
00:23:53.956 --> 00:23:59.516
and in this particular example,
I have a font where normally

451
00:23:59.776 --> 00:24:03.586
when I layout text using this
font, I get one appearance

452
00:23:59.776 --> 00:24:03.586
when I layout text using this
font, I get one appearance

453
00:24:03.876 --> 00:24:05.206
as you can see on the top here.

454
00:24:06.566 --> 00:24:07.906
It says 11:15.

455
00:24:08.726 --> 00:24:12.416
And you'll note that even
though this particular font, 12,

456
00:24:12.476 --> 00:24:15.066
you can't really see it, but
this font is a proportional font

457
00:24:15.066 --> 00:24:17.186
that is it's not monospaced,

458
00:24:17.386 --> 00:24:19.406
different characters
have different widths.

459
00:24:19.816 --> 00:24:22.236
You'll note that the
digits in this font,

460
00:24:22.336 --> 00:24:25.786
they're all monospaced, the
ones the same width as the five.

461
00:24:25.786 --> 00:24:29.906
And this is a very common design
that you'll see from fonts

462
00:24:30.406 --> 00:24:34.156
because it makes it easy to
line up figures in columns,

463
00:24:34.606 --> 00:24:38.646
but I'm no accountant and
I know that in this case,

464
00:24:38.646 --> 00:24:40.996
this particular string
means that I'm trying

465
00:24:40.996 --> 00:24:43.906
to display a font --
a time to the user,

466
00:24:44.386 --> 00:24:48.896
let's say for time stamp
in a table that I have data

467
00:24:48.896 --> 00:24:51.426
that I'd like to present.

468
00:24:51.426 --> 00:24:53.606
And so I've been
told by my designer

469
00:24:53.606 --> 00:24:58.446
that this particular font
has typographic features

470
00:24:58.556 --> 00:25:02.126
that allow me to apply
a time appearance to it.

471
00:24:58.556 --> 00:25:02.126
that allow me to apply
a time appearance to it.

472
00:25:02.126 --> 00:25:05.646
And one of those is one that I
can use in other cases as well

473
00:25:06.186 --> 00:25:09.066
and that's to make these
digits proportional.

474
00:25:09.846 --> 00:25:11.126
And so in this particular
example,

475
00:25:11.126 --> 00:25:15.826
you can see very clearly how the
ones now have a narrower width

476
00:25:17.016 --> 00:25:22.426
and since I'm dealing with
time, this font, I've been told,

477
00:25:22.426 --> 00:25:24.356
has another great
feature that I can use

478
00:25:24.356 --> 00:25:27.416
and that's an alternate
set of glyphs.

479
00:25:27.946 --> 00:25:32.156
In this case, the alternate
set includes a different colon

480
00:25:32.686 --> 00:25:35.836
that clearly looks
like a time separator.

481
00:25:35.836 --> 00:25:40.706
Rather than being rectangular,
you can see that it's circular

482
00:25:40.706 --> 00:25:44.096
and it's brought up
off the baseline a bit.

483
00:25:44.316 --> 00:25:46.216
So -- And this is
what I'd like to use,

484
00:25:46.896 --> 00:25:48.406
how can I do this in code?

485
00:25:48.796 --> 00:25:54.436
Well, first I'd like to build
up an array of feature settings.

486
00:25:55.146 --> 00:25:58.606
So feature settings are
these -- are the identifiers,

487
00:25:58.606 --> 00:26:01.836
the handles onto these
typographic features

488
00:25:58.606 --> 00:26:01.836
the handles onto these
typographic features

489
00:26:01.996 --> 00:26:03.476
that can be implemented
by a font

490
00:26:04.096 --> 00:26:06.406
and you can programatically
query the fonts to find

491
00:26:06.406 --> 00:26:09.396
out what's available,
but in this case,

492
00:26:09.396 --> 00:26:12.106
I've been told specifically
which ones I need to use.

493
00:26:13.026 --> 00:26:15.816
I'm using the Objective-C
literal syntax for doing that,

494
00:26:15.896 --> 00:26:20.176
and so if we unpack this,
you can see it's an array

495
00:26:20.176 --> 00:26:23.366
of two dictionaries and each

496
00:26:23.366 --> 00:26:26.616
of those dictionaries is
specifying both the type

497
00:26:26.856 --> 00:26:30.816
and a selector as the key
and the values are relevant

498
00:26:30.816 --> 00:26:33.316
to those particular
features that I'm trying

499
00:26:33.316 --> 00:26:36.086
to enable on this font.

500
00:26:36.276 --> 00:26:37.516
So, the first one you can see,

501
00:26:37.516 --> 00:26:40.596
it's very clearly
described number spacing type

502
00:26:41.096 --> 00:26:43.176
which is kind of a
grouping of features

503
00:26:43.176 --> 00:26:46.236
and then the proportional
numbers is what I'm going

504
00:26:46.236 --> 00:26:46.776
to be enabling.

505
00:26:48.166 --> 00:26:50.266
And this other one, this
character alternatives,

506
00:26:51.066 --> 00:26:54.736
you'll note this pesky little
magic value, magic constant 1.

507
00:26:55.476 --> 00:27:01.366
Well, so there are a number of
predefined typographic features,

508
00:26:55.476 --> 00:27:01.366
Well, so there are a number of
predefined typographic features,

509
00:27:01.846 --> 00:27:04.936
names that we've given
because we have seen them

510
00:27:04.936 --> 00:27:06.926
in so many fonts, but remember

511
00:27:06.926 --> 00:27:10.286
that typographic features are
kind of like an API to a font.

512
00:27:10.766 --> 00:27:15.286
And so a font is free to define
its own typographic features

513
00:27:16.056 --> 00:27:17.826
and that's exactly what
this font has done.

514
00:27:19.256 --> 00:27:21.366
It's defined a particular
selector

515
00:27:21.366 --> 00:27:23.916
in that character
alternatives type of 1.

516
00:27:24.606 --> 00:27:27.206
And so if that font came with
a header, somehow we could,

517
00:27:27.206 --> 00:27:28.246
you know, give it
a magic cons --

518
00:27:28.246 --> 00:27:30.466
maybe we'll give it
a name in your code

519
00:27:30.516 --> 00:27:33.206
so we know what's going
on, but in this case,

520
00:27:33.206 --> 00:27:36.526
our designer has told
us this is how to enable

521
00:27:36.526 --> 00:27:39.186
that particular change
that you'd like to make

522
00:27:39.186 --> 00:27:41.076
in the appearance of the glyphs.

523
00:27:41.986 --> 00:27:43.736
So once we have that
array of feature settings,

524
00:27:43.736 --> 00:27:45.836
what we're going to do
is we're going to assume

525
00:27:45.836 --> 00:27:48.706
that we've started with the
font already, that original font

526
00:27:48.986 --> 00:27:51.226
in the original appearance
that you saw in the example.

527
00:27:52.606 --> 00:27:53.906
We're going to get
its descriptor.

528
00:27:54.916 --> 00:27:56.636
Now, we're going to
create a new descriptor

529
00:27:57.236 --> 00:27:59.026
by modifying the
original descriptor

530
00:27:59.596 --> 00:28:02.166
by adding attributes to it.

531
00:27:59.596 --> 00:28:02.166
by adding attributes to it.

532
00:28:02.596 --> 00:28:04.366
In this case, there's
just one attribute,

533
00:28:04.366 --> 00:28:07.296
it's the feature settings
attribute and the value

534
00:28:07.296 --> 00:28:10.276
for that is going to be the
array of feature settings

535
00:28:10.386 --> 00:28:11.216
that we defined above.

536
00:28:12.296 --> 00:28:16.066
And then finally, we're going to
say, UIFont, fontWithDescriptor.

537
00:28:16.446 --> 00:28:19.076
We're going to pass that
descriptor that we just created

538
00:28:19.076 --> 00:28:20.056
with those feature settings.

539
00:28:20.746 --> 00:28:22.566
Again, we're going to
pass zero for the size,

540
00:28:22.566 --> 00:28:23.506
meaning don't change it.

541
00:28:24.266 --> 00:28:27.086
And so now, the only difference
between the original font

542
00:28:27.166 --> 00:28:30.446
and time font that we've
made here is it's going

543
00:28:30.446 --> 00:28:33.836
to be the same font but it has
these new features enabled.

544
00:28:34.046 --> 00:28:35.756
And so the font gets
to participate

545
00:28:35.756 --> 00:28:40.706
in that glyph selection process
and during layout it will say,

546
00:28:40.706 --> 00:28:42.546
"oh, I know exactly
what you want

547
00:28:42.546 --> 00:28:44.206
for those ones and that colon.

548
00:28:44.206 --> 00:28:46.306
I know you want this
other glyphs instead."

549
00:28:46.426 --> 00:28:50.436
And these feature settings can
be quite amazingly powerful.

550
00:28:50.836 --> 00:28:53.646
Not only can they change
which glyphs are selected

551
00:28:53.646 --> 00:28:56.476
for certain characters, but they
can also change the interaction

552
00:28:56.816 --> 00:28:58.046
between various glyphs,

553
00:28:58.166 --> 00:29:00.306
ligatures are a great
example of this.

554
00:28:58.166 --> 00:29:00.306
ligatures are a great
example of this.

555
00:29:01.756 --> 00:29:04.136
So another example,
as I mentioned,

556
00:29:04.136 --> 00:29:05.996
is limiting the character
coverage of the font.

557
00:29:07.316 --> 00:29:08.846
So, I've got this
really great app.

558
00:29:09.526 --> 00:29:12.536
It's kind of technical and so
I think Menlo is a great choice

559
00:29:12.536 --> 00:29:16.566
of a font for my --
presenting my user's content.

560
00:29:16.566 --> 00:29:19.986
And as I'm sure it happens
to you a lot -- I --

561
00:29:20.726 --> 00:29:23.816
so many at my documents include
the Unicode snowman character,

562
00:29:23.996 --> 00:29:24.396
of course.

563
00:29:24.996 --> 00:29:27.676
You know, again, I think
I've picked the right font

564
00:29:28.276 --> 00:29:30.576
for this particular
very specialized app,

565
00:29:30.706 --> 00:29:33.526
but I don't know about you, but
I think it's kind of a bit early

566
00:29:33.526 --> 00:29:39.256
in the morning for Menlo
snowman, he's just too happy.

567
00:29:40.636 --> 00:29:43.186
So really what I'd like to
do is I want to use Menlo,

568
00:29:43.186 --> 00:29:45.966
but I don't want to
ever see Menlo snowman.

569
00:29:46.116 --> 00:29:49.286
And so I want to create
a font instance that acts

570
00:29:49.476 --> 00:29:52.006
as if it doesn't
even exist and I'd

571
00:29:52.006 --> 00:29:55.476
like to just let the system
pick a different font,

572
00:29:55.686 --> 00:29:57.736
follow back to different font
whenever it sees a snowman.

573
00:29:58.406 --> 00:30:01.966
Anything will be
better right now.

574
00:29:58.406 --> 00:30:01.966
Anything will be
better right now.

575
00:30:02.456 --> 00:30:04.706
So I mentioned earlier
in passing

576
00:30:04.706 --> 00:30:07.276
that UIFontDescriptor can be
used to access font properties.

577
00:30:08.596 --> 00:30:09.846
And so in this example,

578
00:30:09.846 --> 00:30:13.476
I am going to be ultimately
creating a new descriptor

579
00:30:13.476 --> 00:30:17.086
by modifying an existing one,
but the value of the attribute

580
00:30:17.086 --> 00:30:18.226
that I'm going to be modifying.

581
00:30:18.306 --> 00:30:21.006
First, I want to get from
my original descriptor.

582
00:30:21.006 --> 00:30:22.366
Let me show you how that works.

583
00:30:23.396 --> 00:30:25.166
So, again, we're going to
assume that we have our font,

584
00:30:25.166 --> 00:30:27.596
in this case, in
the example I gave,

585
00:30:27.596 --> 00:30:31.126
it's going to be
a font for Menlo.

586
00:30:31.716 --> 00:30:34.546
We're going to get
this descriptor again,

587
00:30:34.856 --> 00:30:37.586
the original descriptor.

588
00:30:37.636 --> 00:30:41.906
Now, in order to compute what
its character set is going

589
00:30:41.906 --> 00:30:44.516
to be, first we're going to
get its original character set

590
00:30:44.926 --> 00:30:47.266
by invoking object for key

591
00:30:47.266 --> 00:30:50.806
on the original descriptor
getting the character set.

592
00:30:51.916 --> 00:30:56.666
We're going to mutate that by
removing that one character,

593
00:30:56.666 --> 00:30:57.836
just that one snowman character.

594
00:30:58.376 --> 00:31:01.246
And so now we have a character
set which is exactly identical

595
00:30:58.376 --> 00:31:01.246
And so now we have a character
set which is exactly identical

596
00:31:01.246 --> 00:31:07.146
to the original font's character
set minus that one character.

597
00:31:07.696 --> 00:31:11.636
And then just as before, we're
going to make a new descriptor

598
00:31:12.966 --> 00:31:17.026
by adding an attribute and the
nice thing about this method is

599
00:31:17.026 --> 00:31:23.856
that it's defined as using the
new values to override anything

600
00:31:23.856 --> 00:31:26.516
that is already in the font.

601
00:31:26.566 --> 00:31:28.046
So there is no conflict here.

602
00:31:28.366 --> 00:31:31.386
It's going to know that this new
character set attribute is going

603
00:31:31.386 --> 00:31:34.326
to be the one that I want
and when I create a font

604
00:31:34.326 --> 00:31:37.286
with that descriptor -- now
whenever I use that font

605
00:31:37.286 --> 00:31:41.526
in my app, it will use Menlo
for all the text except

606
00:31:41.526 --> 00:31:43.216
that snowman character and in

607
00:31:43.316 --> 00:31:48.966
that case the font subsystem is
going to pick up fallback fonts

608
00:31:49.056 --> 00:31:51.366
to use that to run to
that character instead.

609
00:31:52.496 --> 00:31:56.096
So there're also some
great opportunities for you

610
00:31:56.096 --> 00:31:59.926
to bring your own fonts to
your designs, your app design,

611
00:31:59.926 --> 00:32:02.886
and this goes not
only for iOS but also

612
00:31:59.926 --> 00:32:02.886
and this goes not
only for iOS but also

613
00:32:03.096 --> 00:32:04.526
for OS X Mavericks as well.

614
00:32:05.176 --> 00:32:09.006
So, if you're design
includes something custom,

615
00:32:09.476 --> 00:32:10.736
this is how we'll make it work.

616
00:32:11.136 --> 00:32:14.166
So bringing your own font
to the table is pretty easy.

617
00:32:14.166 --> 00:32:15.386
We've got lots of options.

618
00:32:15.636 --> 00:32:18.806
So when you're talking to
your designers or the foundry

619
00:32:18.806 --> 00:32:20.266
from what you're going
to license your font,

620
00:32:20.746 --> 00:32:22.306
they may ask you some
of these questions.

621
00:32:22.306 --> 00:32:24.356
And so, these are the answers
you're going to need to know.

622
00:32:25.796 --> 00:32:29.026
We support both -- two type,
an OpenType font containers,

623
00:32:29.366 --> 00:32:34.126
both individual fonts and
as collections and in terms

624
00:32:34.126 --> 00:32:40.356
of the layout information in
those fonts, we support both AAT

625
00:32:40.756 --> 00:32:43.216
and OpenType layout information.

626
00:32:44.436 --> 00:32:48.496
So, really, you shouldn't
have any problem being able

627
00:32:48.526 --> 00:32:51.766
to get the font in a
format that we can support.

628
00:32:52.736 --> 00:32:57.556
And then in order to make use
of that, it's very simple,

629
00:32:57.556 --> 00:32:58.996
you simply place
in your app bundle

630
00:32:58.996 --> 00:33:03.216
because that's how your
resources are bundled.

631
00:32:58.996 --> 00:33:03.216
because that's how your
resources are bundled.

632
00:33:04.856 --> 00:33:07.326
And then the system can
automatically make those

633
00:33:07.326 --> 00:33:09.736
available to your app on iOS

634
00:33:09.926 --> 00:33:13.546
by using the UIAppFonts
Info.plist key

635
00:33:13.546 --> 00:33:15.866
to specify the location on
those fonts and your bundle.

636
00:33:16.496 --> 00:33:20.006
There's also a corresponding
Info.plist key with us,

637
00:33:20.226 --> 00:33:25.446
different name on OS X, but
you may find, and I should say

638
00:33:25.446 --> 00:33:28.066
that once you've
done this, it's --

639
00:33:28.206 --> 00:33:29.716
it acts like any other font

640
00:33:29.796 --> 00:33:31.046
that was previously
installed in the system.

641
00:33:31.076 --> 00:33:34.456
So you can say, "UIFont
fontWithName and the name

642
00:33:34.546 --> 00:33:40.146
of that font that you've
added and there will be.

643
00:33:40.426 --> 00:33:43.796
But we found in some cases
that for various reasons,

644
00:33:44.006 --> 00:33:47.366
this isn't what you want to use.

645
00:33:47.696 --> 00:33:51.016
And some cases, we found that
foundries asked the developers

646
00:33:51.016 --> 00:33:54.676
like you, you know, not have
their fonts just sitting

647
00:33:54.676 --> 00:33:56.696
on unencumbered in
the app bundle

648
00:33:57.306 --> 00:33:58.476
to prevent casual snooping.

649
00:33:59.796 --> 00:34:02.236
And so in these cases,
you might want

650
00:33:59.796 --> 00:34:02.236
And so in these cases,
you might want

651
00:34:02.236 --> 00:34:05.736
to have [inaudible] the font
data in some way and in fact,

652
00:34:05.736 --> 00:34:08.346
we have code example
available online

653
00:34:08.436 --> 00:34:10.116
for how you might
accomplish this on your app.

654
00:34:11.485 --> 00:34:13.476
But once you've done
that, of course,

655
00:34:13.616 --> 00:34:16.366
the system can no
longer automatically make

656
00:34:16.366 --> 00:34:18.755
that font available to
you, and so you may need

657
00:34:18.755 --> 00:34:19.946
to add that font manually.

658
00:34:20.386 --> 00:34:22.335
There're two different types --

659
00:34:22.485 --> 00:34:26.116
there're two different ways
in which you can do that.

660
00:34:26.315 --> 00:34:29.216
The first is by adding the font

661
00:34:29.286 --> 00:34:32.116
as what we call a
registered font.

662
00:34:32.116 --> 00:34:35.485
Using one of these
CT font manager APIs,

663
00:34:35.485 --> 00:34:40.525
you can specify the location
of font data to be referenced

664
00:34:40.576 --> 00:34:42.696
by name after it's been added.

665
00:34:43.696 --> 00:34:47.166
These registered fonts, again,
behave just as if they had been

666
00:34:47.166 --> 00:34:49.496
in your app bundle and
activated automatically,

667
00:34:50.116 --> 00:34:51.826
so you just referenced
them by name.

668
00:34:52.226 --> 00:34:54.366
There's another way in which
you can add fonts however

669
00:34:54.826 --> 00:34:56.146
in which they're unregistered.

670
00:34:56.866 --> 00:35:00.416
In this case, the font's
names can never be matched.

671
00:34:56.866 --> 00:35:00.416
In this case, the font's
names can never be matched.

672
00:35:01.646 --> 00:35:04.756
And you might say, "well,
how was that even useful?"

673
00:35:05.096 --> 00:35:09.336
Well, it's really great actually
because what you get back

674
00:35:09.926 --> 00:35:14.486
from these CT font manager
APIs are new font descriptors.

675
00:35:15.266 --> 00:35:17.836
Now, of course, these
are CT font descriptors,

676
00:35:17.836 --> 00:35:20.186
cortex font descriptors, but
they are toll-free bridged

677
00:35:20.186 --> 00:35:22.826
with UIFontDescriptor on iOS.

678
00:35:23.506 --> 00:35:25.396
So, just a little bit of
casting is all you're going

679
00:35:25.396 --> 00:35:26.186
to need to make this work.

680
00:35:26.736 --> 00:35:28.646
Once you have one of these
descriptors, of course,

681
00:35:28.646 --> 00:35:31.666
we've seen several times now
how you can create a font

682
00:35:31.666 --> 00:35:34.106
from a descriptor, and that's
exactly what you can do

683
00:35:34.106 --> 00:35:34.476
with these.

684
00:35:35.436 --> 00:35:39.626
So even though you can't say
font with name, your fonts name

685
00:35:39.746 --> 00:35:41.046
and get back the fonts.

686
00:35:41.276 --> 00:35:43.046
In this case, you can
create a font directly

687
00:35:43.046 --> 00:35:43.876
from a font descriptor.

688
00:35:45.206 --> 00:35:46.826
This could also be
helpful for instance

689
00:35:47.276 --> 00:35:51.846
if you license a
particular version of a font

690
00:35:51.846 --> 00:35:54.026
that already exists
on the system.

691
00:35:54.086 --> 00:35:57.016
And so, if you for some
reason has special layout

692
00:35:57.016 --> 00:36:01.406
considerations and need to
use your own copy of one

693
00:35:57.016 --> 00:36:01.406
considerations and need to
use your own copy of one

694
00:36:01.406 --> 00:36:03.756
of our fonts, this is a great
way to make that happen.

695
00:36:04.586 --> 00:36:07.446
Now, for making it this far in
the conference, in the session,

696
00:36:07.766 --> 00:36:12.426
we'd like to show you
another little surprise here.

697
00:36:12.616 --> 00:36:15.336
So in iOS 7 -- well,
iOS in general,

698
00:36:15.336 --> 00:36:18.716
we've long had the problem
where on OS X, we have a bunch

699
00:36:18.716 --> 00:36:22.496
of really amazing
beautiful fonts.

700
00:36:22.576 --> 00:36:26.466
But until we can get that shrink
ray working, it's really hard

701
00:36:26.466 --> 00:36:30.356
to squeeze a terabyte of storage
into a little phone that goes

702
00:36:30.356 --> 00:36:34.226
in your pocket and so many of
these fonts we've had to leave

703
00:36:34.226 --> 00:36:37.986
out of iOS because there's
just not enough room.

704
00:36:38.526 --> 00:36:42.256
But there are cases when you
might know that you just need

705
00:36:42.256 --> 00:36:43.586
to use a particular font.

706
00:36:44.406 --> 00:36:49.546
And so, what we've done for iOS
7 is we've made a huge number

707
00:36:49.626 --> 00:36:51.426
of fonts available to you.

708
00:36:52.126 --> 00:36:53.896
We've licensed and hosted these

709
00:36:54.016 --> 00:36:55.556
so that you can make
use of them.

710
00:36:55.556 --> 00:36:57.506
These include literally
hundreds of fonts,

711
00:36:57.956 --> 00:37:01.466
all of the fonts installed in
OS X as well as additional fonts

712
00:36:57.956 --> 00:37:01.466
all of the fonts installed in
OS X as well as additional fonts

713
00:37:01.666 --> 00:37:04.886
for particular support
of international scripts.

714
00:37:05.736 --> 00:37:07.426
And the way -- thank
you [applause].

715
00:37:10.866 --> 00:37:12.606
So the way you take
advantage of this is

716
00:37:12.606 --> 00:37:17.546
by using a very long
API CTFontDescriptor

717
00:37:17.546 --> 00:37:19.696
CreateMatchingFont
DescriptorsWithProgressHandler.

718
00:37:20.866 --> 00:37:25.306
And really, what this is,
is it's a very special type

719
00:37:25.346 --> 00:37:26.576
of descriptor matching.

720
00:37:26.866 --> 00:37:28.066
So we've talked about
this already

721
00:37:28.626 --> 00:37:31.856
and before we saw how
simple it was to match

722
00:37:31.856 --> 00:37:33.046
on a descriptor and
get the results.

723
00:37:33.946 --> 00:37:35.636
Well, with downloadable
fonts of course,

724
00:37:36.916 --> 00:37:39.636
were at the mercy
of the network.

725
00:37:40.746 --> 00:37:45.226
And so essentially what this is
API let's you do is it lets you

726
00:37:45.266 --> 00:37:48.396
perform that descriptor
matching asynchronously.

727
00:37:49.116 --> 00:37:51.436
And so the progress handler
is a block that you pass

728
00:37:51.436 --> 00:37:54.716
in that gets called to handle
the various states during

729
00:37:54.716 --> 00:37:55.246
the download.

730
00:37:55.926 --> 00:37:59.106
And so what this means is that
in order to make effective use

731
00:37:59.106 --> 00:38:00.226
of these downloadable fonts,

732
00:37:59.106 --> 00:38:00.226
of these downloadable fonts,

733
00:38:00.676 --> 00:38:04.316
your app will probably have the
design some UI to allow the user

734
00:38:04.316 --> 00:38:06.306
to recover from various
failure states.

735
00:38:07.076 --> 00:38:10.396
But with that in
mind, it's very simple

736
00:38:10.396 --> 00:38:14.166
to query fonts are available
via this download mechanism

737
00:38:14.536 --> 00:38:17.676
by matching on the
downloadable attribute.

738
00:38:18.936 --> 00:38:20.436
And we'll also be
publishing a list

739
00:38:20.436 --> 00:38:22.556
of those fonts online as well.

740
00:38:23.326 --> 00:38:26.526
So, to make use of
one these fonts, I --

741
00:38:26.686 --> 00:38:27.976
your app can simply download it

742
00:38:27.976 --> 00:38:30.176
and then the user's
content is available

743
00:38:30.336 --> 00:38:31.296
in that particular app.

744
00:38:32.666 --> 00:38:34.506
Note also that with iOS 7,

745
00:38:34.606 --> 00:38:38.196
fonts can be installed
by managed profiles.

746
00:38:38.506 --> 00:38:40.016
This could be great if you're

747
00:38:40.016 --> 00:38:42.546
in an enterprise
distribution scenario

748
00:38:42.546 --> 00:38:45.176
and you have multiple
apps that you want

749
00:38:45.176 --> 00:38:46.646
to conform to a house style.

750
00:38:48.096 --> 00:38:51.046
And so, those fonts can be
included in the profiles

751
00:38:51.166 --> 00:38:53.056
and activated in that way.

752
00:38:54.196 --> 00:38:57.626
Note however that this is
the first time in which fonts

753
00:38:57.626 --> 00:39:00.976
on iOS can change while
your app is running.

754
00:38:57.626 --> 00:39:00.976
on iOS can change while
your app is running.

755
00:39:01.436 --> 00:39:03.556
And so, if you'd like to react

756
00:39:03.556 --> 00:39:05.666
to fonts becoming
available via a profile,

757
00:39:06.316 --> 00:39:07.356
you'll want to subscribe

758
00:39:07.386 --> 00:39:10.136
to the registered fonts
changed notification

759
00:39:10.696 --> 00:39:12.786
so that you can react
when that happens.

760
00:39:13.746 --> 00:39:16.866
So, as I've been talking,
we've been focusing

761
00:39:16.866 --> 00:39:17.816
on Unicode text layout.

762
00:39:18.226 --> 00:39:20.836
And Unicode is really
an amazing specification

763
00:39:20.836 --> 00:39:24.136
because it allows us to
communicate using nearly any

764
00:39:24.136 --> 00:39:27.596
of the world's languages on a
computer which is no small task.

765
00:39:28.106 --> 00:39:33.456
But one of the sort of
problems with Unicode is for --

766
00:39:33.596 --> 00:39:36.796
in certain situations, the
characters themselves --

767
00:39:37.306 --> 00:39:38.756
we know that they can take

768
00:39:38.756 --> 00:39:40.686
on different appearances
via the font

769
00:39:41.136 --> 00:39:45.546
but there're also situations in
which the appropriate appearance

770
00:39:45.546 --> 00:39:47.906
of that character is
dictated by the language.

771
00:39:48.306 --> 00:39:52.366
That is its information that the
user has that isn't reflected

772
00:39:52.366 --> 00:39:54.866
in the text, can't be.

773
00:39:54.866 --> 00:40:00.066
And so, the system by default
does the very best job it can

774
00:39:54.866 --> 00:40:00.066
And so, the system by default
does the very best job it can

775
00:40:00.066 --> 00:40:01.976
in resolving these scenarios.

776
00:40:02.596 --> 00:40:04.186
Typically, it does
solve by looking

777
00:40:04.186 --> 00:40:06.346
at the user's preferred
language.

778
00:40:06.806 --> 00:40:10.716
So, if the user is using
her phone in Japanese,

779
00:40:10.976 --> 00:40:12.346
in the text appearing
in Japanese,

780
00:40:12.826 --> 00:40:16.166
the system will select
appropriate Japanese behaviors

781
00:40:16.166 --> 00:40:16.456
for text.

782
00:40:17.236 --> 00:40:21.246
But there are cases in which you
or your content may know more

783
00:40:21.246 --> 00:40:25.296
about what the appropriate
language is and the mechanism

784
00:40:25.296 --> 00:40:27.886
for doing that is
by language tagging.

785
00:40:28.286 --> 00:40:31.086
So, there's -- on
Mavericks and iOS 7,

786
00:40:31.086 --> 00:40:33.586
there's a new string
attribute that allows you

787
00:40:33.586 --> 00:40:37.156
to specify the language
as an ISO language tag.

788
00:40:37.156 --> 00:40:40.386
And the presence of this
attribute indicates that,

789
00:40:40.666 --> 00:40:43.916
that particular language
should be used

790
00:40:43.916 --> 00:40:48.646
to override the default system
behavior in various ways.

791
00:40:49.306 --> 00:40:51.376
You're going to be looking
at glyph substitution,

792
00:40:51.376 --> 00:40:52.816
line breaking, and
font fallbacks.

793
00:40:54.156 --> 00:40:58.186
So the first example is
one that's kind of --

794
00:40:58.186 --> 00:41:00.036
may not be a particularly useful

795
00:40:58.186 --> 00:41:00.036
may not be a particularly useful

796
00:41:00.036 --> 00:41:01.886
because this relies
on a particular font.

797
00:41:02.586 --> 00:41:05.136
But this is another example
of how fonts can participate

798
00:41:05.136 --> 00:41:06.906
in the layout process.

799
00:41:07.156 --> 00:41:11.816
In this case, I'm going to be
displaying a particular string

800
00:41:11.816 --> 00:41:15.566
with two very specific Unicode
characters and I'm going

801
00:41:15.566 --> 00:41:17.986
to be showing you the appearance
of that string when laid

802
00:41:17.986 --> 00:41:21.086
out using one of two
different languages

803
00:41:21.196 --> 00:41:22.376
that I've tagged
the string with.

804
00:41:23.296 --> 00:41:25.616
In the case where I specified
English as the language,

805
00:41:25.746 --> 00:41:28.886
we'll get, for these characters,
their default appearance

806
00:41:28.886 --> 00:41:32.676
which you can see kind of looks
like a little hook or tail

807
00:41:32.676 --> 00:41:36.426
on the bottom of each of
these, the S and the T.

808
00:41:36.676 --> 00:41:38.686
But what's interesting
about these characters is

809
00:41:38.686 --> 00:41:44.146
that when use for Romanian
text, they actually take

810
00:41:44.146 --> 00:41:45.036
on a different appearance.

811
00:41:45.586 --> 00:41:48.656
In this font, Verdana, actually
implements that appearance.

812
00:41:49.286 --> 00:41:52.006
And so if I specified that
language as being Romanian,

813
00:41:52.486 --> 00:41:55.346
you'll see that rather than
having a little hook or tail

814
00:41:55.346 --> 00:41:58.266
on each of those glyphs,
we have what looks more

815
00:41:58.266 --> 00:41:59.556
like a comma or a stroke.

816
00:41:59.556 --> 00:42:06.036
And this is great as a
feature because it allows fonts

817
00:41:59.556 --> 00:42:06.036
And this is great as a
feature because it allows fonts

818
00:42:06.446 --> 00:42:10.876
to be more responsive
to the user's languages.

819
00:42:11.746 --> 00:42:15.766
Another way in which language
tagging can affect the behavior

820
00:42:15.866 --> 00:42:18.076
of text is in line breaking.

821
00:42:18.536 --> 00:42:21.616
So here we have an example
where I have a Japanese string.

822
00:42:22.256 --> 00:42:27.596
You'll note that I've asked to
lay this out in the space up to

823
00:42:27.596 --> 00:42:30.136
that dotted red line
on the right there.

824
00:42:30.136 --> 00:42:34.276
And you'll note that when
I'm doing so in the context

825
00:42:34.276 --> 00:42:37.766
of an English user, the line
break position is actually

826
00:42:37.766 --> 00:42:39.156
different than for Japanese.

827
00:42:39.886 --> 00:42:42.346
That's because in the
absence of any information

828
00:42:42.346 --> 00:42:45.556
about Japanese --
the Japanese text,

829
00:42:45.766 --> 00:42:49.546
the system uses the default
Unicode character properties

830
00:42:49.606 --> 00:42:52.336
which isn't really
appropriate for Japanese text.

831
00:42:52.876 --> 00:42:56.136
Now, again, as I mentioned
earlier, if the user is running

832
00:42:56.516 --> 00:42:58.106
with Japanese as their
primary language,

833
00:42:58.106 --> 00:43:00.526
they'll get the correct
behavior by defaults

834
00:42:58.106 --> 00:43:00.526
they'll get the correct
behavior by defaults

835
00:43:00.996 --> 00:43:03.726
but you may be writing
an app in which you know

836
00:43:03.726 --> 00:43:06.676
that text should always have --

837
00:43:06.676 --> 00:43:08.586
should always be
treated as Japanese text.

838
00:43:08.886 --> 00:43:10.866
Maybe you're writing
a dictionary app

839
00:43:11.276 --> 00:43:15.436
or maybe the content is
being specified using HTML

840
00:43:15.436 --> 00:43:16.976
and tagged as Japanese.

841
00:43:17.436 --> 00:43:20.276
And so in these cases, the
system can adapt accordingly.

842
00:43:20.276 --> 00:43:25.626
And one of the most common
examples when dealing

843
00:43:25.686 --> 00:43:30.306
with this quirk of Unicode
is for languages like Chinese

844
00:43:30.306 --> 00:43:31.926
and Japanese where many

845
00:43:31.926 --> 00:43:34.826
of the characters actually
overlap in Unicode.

846
00:43:34.976 --> 00:43:38.566
They can have the same character
but different appearances.

847
00:43:39.416 --> 00:43:43.006
In this particular example, we
have a very obvious difference

848
00:43:43.146 --> 00:43:48.906
of appearance when we're dealing
with either Japanese or Chinese

849
00:43:49.126 --> 00:43:50.826
as the language for this
particular character.

850
00:43:51.456 --> 00:43:55.076
So in this case, what the
system actually does is --

851
00:43:55.076 --> 00:43:58.386
note that I haven't specified
a font on my attributed string

852
00:43:58.386 --> 00:44:01.796
and so this is going to
immediately trigger fallback

853
00:43:58.386 --> 00:44:01.796
and so this is going to
immediately trigger fallback

854
00:44:01.796 --> 00:44:03.336
which is the process
of finding a font

855
00:44:03.826 --> 00:44:06.066
that can actually
render that character.

856
00:44:06.616 --> 00:44:09.356
And by specifying the
language attribute,

857
00:44:09.596 --> 00:44:11.646
I've told the system
exactly what it needs to know

858
00:44:11.676 --> 00:44:12.826
to make the right choice,

859
00:44:12.826 --> 00:44:15.996
not just a good choice
but the right choice.

860
00:44:16.636 --> 00:44:20.166
And in this case, it's going
to select one font for Japanese

861
00:44:21.206 --> 00:44:23.586
and a different font
completely for Chinese.

862
00:44:24.366 --> 00:44:27.146
So beside the appearance
of just this one character

863
00:44:27.146 --> 00:44:30.926
in a real world situation,
the user would notice

864
00:44:31.226 --> 00:44:34.126
that there're other
stylistic differences

865
00:44:34.126 --> 00:44:37.486
or even other glyph differences
between those two fonts

866
00:44:37.486 --> 00:44:38.836
and so this can be
done automatically.

867
00:44:39.296 --> 00:44:42.786
So on that note, I'd like to
talk about one other technique

868
00:44:42.856 --> 00:44:46.576
for changing the behavior
of fallbacks and that's

869
00:44:46.626 --> 00:44:48.766
by making use of a
custom cascade list.

870
00:44:49.386 --> 00:44:52.386
We've seen how an
app can tag a string

871
00:44:52.456 --> 00:44:55.666
with the appropriate language to
get language specific behavior

872
00:44:56.236 --> 00:45:00.516
but there are other cases beyond
just that when we might want

873
00:44:56.236 --> 00:45:00.516
but there are other cases beyond
just that when we might want

874
00:45:00.516 --> 00:45:02.546
to make a change to
the fallback behavior.

875
00:45:03.076 --> 00:45:07.316
The cascade list attribute is
a font descriptor attribute

876
00:45:07.356 --> 00:45:11.036
that you can add that allows
you to specify an array

877
00:45:11.036 --> 00:45:16.006
of font descriptors that will
be used before the default list

878
00:45:17.426 --> 00:45:18.326
when performing fallbacks.

879
00:45:18.676 --> 00:45:19.466
So, what does that mean?

880
00:45:19.906 --> 00:45:21.266
Well -- so remember, I mentioned

881
00:45:21.266 --> 00:45:24.116
that the system has
a default behavior

882
00:45:24.116 --> 00:45:26.916
that works as best it can.

883
00:45:27.676 --> 00:45:30.836
But in this case, you have
the flexibility and the power

884
00:45:30.866 --> 00:45:34.246
to insert something that's going
to be checked before that list.

885
00:45:34.376 --> 00:45:37.306
So let's take a look an
example to try to clarify this.

886
00:45:38.026 --> 00:45:40.846
So let's say I'm marking
on an Arabic dictionary app

887
00:45:41.686 --> 00:45:46.816
and I have a -- I've specified
a really great font in my design

888
00:45:46.946 --> 00:45:52.176
for the English headwords but
the behavior I'm seeing is

889
00:45:52.236 --> 00:45:56.666
that when the text system
encounters the Arabic characters

890
00:45:57.206 --> 00:46:00.786
in that string, they're
falling back --

891
00:45:57.206 --> 00:46:00.786
in that string, they're
falling back --

892
00:46:00.786 --> 00:46:02.066
the fallback font
that's selected

893
00:46:02.066 --> 00:46:04.366
to render those characters
is Geeza Pro.

894
00:46:05.606 --> 00:46:07.606
Now, some people will call
Geeza Pro time tested.

895
00:46:08.216 --> 00:46:09.606
Others would call it
long in the tooth.

896
00:46:10.346 --> 00:46:14.706
But more importantly, I think
what's important to note here is

897
00:46:14.746 --> 00:46:17.736
that Arabic is a writing system

898
00:46:17.736 --> 00:46:20.626
with a very rich
calligraphic history

899
00:46:20.966 --> 00:46:23.626
and so there are a
number of different styles

900
00:46:23.626 --> 00:46:26.466
in which I could expect
this text to appear

901
00:46:26.966 --> 00:46:29.576
and Geeza Pro is just
obviously one style.

902
00:46:31.076 --> 00:46:33.166
So what I've done is I've
licensed a really beautiful

903
00:46:33.336 --> 00:46:35.516
Arabic font for use in
my dictionary and I'd

904
00:46:35.516 --> 00:46:38.576
like the system to
manage the transition

905
00:46:38.576 --> 00:46:39.906
between those fonts
automatically.

906
00:46:40.816 --> 00:46:42.526
And so what I'd like instead is

907
00:46:42.526 --> 00:46:45.496
when I specified my original
font from my headwords,

908
00:46:46.066 --> 00:46:48.626
I'd like to let the system
take care of the fallback

909
00:46:49.026 --> 00:46:53.206
by overriding the default
behavior, not going to Geeza Pro

910
00:46:53.476 --> 00:46:54.846
and selecting my font instead.

911
00:46:55.696 --> 00:46:58.146
So in order to do
that, I'm going to want

912
00:46:58.146 --> 00:46:59.646
to specify my own cascade list.

913
00:47:00.616 --> 00:47:01.626
So I've got a font descriptor.

914
00:47:01.626 --> 00:47:03.776
We'll, assuming that I've
constructed font descriptor

915
00:47:04.016 --> 00:47:08.366
for my licensed Arabic
font and then I'm going

916
00:47:08.366 --> 00:47:12.276
to build a cascade list which is
pretty simple using Objective-C

917
00:47:12.276 --> 00:47:14.126
literal syntax, I'm just
going to have an array

918
00:47:14.126 --> 00:47:16.196
with this single
object and that's going

919
00:47:16.196 --> 00:47:17.136
to be that descriptor.

920
00:47:18.136 --> 00:47:21.366
I'll assume that I have my
font for my English text.

921
00:47:22.566 --> 00:47:23.846
Again, like we've seen before,

922
00:47:23.846 --> 00:47:26.766
I'm going to get the original
descriptor and I'm going

923
00:47:26.766 --> 00:47:27.726
to create a new descriptor

924
00:47:27.726 --> 00:47:31.566
by adding my cascade list
attribute to that descriptor.

925
00:47:32.186 --> 00:47:35.026
Now, whenever I make use
of the font that I can make

926
00:47:35.256 --> 00:47:37.406
from that descriptor,
what will happen is --

927
00:47:37.676 --> 00:47:42.076
I know that this font doesn't
support Arabic characters.

928
00:47:42.116 --> 00:47:44.466
And so whenever the string
contains those characters,

929
00:47:44.466 --> 00:47:46.336
the system is going to need
to consult the fallback

930
00:47:46.566 --> 00:47:48.546
to find an appropriate
font to render that.

931
00:47:49.256 --> 00:47:50.686
And so, this cascade list --

932
00:47:51.316 --> 00:47:55.436
since I know this covers Arabic
characters, it'll be used rather

933
00:47:55.436 --> 00:47:57.566
than the default fallback
which is Geeza Pro.

934
00:47:58.796 --> 00:48:04.166
So, you may note also that this
particular example could be

935
00:47:58.796 --> 00:48:04.166
So, you may note also that this
particular example could be

936
00:48:04.166 --> 00:48:07.396
quite powerful when combined
with a previous example

937
00:48:07.396 --> 00:48:08.636
of modifying the character set.

938
00:48:09.236 --> 00:48:12.756
And so they're depending
on the needs of your app.

939
00:48:12.756 --> 00:48:16.236
You may even be able to
combine the various techniques

940
00:48:16.266 --> 00:48:18.616
that I've shown you for
a very precise control

941
00:48:18.696 --> 00:48:19.756
of the fallback behavior.

942
00:48:21.016 --> 00:48:25.036
For more information, there
are various resources available

943
00:48:25.036 --> 00:48:25.356
to you.

944
00:48:25.356 --> 00:48:28.606
There are a couple of
sessions that are available

945
00:48:28.606 --> 00:48:32.156
on instant replay to you and I
encourage you to review those

946
00:48:32.186 --> 00:48:36.216
because there're some really
fascinating concepts in there

947
00:48:36.626 --> 00:48:39.916
as well as several of
the design sessions

948
00:48:39.956 --> 00:48:43.286
on designing your user
interface for iOS 7

949
00:48:43.726 --> 00:48:46.016
because that will give you I
think some really great ideas

950
00:48:46.076 --> 00:48:47.526
for adapting text
style in your apps.

951
00:48:47.986 --> 00:48:49.656
And I, as a user,
I'm really excited

952
00:48:49.656 --> 00:48:52.336
to see what you guys
can come up with.

953
00:48:52.526 --> 00:48:55.176
In summary, I just like
to drive home a couple

954
00:48:55.176 --> 00:48:56.166
of points one more time.

955
00:48:56.456 --> 00:49:00.756
The first is to -- in
order to adapt dynamic type

956
00:48:56.456 --> 00:49:00.756
The first is to -- in
order to adapt dynamic type

957
00:49:01.006 --> 00:49:04.676
in your iOS 7 app, you'll
do so using text styles.

958
00:49:04.676 --> 00:49:08.456
Remember that this is -- this
requires a bit of flexibility

959
00:49:08.456 --> 00:49:11.446
on your part in order
to adapt appropriately

960
00:49:11.446 --> 00:49:14.286
to the user's desired
content size.

961
00:49:14.786 --> 00:49:18.836
So please investigate using
auto layout but keep in mind

962
00:49:18.836 --> 00:49:20.596
that those font metrics
are going

963
00:49:20.596 --> 00:49:22.146
to change based on
user preference.

964
00:49:22.656 --> 00:49:25.906
For developers in
multilingual situations,

965
00:49:26.406 --> 00:49:30.616
language tagging is a great
feature that allows you

966
00:49:30.616 --> 00:49:33.746
to specify language
sensitive behavior.

967
00:49:34.506 --> 00:49:37.336
And what's really great
about it is that --

968
00:49:37.886 --> 00:49:41.466
in those examples I showed you,
that attribute will flow right

969
00:49:41.466 --> 00:49:43.726
up to your Text Kit and
you'll get perfect behavior.

970
00:49:43.986 --> 00:49:46.556
For various specific
needs involving fallbacks,

971
00:49:46.556 --> 00:49:49.646
you can influence the
systems fallback behavior

972
00:49:49.646 --> 00:49:51.246
by adding a cascade descriptor.

973
00:49:51.646 --> 00:49:54.976
Remember also that
profiles can install fonts

974
00:49:55.026 --> 00:49:57.666
and so this is a new tool
available to you as well

975
00:49:58.056 --> 00:50:00.136
and those fonts are
available systemwide.

976
00:49:58.056 --> 00:50:00.136
and those fonts are
available systemwide.

977
00:50:01.496 --> 00:50:05.006
So with that, I'd like to say
thank you very much for coming

978
00:50:05.006 --> 00:50:08.036
to hear about fonts and Text
Kit and a little bit of OS X.

979
00:50:08.036 --> 00:50:09.286
Thank you very much.

980
00:50:09.286 --> 00:50:09.976
Enjoy the rest of
the conference.

981
00:50:10.516 --> 00:50:12.780
[ Applause ]
