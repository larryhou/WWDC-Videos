
1
00:00:00.506 --> 00:00:09.516
[ Silence ]

2
00:00:10.016 --> 00:00:14.000
[ Applause ]

3
00:00:15.326 --> 00:00:16.076
>> Good afternoon.

4
00:00:17.186 --> 00:00:20.116
My name is Doug Gregor and I'm
here today to talk today to you

5
00:00:20.276 --> 00:00:22.196
about Advances in Objective-C.

6
00:00:23.786 --> 00:00:27.906
Objective-C is a great language
with the vibrant user community.

7
00:00:28.846 --> 00:00:31.776
If you're here last year,
you saw that we are really,

8
00:00:31.836 --> 00:00:33.966
really excited that
we could see this here

9
00:00:33.966 --> 00:00:35.876
in the TIOBE Programming
Community Index.

10
00:00:35.876 --> 00:00:38.096
This is from May 2012.

11
00:00:38.806 --> 00:00:40.916
And we see that Objective-C
had moved all the way

12
00:00:40.916 --> 00:00:42.526
up to fourth place
in the rankings.

13
00:00:42.856 --> 00:00:43.796
Just pretty amazing.

14
00:00:44.666 --> 00:00:47.946
Well in just the last
year, Objective-C has moved

15
00:00:47.946 --> 00:00:51.376
up even further displacing
the vulnerable C++

16
00:00:51.376 --> 00:00:52.846
for the number three spot.

17
00:00:52.846 --> 00:00:53.586
Whoo!

18
00:00:54.516 --> 00:00:59.306
[ Applause ]

19
00:00:59.806 --> 00:01:01.526
So how do we evolve
the Objective-C?

20
00:00:59.806 --> 00:01:01.526
So how do we evolve
the Objective-C?

21
00:01:01.886 --> 00:01:04.296
Well, there are some
things that we focus on.

22
00:01:04.676 --> 00:01:07.486
The two things in general that
we really do want to focus

23
00:01:07.486 --> 00:01:10.016
on are developer
productivity, that's your time,

24
00:01:10.686 --> 00:01:13.336
and software quality,
that's the quality that goes

25
00:01:13.336 --> 00:01:14.506
into your applications.

26
00:01:14.976 --> 00:01:17.336
And we can improve
both of these things

27
00:01:17.946 --> 00:01:20.506
through evolving the language
and the tools that support it.

28
00:01:21.626 --> 00:01:25.026
So in the realm of developer
productivity, we can do things

29
00:01:25.026 --> 00:01:27.316
like find places where
there's boilerplate,

30
00:01:27.316 --> 00:01:30.256
you're writing the same thing
over and over and over again,

31
00:01:30.256 --> 00:01:33.546
at synthesize, at synthesize,
at synthesize, and eliminate

32
00:01:33.546 --> 00:01:36.276
that from the language by
getting the right defaults.

33
00:01:36.676 --> 00:01:39.806
Second, we can find other
operations that you do day in

34
00:01:39.806 --> 00:01:42.316
and day out throughout many,
many different code bases

35
00:01:42.536 --> 00:01:45.036
and simplify them, bring the
syntax into the language,

36
00:01:45.036 --> 00:01:49.746
make them easier to use, faster
to write, faster to read.

37
00:01:49.746 --> 00:01:52.146
And finally, we can
provide great tools

38
00:01:52.196 --> 00:01:55.336
because you use tools to
write codes in Objective-C.

39
00:01:55.696 --> 00:01:59.186
And part of this is developing
the tools themselves and part

40
00:01:59.186 --> 00:02:02.186
of this is making sure that
the language itself is amenable

41
00:01:59.186 --> 00:02:02.186
of this is making sure that
the language itself is amenable

42
00:02:02.186 --> 00:02:03.326
to building great tools.

43
00:02:03.326 --> 00:02:06.246
We'll actually get back to that
with our first major feature.

44
00:02:07.456 --> 00:02:09.556
The other area is
software quality

45
00:02:09.556 --> 00:02:12.026
and how can we help there
through the language.

46
00:02:12.856 --> 00:02:13.756
So, couple of areas.

47
00:02:13.846 --> 00:02:16.246
We can try to catch
more bugs earlier.

48
00:02:16.686 --> 00:02:20.646
You can do this through stronger
and better static type safety

49
00:02:21.056 --> 00:02:23.476
so the compiler can reason
about the type in your program

50
00:02:23.476 --> 00:02:25.946
and warn when something
is going wrong.

51
00:02:26.166 --> 00:02:30.086
Next, we can find error
prone tasks, for example,

52
00:02:30.086 --> 00:02:33.576
writing retain and release
everywhere, automate those away

53
00:02:33.576 --> 00:02:36.736
within the compiler to eliminate
huge classes of problems.

54
00:02:38.056 --> 00:02:40.916
And finally, Objective-C is a
language with a rich history.

55
00:02:40.916 --> 00:02:42.666
We have a large developer
community

56
00:02:42.666 --> 00:02:45.316
that has established
best practices for how

57
00:02:45.316 --> 00:02:46.866
to use this language well.

58
00:02:46.866 --> 00:02:49.366
And we can bring those
into the language

59
00:02:49.366 --> 00:02:50.926
to help you build
better software.

60
00:02:52.376 --> 00:02:54.836
Today, we're going to talk
about a couple of things.

61
00:02:55.246 --> 00:02:57.176
We're going to talk about a new
Objective-C language feature

62
00:02:57.336 --> 00:02:58.426
called Modules.

63
00:02:58.426 --> 00:03:01.666
We're also going to talk
about better productivity

64
00:02:58.426 --> 00:03:01.666
We're also going to talk
about better productivity

65
00:03:01.786 --> 00:03:03.276
in the use of Objective-C.

66
00:03:03.626 --> 00:03:05.106
And finally, some improvements

67
00:03:05.106 --> 00:03:10.176
to Automatic Reference
Counting or ARC.

68
00:03:10.446 --> 00:03:16.006
Modules. So, the idea behind
Modules is that if you look

69
00:03:16.006 --> 00:03:19.166
at applications built
for iOS and OS X,

70
00:03:19.246 --> 00:03:23.506
at the core of these
applications is the use of a ton

71
00:03:23.506 --> 00:03:25.436
of really great systems
frameworks.

72
00:03:26.246 --> 00:03:28.166
This is how you integrate
with services

73
00:03:28.236 --> 00:03:30.576
like iCloud or with Game Center.

74
00:03:30.966 --> 00:03:33.636
Maybe it's using
iAd to introduce ads

75
00:03:33.636 --> 00:03:36.716
into your application or
core location services

76
00:03:37.476 --> 00:03:39.866
so that you give your
user relevant content

77
00:03:39.916 --> 00:03:41.836
where they at right now.

78
00:03:42.876 --> 00:03:45.316
And so, this is sort of
the foundational layer

79
00:03:45.316 --> 00:03:48.736
on which you build all of the
magic of your applications.

80
00:03:49.326 --> 00:03:51.326
So we looked at the
process of how is it

81
00:03:51.326 --> 00:03:52.346
that you use a framework.

82
00:03:53.156 --> 00:03:54.986
Well, first, you go into Xcode.

83
00:03:54.986 --> 00:03:56.056
You go into your coding window.

84
00:03:56.746 --> 00:03:58.666
You write the #import for
the framework you want.

85
00:03:58.916 --> 00:04:01.176
In this case, we're going
to pull in iAd and use

86
00:03:58.916 --> 00:04:01.176
In this case, we're going
to pull in iAd and use

87
00:04:01.176 --> 00:04:02.696
that as our demonstration.

88
00:04:03.096 --> 00:04:05.466
And the name is really
important, so you see iAd twice

89
00:04:05.466 --> 00:04:09.906
when you import iAd/iAd.h.
That's fine.

90
00:04:09.906 --> 00:04:12.066
You start writing your
code to the iAd framework,

91
00:04:12.066 --> 00:04:13.916
use some tutorial
samples and so on.

92
00:04:14.196 --> 00:04:16.906
You hit Build and you get
the dreaded link error.

93
00:04:17.555 --> 00:04:20.636
If this is the first time you've
seen this, this is horrifying

94
00:04:20.636 --> 00:04:22.666
and you have to search to
see what actually went wrong.

95
00:04:23.056 --> 00:04:25.016
But of course seasoned
developers know.

96
00:04:25.296 --> 00:04:26.896
Fine, there's several
ways to fix this.

97
00:04:26.896 --> 00:04:28.926
You can go edit the project,

98
00:04:28.926 --> 00:04:32.056
just go over to the build
phases, just close the triangle,

99
00:04:32.126 --> 00:04:34.746
hit the Plus, go find
the framework again.

100
00:04:34.746 --> 00:04:37.196
We said iAd three times
now if you're counting.

101
00:04:37.796 --> 00:04:40.496
Hit Add and we can actually
build our application,

102
00:04:41.346 --> 00:04:42.786
not exactly wonderful.

103
00:04:43.456 --> 00:04:46.606
And both of these steps
are very disjointed.

104
00:04:46.636 --> 00:04:49.456
We have the #import which is
what you write in your code

105
00:04:49.456 --> 00:04:51.366
and then we have the
addition of the library

106
00:04:51.366 --> 00:04:53.216
which is something you
do in Xcode, elsewhere.

107
00:04:53.896 --> 00:04:56.416
And so, let's go back to
the #import side of things

108
00:04:56.816 --> 00:05:00.356
because #import is a
teeny tiny innovation

109
00:04:56.816 --> 00:05:00.356
because #import is a
teeny tiny innovation

110
00:05:00.666 --> 00:05:04.036
over the basic #include
that's been in C for three,

111
00:05:04.126 --> 00:05:06.136
four decades based
on the preprocessor.

112
00:05:06.766 --> 00:05:09.106
And so, we're going to look a
little bit at how the #import

113
00:05:09.106 --> 00:05:10.796
and #include actually work.

114
00:05:10.866 --> 00:05:14.176
So you have your application,
some .m file from it.

115
00:05:14.176 --> 00:05:18.306
And what it does is it
#imports iAd.h. Fine,

116
00:05:18.306 --> 00:05:19.056
what does that actually do?

117
00:05:19.056 --> 00:05:22.166
Well, it resolves iAd.h and
the compiler goes and hunts

118
00:05:22.166 --> 00:05:24.486
for the next thing
that iAd included

119
00:05:24.486 --> 00:05:26.076
and the next thing
that that included.

120
00:05:26.366 --> 00:05:29.066
Eventually, we get back to
UIKit and all of its headers

121
00:05:29.066 --> 00:05:30.506
and all the things
that that brings in.

122
00:05:30.506 --> 00:05:33.146
And so, really, the
dependency that you have

123
00:05:33.616 --> 00:05:36.386
from your data .m is
out to a whole bunch

124
00:05:36.386 --> 00:05:40.346
of different header
files within the SDK.

125
00:05:40.576 --> 00:05:44.236
How does this actually
work as the language model?

126
00:05:44.356 --> 00:05:47.146
Well, again, this is the C
model of the preprocessor.

127
00:05:47.146 --> 00:05:48.946
It's essentially
textual inclusion

128
00:05:49.246 --> 00:05:51.386
or a fancy form of
cut and paste.

129
00:05:51.956 --> 00:05:55.176
So, here we have, you know,
simple .m for an app delegate.

130
00:05:55.506 --> 00:05:57.776
It imports iAd.h.
What's that do?

131
00:05:58.376 --> 00:05:59.386
First thing compiler does,

132
00:05:59.386 --> 00:06:03.776
go find what is iAd/iAd.h
actually refers to and it comes

133
00:05:59.386 --> 00:06:03.776
go find what is iAd/iAd.h
actually refers to and it comes

134
00:06:03.776 --> 00:06:04.846
up with a file on disk.

135
00:06:05.626 --> 00:06:08.836
Fine, it copies that
file, preprocess it,

136
00:06:09.206 --> 00:06:15.496
and pastes the results
into our .m at the end.

137
00:06:15.546 --> 00:06:17.536
Okay. And then what do we have?

138
00:06:17.536 --> 00:06:18.356
More imports.

139
00:06:18.726 --> 00:06:20.886
So we go hunt for the next file.

140
00:06:21.056 --> 00:06:25.256
Take its text, copy it,
preprocess it, paste it in,

141
00:06:25.256 --> 00:06:27.266
and the .m gets as
little longer.

142
00:06:27.346 --> 00:06:30.646
And we go hunt for more files
and we copy and paste those in.

143
00:06:30.646 --> 00:06:33.976
And once you get at the
end is one big long .m

144
00:06:33.976 --> 00:06:36.746
which is what the
compiler actually sees

145
00:06:36.976 --> 00:06:38.696
for each .m file in
your application.

146
00:06:40.036 --> 00:06:42.016
This model has been
working for decades,

147
00:06:42.096 --> 00:06:44.316
so what's wrong with it?

148
00:06:44.316 --> 00:06:46.006
Well, it has two problems.

149
00:06:46.006 --> 00:06:47.226
The first problem
we're going to talk

150
00:06:47.226 --> 00:06:49.656
about is it's a very
fragile model.

151
00:06:49.656 --> 00:06:51.776
So I'm going to do
something here

152
00:06:51.776 --> 00:06:53.246
that may make a few
of you cringe.

153
00:06:53.606 --> 00:06:57.226
I'm going to define a
constant read-only to 0x01

154
00:06:57.226 --> 00:07:00.416
because that makes sense for
my .m, for my application code.

155
00:06:57.226 --> 00:07:00.416
because that makes sense for
my .m, for my application code.

156
00:07:00.466 --> 00:07:05.766
And I happen to do that
before #importing iAd.h. See,

157
00:07:05.766 --> 00:07:08.016
preprocessor does
what its design to do.

158
00:07:08.306 --> 00:07:10.856
It goes and hunts down
these files, copies them,

159
00:07:10.956 --> 00:07:13.126
preprocess them,
paste the result,

160
00:07:13.566 --> 00:07:15.566
and we end up with
this file up here

161
00:07:15.566 --> 00:07:17.846
which is the .m the
compiler sees.

162
00:07:18.886 --> 00:07:22.116
The compiler is not going to
like this .m and it's going

163
00:07:22.116 --> 00:07:25.456
to complain, 0x01 is not a
valid property attribute,

164
00:07:25.826 --> 00:07:26.896
it is very correct.

165
00:07:27.896 --> 00:07:31.056
The really unfortunate
thing here is that the error

166
00:07:31.056 --> 00:07:32.706
that you get is in
the system headers.

167
00:07:32.706 --> 00:07:34.826
That's not code you wrote and

168
00:07:34.826 --> 00:07:39.256
yet somehow you accidentally
broke it just by doing something

169
00:07:39.326 --> 00:07:41.546
where you defined the local
constant in your header file.

170
00:07:41.956 --> 00:07:43.946
And now, you can blame
me for doing this.

171
00:07:43.946 --> 00:07:45.656
I'm the one that write--
wrote this code in this slide.

172
00:07:45.786 --> 00:07:49.636
Clearly, it's my fault because
what I should have done is used

173
00:07:49.906 --> 00:07:54.186
a prefixed very long
uppercase name for my constant

174
00:07:54.216 --> 00:07:55.826
because that's what
we do with macros.

175
00:07:56.126 --> 00:07:57.976
It's the convention
that we've established

176
00:07:58.016 --> 00:08:00.836
within the C programming
world to cope

177
00:07:58.016 --> 00:08:00.836
within the C programming
world to cope

178
00:08:00.836 --> 00:08:02.886
with this fragility problem.

179
00:08:03.146 --> 00:08:05.286
And so, this doesn't
happen often

180
00:08:05.286 --> 00:08:06.436
that you hit these problems.

181
00:08:06.646 --> 00:08:09.036
But we do hit them
in programming.

182
00:08:09.036 --> 00:08:10.576
And usually, they
come in as some sort

183
00:08:10.576 --> 00:08:11.776
of header include-dependency.

184
00:08:12.216 --> 00:08:15.086
Someone's header over here
didn't follow the rules.

185
00:08:15.086 --> 00:08:16.056
He didn't get the memo.

186
00:08:16.396 --> 00:08:18.396
And it stomps on
another header over here.

187
00:08:18.396 --> 00:08:21.086
And if you include them in
one order, things work fine,

188
00:08:21.086 --> 00:08:23.756
or with one version of some
framework, it works fine.

189
00:08:24.206 --> 00:08:25.746
You migrate to another
version and, suddenly,

190
00:08:25.746 --> 00:08:27.646
there's a conflict
that you get to debug.

191
00:08:27.866 --> 00:08:30.566
If you're lucky, it manifests
an error that's fairly easy

192
00:08:30.566 --> 00:08:31.276
to track down.

193
00:08:31.996 --> 00:08:35.035
If you're not so lucky, it could
actually be a runtime that's

194
00:08:35.176 --> 00:08:37.356
really hard to track down
for something that ends

195
00:08:37.356 --> 00:08:39.096
up being just flipping
to include.

196
00:08:39.726 --> 00:08:43.676
So this is a problem that we
deal with but we've been working

197
00:08:43.746 --> 00:08:45.196
through it through
our conventions.

198
00:08:45.576 --> 00:08:46.156
It's fine.

199
00:08:47.076 --> 00:08:48.926
The real issue here, however,

200
00:08:48.926 --> 00:08:51.866
is that this whole model
is inherently not scalable.

201
00:08:52.436 --> 00:08:56.726
And so, to see this, we took
all of the .m files in iOS Mail

202
00:08:56.756 --> 00:08:59.176
and we plot them according
to their size on disk.

203
00:08:59.806 --> 00:09:02.386
So it's got, you know,
about 250 .ms here

204
00:08:59.806 --> 00:09:02.386
So it's got, you know,
about 250 .ms here

205
00:09:02.756 --> 00:09:05.246
and you can see they range
from half a kilobyte up to

206
00:09:05.246 --> 00:09:09.156
about 200 kilobytes in
size with a very large skew

207
00:09:09.186 --> 00:09:10.676
with really tiny files.

208
00:09:10.676 --> 00:09:13.446
And we see this across the
numerous projects that you tend

209
00:09:13.446 --> 00:09:15.806
to have many, many
small .m files.

210
00:09:17.096 --> 00:09:20.546
Now, we've added iAd.h,
an import of iAd.h

211
00:09:20.696 --> 00:09:23.136
into a fairly central header.

212
00:09:23.586 --> 00:09:25.606
So what that really means
is for all these .m files,

213
00:09:25.606 --> 00:09:27.476
we're not just parsing
what's in the .m file,

214
00:09:27.476 --> 00:09:30.356
we're also parsing
everything that's in iAd.

215
00:09:30.466 --> 00:09:34.196
iAd is a fairly small
framework and the headers come

216
00:09:34.196 --> 00:09:35.896
in about 25 kilobytes.

217
00:09:35.946 --> 00:09:39.546
So, for many of these
files, just the size

218
00:09:39.786 --> 00:09:42.786
of iAd works the size
of the actual code

219
00:09:42.786 --> 00:09:44.966
that you wrote in your .m file.

220
00:09:45.916 --> 00:09:47.476
Of course, iAd isn't standalone

221
00:09:47.476 --> 00:09:49.626
and everyone needs
UIKit everywhere

222
00:09:49.626 --> 00:09:52.236
and UIKit is more
like 400 kilobytes.

223
00:09:53.336 --> 00:09:56.456
Okay. So now, our tiny
little files which is most

224
00:09:56.456 --> 00:10:01.906
of what's here are actually
going through 425 kilobytes

225
00:09:56.456 --> 00:10:01.906
of what's here are actually
going through 425 kilobytes

226
00:10:01.906 --> 00:10:03.596
of header files pulling
all those

227
00:10:03.596 --> 00:10:07.276
in from disk parsing
them just to get

228
00:10:07.276 --> 00:10:09.266
at your tiny little bit of code.

229
00:10:10.306 --> 00:10:11.406
And if you think this is bad,

230
00:10:11.406 --> 00:10:14.136
this is iOS where UIKit
is actually fairly small.

231
00:10:14.436 --> 00:10:19.096
So, on OS X, the Cocoa framework
that you pull in everywhere,

232
00:10:19.096 --> 00:10:23.096
it's about 29 times
larger than UIKit.

233
00:10:23.226 --> 00:10:26.556
So you can't even see the
.m files, your own code

234
00:10:26.556 --> 00:10:27.796
in this kind of chart.

235
00:10:28.276 --> 00:10:32.356
So what this presents is
inherent scalability problem.

236
00:10:32.356 --> 00:10:34.166
You can't scale with
a system like this

237
00:10:34.216 --> 00:10:36.306
because you have
your M source files

238
00:10:36.456 --> 00:10:38.316
and you have the N headers.

239
00:10:39.476 --> 00:10:41.986
That's the storage
on disk, M plus N.

240
00:10:42.046 --> 00:10:44.526
But the time to compile
is M times N

241
00:10:44.526 --> 00:10:46.956
because you're reparsing
every one of those headers

242
00:10:46.956 --> 00:10:48.456
for all of your .m files.

243
00:10:48.566 --> 00:10:51.476
And of course, both
M and N are growing

244
00:10:51.836 --> 00:10:54.656
as you build your applications
and add more code to them

245
00:10:54.976 --> 00:10:59.936
and as the system adds more
frameworks and APIs to them.

246
00:11:00.126 --> 00:11:03.426
So clearly, it can't be this
horrible or I'll be screaming

247
00:11:03.426 --> 00:11:05.016
at us to fix the
compile time issue.

248
00:11:05.466 --> 00:11:08.686
And so, one of that features
that we've had for a long time

249
00:11:08.686 --> 00:11:11.306
to try to solve this
is precompiled headers.

250
00:11:12.206 --> 00:11:14.626
And so, precompiled headers
actually do help a lot.

251
00:11:14.676 --> 00:11:15.866
The idea is fairly simple.

252
00:11:16.226 --> 00:11:18.396
You take some subset of
headers that's common

253
00:11:18.396 --> 00:11:21.866
across your entire project,
like maybe all of UIKit.

254
00:11:21.866 --> 00:11:25.256
And you compile it once
into some efficient

255
00:11:25.446 --> 00:11:26.896
on disk representation.

256
00:11:27.726 --> 00:11:29.746
And then whenever
you build a .m file,

257
00:11:29.996 --> 00:11:31.706
you load that representation
first,

258
00:11:31.706 --> 00:11:33.376
that binary representation
that's fast,

259
00:11:33.676 --> 00:11:36.216
no parsing, and start
from there.

260
00:11:36.866 --> 00:11:38.556
Now, this is great
because you don't have

261
00:11:38.556 --> 00:11:40.906
to parse UIKit or Cocoa.

262
00:11:40.906 --> 00:11:43.706
And in fact, when you started
with your project with Xcode,

263
00:11:43.706 --> 00:11:46.206
you got a precompiled
header for UIKit or Cocoa

264
00:11:46.206 --> 00:11:47.326
for free as you started.

265
00:11:48.206 --> 00:11:51.136
But anything else that you've
added later on, when you add

266
00:11:51.136 --> 00:11:54.816
that #import of iAd.h
is still being parsed

267
00:11:54.816 --> 00:11:56.146
over and over again.

268
00:11:57.176 --> 00:11:59.106
You could fix this if
you really wanted to.

269
00:11:59.426 --> 00:12:01.626
You could extend your
precompiled header

270
00:11:59.426 --> 00:12:01.626
You could extend your
precompiled header

271
00:12:01.756 --> 00:12:04.416
to include iAd.h. And now,

272
00:12:04.416 --> 00:12:06.186
you're no longer
parsing this every time.

273
00:12:06.226 --> 00:12:08.406
What we've seen, however,

274
00:12:08.406 --> 00:12:11.216
is that developers don't
generally maintain their

275
00:12:11.266 --> 00:12:12.276
precompiled headers.

276
00:12:12.646 --> 00:12:14.686
A few people do and
they see more benefits

277
00:12:14.686 --> 00:12:15.866
out of precompiled headers.

278
00:12:16.236 --> 00:12:19.176
But most don't, partly because
they don't know about it,

279
00:12:19.176 --> 00:12:22.146
partly because they don't want
to be optimizing for our tools.

280
00:12:22.796 --> 00:12:26.666
But also, there's another
reason you might want to this

281
00:12:26.666 --> 00:12:29.196
and that's using
precompiled headers introduces

282
00:12:29.196 --> 00:12:30.116
namespace pollution.

283
00:12:30.646 --> 00:12:34.426
You may not want to have iAd in
every part of your application.

284
00:12:34.426 --> 00:12:36.726
It maybe fairly centralized
but putting it

285
00:12:36.726 --> 00:12:39.696
into your precompiled header
makes it available everywhere.

286
00:12:39.696 --> 00:12:40.796
So they're always showing

287
00:12:40.796 --> 00:12:42.866
up in code completion
results, for example.

288
00:12:43.156 --> 00:12:44.256
It's always available.

289
00:12:44.256 --> 00:12:46.486
And so, there's principle
reasons for not wanting

290
00:12:46.486 --> 00:12:47.856
to use precompiled
headers anywhere.

291
00:12:48.486 --> 00:12:52.416
So Modules are designed to
solve these two problems,

292
00:12:53.226 --> 00:12:55.636
the problem of the inherent
scalability problem of headers

293
00:12:55.636 --> 00:12:57.556
and also the fragility
problem of headers.

294
00:12:58.716 --> 00:13:00.156
So what are these Modules?

295
00:12:58.716 --> 00:13:00.156
So what are these Modules?

296
00:13:00.586 --> 00:13:02.986
So think of them
as an encapsulation

297
00:13:03.046 --> 00:13:04.896
of what a framework is.

298
00:13:05.206 --> 00:13:08.096
It's API and its
corresponding implementation.

299
00:13:09.096 --> 00:13:11.946
A Module is something that's
separately compiled all

300
00:13:11.946 --> 00:13:12.286
the time.

301
00:13:12.756 --> 00:13:17.646
So, it's compiled once and
set aside so that later

302
00:13:17.646 --> 00:13:19.816
on your application
can import that Module,

303
00:13:19.816 --> 00:13:22.816
get access to the API, get
access to the implementation

304
00:13:23.696 --> 00:13:25.726
without having the go
through and parse the headers.

305
00:13:26.936 --> 00:13:28.396
Now in support of Modules,

306
00:13:28.516 --> 00:13:30.656
we introduced one
little bit of syntax.

307
00:13:31.256 --> 00:13:32.936
It's the @import declaration.

308
00:13:33.906 --> 00:13:38.896
What @import does is it pulls in
the API for a particular Module

309
00:13:38.896 --> 00:13:40.046
which corresponds
to the framework.

310
00:13:40.276 --> 00:13:44.146
So here, we're importing
the iAd frameworks API

311
00:13:44.396 --> 00:13:45.396
into our application.

312
00:13:46.466 --> 00:13:48.896
Now this is what we
call a Semantic Import

313
00:13:48.896 --> 00:13:51.756
and it's very different from the
textual inclusion that you get

314
00:13:51.756 --> 00:13:54.216
with headers 'cause
semantic import, of course,

315
00:13:54.296 --> 00:13:55.726
it doesn't parse the headers

316
00:13:56.566 --> 00:13:59.916
but it also doesn't let
the API that's exposed

317
00:13:59.916 --> 00:14:03.616
by @import be changed by
any of your local context.

318
00:13:59.916 --> 00:14:03.616
by @import be changed by
any of your local context.

319
00:14:03.616 --> 00:14:06.556
So if I do this horrible
thing that I did earlier,

320
00:14:06.786 --> 00:14:10.826
# defining read-only to
0x01, it's perfectly fine.

321
00:14:10.936 --> 00:14:15.516
That doesn't change or break
the API of iAd in any way.

322
00:14:16.096 --> 00:14:20.346
The API you get out of the iAd
Module is exactly as the authors

323
00:14:20.406 --> 00:14:21.736
of iAd intended you to get.

324
00:14:21.826 --> 00:14:23.106
You can't make mistake here.

325
00:14:23.676 --> 00:14:29.186
Now, Modules can be thought
of as monolithic things,

326
00:14:29.186 --> 00:14:30.716
like we often think
of frameworks

327
00:14:30.716 --> 00:14:31.786
as a monolithic thing.

328
00:14:31.836 --> 00:14:35.966
I want to get all of the API of
iAd, but you don't have to think

329
00:14:35.966 --> 00:14:37.046
about frameworks this way.

330
00:14:37.046 --> 00:14:38.866
And therefore, you don't have
to think about Modules this way.

331
00:14:39.346 --> 00:14:43.196
And so, we can think of Modules
as being a larger structure,

332
00:14:43.196 --> 00:14:46.806
so here we have the iAd Module
and their smaller pieces

333
00:14:46.806 --> 00:14:48.026
which we call submodules.

334
00:14:48.176 --> 00:14:50.176
So here, we have the
ADInterstitialAd,

335
00:14:50.176 --> 00:14:57.256
the ADBannerView as submodules
within the iAd module itself.

336
00:14:57.556 --> 00:15:00.326
We can import just
part of a framework

337
00:14:57.556 --> 00:15:00.326
We can import just
part of a framework

338
00:15:00.636 --> 00:15:02.716
by writing @import of iAd.

339
00:15:02.716 --> 00:15:04.336
and then one of the
submodule names.

340
00:15:04.336 --> 00:15:05.746
In this case, it's ADBannerView.

341
00:15:05.746 --> 00:15:09.876
And what that does is it gives
us just the API corresponding

342
00:15:09.876 --> 00:15:11.736
to ADBannerView within iAd.

343
00:15:12.236 --> 00:15:14.326
So from an API perspective,

344
00:15:14.326 --> 00:15:17.916
this is giving you exactly the
same thing that you would get

345
00:15:17.916 --> 00:15:21.836
out of #import of
iAd/ADBannerView.h. And in fact,

346
00:15:21.836 --> 00:15:23.666
the frameworks and the sub--

347
00:15:23.666 --> 00:15:27.726
the framework headers and the
submodules match up exactly.

348
00:15:27.726 --> 00:15:30.036
It's something you can see if
you look at code completion

349
00:15:30.036 --> 00:15:32.416
for example after @import iAd.

350
00:15:33.286 --> 00:15:37.186
is the submodule structure here
to get at exactly what you want

351
00:15:37.186 --> 00:15:41.726
and this match up exactly what
the file names that are there.

352
00:15:41.726 --> 00:15:45.436
Now, once you've used @import,
you get the API of a framework.

353
00:15:46.246 --> 00:15:47.506
You also get the implementation

354
00:15:47.506 --> 00:15:49.266
for free via the
Autolinking feature.

355
00:15:50.156 --> 00:15:53.716
And so, once you've
switch over to Modules

356
00:15:53.896 --> 00:15:56.046
and you're importing
a particular Module,

357
00:15:56.046 --> 00:15:57.766
the compiler is just
going to record

358
00:15:57.766 --> 00:16:00.766
in the object files it
create what Modules you used

359
00:15:57.766 --> 00:16:00.766
in the object files it
create what Modules you used

360
00:16:01.036 --> 00:16:03.516
so that we'll automatically
link against these things

361
00:16:03.736 --> 00:16:05.856
and you never have
to go in-- thank you.

362
00:16:06.516 --> 00:16:10.476
[ Applause ]

363
00:16:10.976 --> 00:16:13.236
Right. So you should not have
to go in and then link binary

364
00:16:13.236 --> 00:16:14.066
with libraries anymore.

365
00:16:14.576 --> 00:16:16.556
So what does it takes
to use Modules?

366
00:16:16.556 --> 00:16:19.276
We've shown the new
syntax, the @import syntax.

367
00:16:20.296 --> 00:16:22.416
So Modules are an
opting feature.

368
00:16:23.536 --> 00:16:25.786
So you can opt in via
build setting and I'll show

369
00:16:25.786 --> 00:16:27.366
in just a few moments.

370
00:16:28.476 --> 00:16:31.146
And of course, once you've
opted in, you have access

371
00:16:31.146 --> 00:16:32.526
to the @import syntax.

372
00:16:32.526 --> 00:16:37.206
Now, you probably have
a couple of #imports

373
00:16:37.206 --> 00:16:38.936
and maybe some #includes
in your code,

374
00:16:38.936 --> 00:16:41.316
maybe a handful,
hundreds, thousands.

375
00:16:42.166 --> 00:16:44.236
We don't actually want you to
have to go and rewrite those,

376
00:16:44.516 --> 00:16:46.376
not even automatically.

377
00:16:46.376 --> 00:16:47.466
Of course, we could
migrate them.

378
00:16:47.466 --> 00:16:50.106
What we really want is you
to be able to turn on Modules

379
00:16:50.106 --> 00:16:51.866
and go use the feature
immediately.

380
00:16:52.216 --> 00:16:52.976
And so, the way we deal

381
00:16:52.976 --> 00:16:55.506
with this is we actually
automatically remapped the

382
00:16:55.686 --> 00:16:57.986
#includes and the #includes
in your source code.

383
00:16:58.426 --> 00:17:00.566
When those refer to a
header that we know is part

384
00:16:58.426 --> 00:17:00.566
When those refer to a
header that we know is part

385
00:17:00.566 --> 00:17:02.216
of a Module, we just treat it

386
00:17:02.216 --> 00:17:05.066
as if you had written
@import all along.

387
00:17:05.195 --> 00:17:07.136
And the great thing
here is you don't have

388
00:17:07.205 --> 00:17:09.556
to change your source
code to use Modules.

389
00:17:09.715 --> 00:17:12.066
You just need to opt in
via the build settings.

390
00:17:12.756 --> 00:17:16.076
The Modules, the @import
provides the exact same API

391
00:17:16.076 --> 00:17:19.596
that you got before just
through a different mechanism

392
00:17:19.596 --> 00:17:21.945
that is safer and
more efficient.

393
00:17:23.376 --> 00:17:26.685
Now, all of the system
frameworks in iOS 7

394
00:17:26.685 --> 00:17:30.496
and OS X Mavericks are
available as Modules.

395
00:17:31.226 --> 00:17:34.546
And so, when you opt in to
Modules, anything you're using

396
00:17:34.546 --> 00:17:37.176
from the system, any of those
system frameworks automatically

397
00:17:37.176 --> 00:17:41.196
goes through this more
efficient, safer path.

398
00:17:41.376 --> 00:17:43.196
You may be wondering, how
does this actually work

399
00:17:43.196 --> 00:17:43.746
under the hood?

400
00:17:43.746 --> 00:17:45.286
Well, let's take a quick look.

401
00:17:45.576 --> 00:17:51.926
So, the basic idea is we have
this notion of Module Maps.

402
00:17:52.086 --> 00:17:56.936
And a Module Map establishes a
relationship between the headers

403
00:17:57.026 --> 00:17:59.876
that are part of the framework
and have always been there,

404
00:18:00.326 --> 00:18:02.886
and the actual logical
Module structure.

405
00:18:03.166 --> 00:18:04.826
So here's a fragment
of a Module Map.

406
00:18:05.366 --> 00:18:08.586
It defines the UIKit Module
based on the UIKit framework.

407
00:18:09.586 --> 00:18:13.186
It says that to actually get
the contents of the UIKit model,

408
00:18:13.186 --> 00:18:15.276
you parse the umbrella
header UIKit.h

409
00:18:15.546 --> 00:18:18.036
which UIKit.h is what
you generally import.

410
00:18:18.036 --> 00:18:19.736
So this is the same
API description.

411
00:18:20.406 --> 00:18:25.446
And that anything that UIKit.h
itself imports becomes a

412
00:18:25.446 --> 00:18:26.966
submodule within UIKit.

413
00:18:26.966 --> 00:18:29.286
This is what reflects
the header structure

414
00:18:29.866 --> 00:18:31.726
within the logical
Module structure.

415
00:18:33.046 --> 00:18:34.966
And finally, you can
see Autolinking here

416
00:18:34.966 --> 00:18:37.736
through the link framework
line here that says

417
00:18:37.806 --> 00:18:40.526
when you actually use the
UIKit Module, you should link

418
00:18:40.526 --> 00:18:41.816
against the UIKit framework.

419
00:18:42.996 --> 00:18:45.056
Now, these Module Maps
are actually very crucial

420
00:18:45.446 --> 00:18:48.836
because in our SDKs, we
don't ship Module binaries.

421
00:18:49.246 --> 00:18:51.766
Instead, we ship headers
like we always have.

422
00:18:51.766 --> 00:18:55.286
And when the compiler asks
for a Module, when you ask

423
00:18:55.286 --> 00:19:00.016
to @import UIKit, the compiler
will find the Module Map,

424
00:18:55.286 --> 00:19:00.016
to @import UIKit, the compiler
will find the Module Map,

425
00:19:00.016 --> 00:19:01.486
it tells it how to build UIKit

426
00:19:01.486 --> 00:19:04.506
and effectively spawn a
separate compilation process

427
00:19:04.506 --> 00:19:08.896
to go separately compile
UIkit.h into the UIKit Module

428
00:19:09.206 --> 00:19:11.736
which is then cached in
Xcode's derived data.

429
00:19:12.216 --> 00:19:15.486
So the next time you come
through and ask to import UIKit,

430
00:19:15.676 --> 00:19:17.956
it's already there and
it's instantaneous to load.

431
00:19:18.336 --> 00:19:22.366
So this is what breaks the M
times N scalability problem

432
00:19:22.366 --> 00:19:24.416
down to actually
efficient compilation model.

433
00:19:24.416 --> 00:19:27.626
So let's take a quick look at
what this does to build times?

434
00:19:28.126 --> 00:19:31.016
So build times, of course, build
time for an entire project.

435
00:19:31.016 --> 00:19:32.666
And so, we'll talk about
a couple of projects

436
00:19:32.666 --> 00:19:35.896
at different scales and with
different levels of utilization

437
00:19:35.896 --> 00:19:37.476
of the precompiled
headers feature.

438
00:19:37.896 --> 00:19:41.046
So Xcode is a very, very
large Objective-C project,

439
00:19:41.306 --> 00:19:42.736
a lot going on in the build.

440
00:19:43.356 --> 00:19:45.806
And in fact, they've been
tuning their precompiled headers

441
00:19:45.806 --> 00:19:46.366
for years.

442
00:19:46.656 --> 00:19:48.436
And so, what we see when
we turn on Modules is

443
00:19:48.436 --> 00:19:50.706
that they don't have to change
their source code at all.

444
00:19:50.706 --> 00:19:51.706
It's just a build setting.

445
00:19:52.206 --> 00:19:53.706
And they get a smallish win,

446
00:19:53.706 --> 00:19:55.716
a couple of percent
win in the build time.

447
00:19:56.286 --> 00:19:58.336
Since they had optimized
precompiled headers,

448
00:19:58.336 --> 00:19:59.446
this isn't a huge surprise.

449
00:20:00.906 --> 00:20:05.816
Preview on the Mac is
actually a much smaller project

450
00:20:05.816 --> 00:20:06.606
as you might expect.

451
00:20:06.906 --> 00:20:11.046
Also, has fairly decent
precompiled header.

452
00:20:11.046 --> 00:20:14.006
And so, you get a small
win [inaudible] larger win

453
00:20:14.306 --> 00:20:15.366
out of using Modules.

454
00:20:15.366 --> 00:20:18.696
Again, no source code-- yeah--
source code changes required,

455
00:20:19.296 --> 00:20:21.176
so it's essentially a
free performance here.

456
00:20:21.876 --> 00:20:25.846
And finally, the Mail
Application on iOS didn't have

457
00:20:25.846 --> 00:20:26.606
such great use

458
00:20:26.606 --> 00:20:29.456
of the precompiled headers
'cause they hadn't been actively

459
00:20:29.456 --> 00:20:30.256
maintained, like most

460
00:20:30.256 --> 00:20:32.336
of all operators don't actively
maintained their precompiled

461
00:20:32.336 --> 00:20:35.786
headers and it's a huge
40 percent speed up just

462
00:20:35.786 --> 00:20:37.866
from flipping the
switch, turning on Modules

463
00:20:37.866 --> 00:20:40.036
and not doing anything
else, all right.

464
00:20:40.456 --> 00:20:41.656
This is the elimination

465
00:20:41.656 --> 00:20:44.256
of repeated header
processing really helping.

466
00:20:45.596 --> 00:20:48.456
So now, build times or
overall project build times,

467
00:20:48.716 --> 00:20:50.766
they're a little
bit messy in a sense

468
00:20:50.766 --> 00:20:52.336
that we're not really
just measuring what the

469
00:20:52.336 --> 00:20:52.926
compiler does.

470
00:20:52.926 --> 00:20:54.556
There's a whole lot of
other things going on.

471
00:20:55.216 --> 00:20:58.616
So, let's go to something
a little bit more heavy

472
00:20:58.616 --> 00:21:01.386
on the parsing and
that is indexing.

473
00:20:58.616 --> 00:21:01.386
on the parsing and
that is indexing.

474
00:21:01.386 --> 00:21:03.786
When an Xcode is
indexing your project,

475
00:21:03.786 --> 00:21:06.766
it's parsing all the sources
in your project so it can build

476
00:21:06.766 --> 00:21:09.906
that rich cross reference
to give you more information

477
00:21:09.906 --> 00:21:11.126
at your fingertips
within the IDE.

478
00:21:11.126 --> 00:21:15.636
And so if we take these
same projects, indexing time

479
00:21:15.636 --> 00:21:17.496
for Xcode got a bit faster,

480
00:21:17.496 --> 00:21:20.496
we're in the seven
percent range or so.

481
00:21:21.476 --> 00:21:24.716
Preview on the other hand got
pretty significantly faster,

482
00:21:24.716 --> 00:21:27.526
so 32 percent faster
indexing time just

483
00:21:27.526 --> 00:21:28.846
from switching to Modules.

484
00:21:29.986 --> 00:21:32.556
And iOS Mail, as you may have
seen earlier this morning,

485
00:21:32.866 --> 00:21:36.486
got 2.3 times faster
indexing just

486
00:21:36.486 --> 00:21:37.796
from doing the switch
to Modules.

487
00:21:40.016 --> 00:21:42.036
Hopefully, at this
point, I've convinced you,

488
00:21:42.036 --> 00:21:45.176
you should at least try out
Modules, fairly easy to do.

489
00:21:45.176 --> 00:21:47.696
So if you start a new
project in Xcode 5,

490
00:21:47.696 --> 00:21:49.316
Modules are enabled by default.

491
00:21:49.316 --> 00:21:52.106
We really thinking this is the
way forward for Objective-C

492
00:21:52.266 --> 00:21:54.536
to get access to
system frameworks.

493
00:21:54.786 --> 00:21:58.096
If you have an existing
project, to covert it Modules,

494
00:21:58.096 --> 00:22:01.186
just go into your Build Settings
and find the Module Setting,

495
00:21:58.096 --> 00:22:01.186
just go into your Build Settings
and find the Module Setting,

496
00:22:01.456 --> 00:22:02.996
change it to Yes
and then Rebuild.

497
00:22:02.996 --> 00:22:04.586
Nothing else is needed.

498
00:22:05.756 --> 00:22:08.426
Now, if you're doing some
fancy linking tricks,

499
00:22:09.106 --> 00:22:11.406
you may actually want to turn
off the Autolinking feature

500
00:22:11.956 --> 00:22:13.816
in which case there is
a separate option here

501
00:22:13.816 --> 00:22:16.046
where you can turn off
the Autolinking feature.

502
00:22:16.286 --> 00:22:20.076
Most users shouldn't
actually need to do this.

503
00:22:20.286 --> 00:22:22.576
As you may expect, there's
a couple of caveats.

504
00:22:22.576 --> 00:22:26.706
So, first caveat, you
need to be using the iOS 7

505
00:22:26.826 --> 00:22:28.416
or OS X Mavericks SDK.

506
00:22:28.416 --> 00:22:30.806
Only those SDKs have
support for Modules.

507
00:22:31.146 --> 00:22:32.986
Now, of course, you
can deploy backward

508
00:22:33.396 --> 00:22:35.886
because you can use the new
SDK and deploy backward.

509
00:22:36.146 --> 00:22:39.316
Modules don't change how
your code is actually built.

510
00:22:39.316 --> 00:22:40.836
They don't change
for your source code.

511
00:22:40.836 --> 00:22:42.336
They don't change how
your code is built.

512
00:22:42.336 --> 00:22:45.736
You just need to move to
the newer SDK to get those--

513
00:22:45.796 --> 00:22:46.936
essentially the Module Maps

514
00:22:47.316 --> 00:22:50.356
that tell the Module
system how to work.

515
00:22:50.536 --> 00:22:54.416
Second point is that
Modules aren't available C++.

516
00:22:54.736 --> 00:22:58.656
Now, it's perfectly fine to
enable Modules in a C++ project.

517
00:22:58.946 --> 00:23:01.836
Essentially, the fact that you
requested Modules will just be

518
00:22:58.946 --> 00:23:01.836
Essentially, the fact that you
requested Modules will just be

519
00:23:01.836 --> 00:23:05.176
ignored for the C++ sources,
you'll still get the benefits

520
00:23:05.176 --> 00:23:07.146
of Modules for your
Objective-C sources.

521
00:23:07.756 --> 00:23:10.386
The only downside here is you
can't use the fancy new @import

522
00:23:10.386 --> 00:23:12.096
syntax in something
that's shared

523
00:23:12.546 --> 00:23:16.066
between C++ and non-C++ code.

524
00:23:16.276 --> 00:23:19.206
And finally, while Modules
are available for all

525
00:23:19.206 --> 00:23:22.986
of the system frameworks,
on iOS and the Mac,

526
00:23:22.986 --> 00:23:24.686
they're not available
for user frameworks.

527
00:23:26.116 --> 00:23:28.676
So, let's wrap up here.

528
00:23:29.596 --> 00:23:32.176
We talked about this
new feature, Modules.

529
00:23:32.696 --> 00:23:35.826
The idea behind Modules is to
simplify the user frameworks

530
00:23:35.826 --> 00:23:39.896
so you can just get the nice
semantic import behavior

531
00:23:40.326 --> 00:23:41.516
which is much harder to break

532
00:23:41.586 --> 00:23:44.766
than the textual inclusion
behavior that would, so--

533
00:23:44.766 --> 00:23:47.816
and this means we've essentially
eliminated all of the problems

534
00:23:47.816 --> 00:23:50.246
with strange header
order dependencies

535
00:23:50.246 --> 00:23:52.556
between system frameworks
and user code,

536
00:23:54.166 --> 00:23:57.946
and we've eliminated the
separate link with library step

537
00:23:57.946 --> 00:24:00.426
through the Autolinking
feature of Modules.

538
00:23:57.946 --> 00:24:00.426
through the Autolinking
feature of Modules.

539
00:24:01.696 --> 00:24:04.096
Now, Modules are
actually a lot more

540
00:24:04.096 --> 00:24:05.646
than just a user convenience.

541
00:24:06.226 --> 00:24:09.196
We're actually fundamentally
changing the underlying model

542
00:24:09.196 --> 00:24:11.916
and how we can access
to APIs in a way

543
00:24:11.916 --> 00:24:15.076
that can significantly improve
the performance of source tools.

544
00:24:15.416 --> 00:24:17.056
And the very nice thing here is

545
00:24:17.056 --> 00:24:19.176
that improvement
essentially comes for free.

546
00:24:19.496 --> 00:24:21.546
You no longer have to tweak
your precompiled header

547
00:24:21.546 --> 00:24:22.526
to get the build times.

548
00:24:22.826 --> 00:24:25.476
Just use Modules and forget
about the precompiled header,

549
00:24:25.716 --> 00:24:27.396
Modules will do the right thing.

550
00:24:28.616 --> 00:24:31.886
And finally, you can enable
this feature without any changes

551
00:24:31.886 --> 00:24:33.156
to your source code, whatsoever.

552
00:24:33.226 --> 00:24:36.186
It's changing your Build Setting
and rebuilding your application.

553
00:24:36.456 --> 00:24:37.436
The application doesn't change.

554
00:24:37.436 --> 00:24:38.496
Your source code doesn't change.

555
00:24:39.936 --> 00:24:42.346
So with that, I'd like to
turn you over to my colleague,

556
00:24:42.346 --> 00:24:44.886
Dave Zarzycki to talk about
advances in Objective-C.

557
00:24:44.886 --> 00:24:45.446
[applause]

558
00:24:45.446 --> 00:24:47.516
>> All right.

559
00:24:48.066 --> 00:24:48.556
Thanks, Doug.

560
00:24:51.396 --> 00:24:53.796
So I'm going to be talking
to you about more advances

561
00:24:53.796 --> 00:24:56.536
in Objective-C, some
recent, some new.

562
00:24:57.336 --> 00:24:59.146
So, I'm going to be
starting off talking

563
00:24:59.146 --> 00:25:00.216
about better productivity.

564
00:24:59.146 --> 00:25:00.216
about better productivity.

565
00:25:00.216 --> 00:25:01.986
We're going to be
talking about tool support

566
00:25:01.986 --> 00:25:03.236
for modernizing your code.

567
00:25:03.236 --> 00:25:05.576
We'll be talking about
improvements in the SDK

568
00:25:05.576 --> 00:25:08.146
and how they make your life
better and more productive

569
00:25:08.146 --> 00:25:09.066
and generate better code.

570
00:25:09.066 --> 00:25:12.466
And we'll be talking
about block return safety

571
00:25:12.556 --> 00:25:13.926
and catching some common errors.

572
00:25:14.436 --> 00:25:16.196
And then we'll be talking
about the runtime in your code.

573
00:25:16.196 --> 00:25:19.886
And then, for the rest of
the talk, we'll be talking

574
00:25:19.886 --> 00:25:21.216
about Automatic Reference
Counting.

575
00:25:21.296 --> 00:25:24.486
We'll be talking about
updates we've made to it

576
00:25:24.486 --> 00:25:26.576
and we've been talking--
we'll talk about improvements

577
00:25:26.616 --> 00:25:28.206
in generating better warnings

578
00:25:28.206 --> 00:25:29.716
that help you generate
more correct code.

579
00:25:30.476 --> 00:25:32.386
So with that, let's
jump in and talk

580
00:25:32.386 --> 00:25:34.136
about Tools Support
for Modernization.

581
00:25:35.066 --> 00:25:38.336
Something we did recently
was adding a Refactoring Tool

582
00:25:38.386 --> 00:25:39.716
to modernize your code.

583
00:25:40.676 --> 00:25:42.516
It's found right
here in the Edit Menu

584
00:25:42.656 --> 00:25:45.956
under the Refactoring
Submenu and you just convert

585
00:25:45.956 --> 00:25:48.506
to the Modern Objective-C
Syntax.

586
00:25:49.546 --> 00:25:50.736
So what does this do?

587
00:25:50.976 --> 00:25:54.336
Well, it reduces a ton of
boilerplate in your code.

588
00:25:54.336 --> 00:25:57.756
We have object-- more object
literals, container literals.

589
00:25:58.246 --> 00:25:59.936
We have improved subscripting.

590
00:26:00.536 --> 00:26:01.596
And this is covered in-depth

591
00:26:01.596 --> 00:26:03.036
at last year's version
of this talk.

592
00:26:04.416 --> 00:26:05.806
So let's look at
the example of this.

593
00:26:05.946 --> 00:26:08.236
Here is an example of one of
my favorite jazz musicians.

594
00:26:09.436 --> 00:26:12.046
Now, we do have literals.

595
00:26:12.046 --> 00:26:12.736
We have string literals.

596
00:26:12.796 --> 00:26:13.846
We have a lot of other things.

597
00:26:13.846 --> 00:26:15.406
We need to remember how
to create a dictionary.

598
00:26:15.406 --> 00:26:17.506
What factory method to call?

599
00:26:17.866 --> 00:26:21.146
We need to remember the order
of the keys and the objects.

600
00:26:21.586 --> 00:26:23.856
We need to remember that
they have to be objects.

601
00:26:23.986 --> 00:26:26.246
And we have to remember to
nil-terminate this list.

602
00:26:26.916 --> 00:26:28.846
And similarly for NSArray,

603
00:26:28.846 --> 00:26:30.716
we have to remember the
right factory method to call.

604
00:26:30.796 --> 00:26:33.256
And like NSDictionary, we need

605
00:26:33.256 --> 00:26:34.496
to remember the nil-terminate
it.

606
00:26:35.866 --> 00:26:38.166
Similarly, NSNumber
has the same problem.

607
00:26:39.366 --> 00:26:41.646
We need to remember the
right factory method to call.

608
00:26:41.646 --> 00:26:42.276
Is that an end?

609
00:26:42.276 --> 00:26:43.456
Is it a long?

610
00:26:43.456 --> 00:26:45.106
Is it a short?

611
00:26:45.106 --> 00:26:47.466
We need to remember
the right one for Bool.

612
00:26:48.056 --> 00:26:50.726
There's a lot of opportunity
here to reduce boilerplate.

613
00:26:51.666 --> 00:26:55.256
Well, with the Refactoring Tool,
you can adopt the modern syntax.

614
00:26:55.736 --> 00:26:58.126
Dictionary literals just
become @, curly brace.

615
00:26:58.596 --> 00:27:01.916
Array literals become
@ square bracket.

616
00:26:58.596 --> 00:27:01.916
Array literals become
@ square bracket.

617
00:27:03.026 --> 00:27:06.136
The compiler helps you remember
keys and values and the fact

618
00:27:06.136 --> 00:27:07.266
that they have to be objects.

619
00:27:07.836 --> 00:27:10.036
You don't need to worry about
nil terminating the list.

620
00:27:10.106 --> 00:27:13.436
And similarly, for NSNumber,
you don't need to worry

621
00:27:13.436 --> 00:27:14.546
about what type it is anymore.

622
00:27:14.546 --> 00:27:17.826
You can just say @
number or @ yes or @ no.

623
00:27:17.826 --> 00:27:21.046
So this is a huge simplification
and we have tools to help you

624
00:27:21.046 --> 00:27:23.556
about the syntax so you can
focus on writing great code

625
00:27:23.556 --> 00:27:26.046
and sweeping away the details.

626
00:27:27.876 --> 00:27:30.386
Similarly, we can consider
containers before the

627
00:27:30.386 --> 00:27:31.416
modern syntax.

628
00:27:32.276 --> 00:27:34.966
Throughout your code, you work
with containers and you have

629
00:27:35.026 --> 00:27:37.196
to write this code repeatedly.

630
00:27:37.196 --> 00:27:40.236
You have to remember
if in the case--

631
00:27:40.266 --> 00:27:43.506
whether the key comes first
or the object comes first,

632
00:27:44.056 --> 00:27:46.976
it's just a lot of boilerplate
that could be simplified.

633
00:27:47.976 --> 00:27:49.876
Well, with modern
syntax, you can do that.

634
00:27:50.506 --> 00:27:53.966
You can use common subscripting
syntax that's available

635
00:27:53.966 --> 00:27:56.676
in a variety of languages
to access containers

636
00:27:56.676 --> 00:27:59.296
in the modern SDK and
the modern syntax.

637
00:27:59.816 --> 00:28:03.766
Now, there's a ton more to
modern syntax that I'm not going

638
00:27:59.816 --> 00:28:03.766
Now, there's a ton more to
modern syntax that I'm not going

639
00:28:03.766 --> 00:28:05.176
to cover here and
I strongly suggest

640
00:28:05.176 --> 00:28:06.346
that you watch last year's talk.

641
00:28:07.266 --> 00:28:09.726
We have boxed expressions
via @ parenthesis.

642
00:28:10.786 --> 00:28:14.456
We have the full intersection
with C types if you want

643
00:28:14.456 --> 00:28:17.476
to understand how they work,
like shorts and chars and longs

644
00:28:17.476 --> 00:28:18.466
and unsigned behavior.

645
00:28:19.736 --> 00:28:24.016
We have-- we teach you how
to implement subscripting

646
00:28:24.016 --> 00:28:27.786
for your own classes and you can
see this on last year's version

647
00:28:27.936 --> 00:28:31.056
of this talk, number
four or five.

648
00:28:31.926 --> 00:28:35.276
So with that, I'd like to
jump into SDK improvements

649
00:28:35.446 --> 00:28:37.616
and how they will
improve your productivity.

650
00:28:38.686 --> 00:28:42.116
So the SDK is constantly
leveraging the compiler.

651
00:28:42.116 --> 00:28:43.486
It's adopting new features.

652
00:28:43.876 --> 00:28:47.026
It's helping you write more
correct code, safer code,

653
00:28:47.546 --> 00:28:50.836
and get better compiled time
error detection and problems

654
00:28:50.836 --> 00:28:51.846
that you might be running into.

655
00:28:52.846 --> 00:28:55.186
And specifically, I'd like
to call out two features

656
00:28:55.186 --> 00:28:57.756
that the new SDKs have adopted

657
00:28:57.806 --> 00:29:00.676
that will affect
potentially your experience

658
00:28:57.806 --> 00:29:00.676
that will affect
potentially your experience

659
00:29:00.676 --> 00:29:03.806
and help you write better code.

660
00:29:04.026 --> 00:29:06.186
And specifically, where there--

661
00:29:06.836 --> 00:29:09.956
instancetype keyword and
explicitly-typed enums.

662
00:29:11.086 --> 00:29:12.866
So let's jump in and
consider with that is.

663
00:29:14.236 --> 00:29:16.786
Now, some of you probably
can look at this code

664
00:29:16.896 --> 00:29:18.006
and already see the bug.

665
00:29:18.806 --> 00:29:20.916
We're taking an NSArray
and we're assigning it

666
00:29:20.916 --> 00:29:22.976
to an NSDictionary variable.

667
00:29:22.976 --> 00:29:24.386
That's terrible.

668
00:29:24.866 --> 00:29:27.766
But, copy and paste
errors are easy.

669
00:29:28.676 --> 00:29:30.586
Refactoring are easy.

670
00:29:31.236 --> 00:29:35.346
And in fact, now with the
SDKs worshipping this,

671
00:29:35.486 --> 00:29:39.376
you will actually get a warning
pointing out the problem.

672
00:29:40.636 --> 00:29:42.926
So how is it that the compiler
knows if we have a problem?

673
00:29:43.746 --> 00:29:45.256
When previous versions
of the SDK,

674
00:29:45.256 --> 00:29:48.876
array and many similar
APIs returned IDE.

675
00:29:49.676 --> 00:29:52.516
The problem is that IDE
implicitly converts to anything,

676
00:29:52.556 --> 00:29:54.746
so the compiler didn't
historically know

677
00:29:54.746 --> 00:29:56.346
that there was a problem here.

678
00:29:57.826 --> 00:30:01.146
In the new SDK, array
returns instancetype.

679
00:29:57.826 --> 00:30:01.146
In the new SDK, array
returns instancetype.

680
00:30:02.176 --> 00:30:03.946
This is a contextual keyword.

681
00:30:04.896 --> 00:30:06.796
It's only for return types.

682
00:30:07.286 --> 00:30:12.066
And subclasses don't need
to redeclare array here

683
00:30:12.066 --> 00:30:14.786
to expose the fact that
they're returning an instance

684
00:30:14.866 --> 00:30:16.656
of their subclass.

685
00:30:17.156 --> 00:30:20.446
And finally, the compiler
contextually matches the return

686
00:30:20.446 --> 00:30:21.756
type to that other receiver.

687
00:30:23.056 --> 00:30:24.306
Okay, well what does that mean?

688
00:30:25.016 --> 00:30:27.506
Let's consider our
subclassing NSArray.

689
00:30:27.646 --> 00:30:29.516
And let's say we create
a class name Foobar.

690
00:30:30.116 --> 00:30:31.596
We don't do anything more.

691
00:30:31.596 --> 00:30:33.036
We just put in @end.

692
00:30:33.226 --> 00:30:37.526
And what happens in this code
now that we're taking a Foobar

693
00:30:37.526 --> 00:30:40.726
and calling array and this
signage NSDictionary variable?

694
00:30:40.726 --> 00:30:44.606
Well, the compiler would still
print out the warning, great.

695
00:30:45.866 --> 00:30:47.476
But I'd like to point out is

696
00:30:47.476 --> 00:30:49.836
that the compiler is
contextually taking the receive

697
00:30:49.836 --> 00:30:53.706
type Foobar and printing
out the warning pointing

698
00:30:53.706 --> 00:30:55.696
out that the return
value is also a Foobar,

699
00:30:55.696 --> 00:30:57.156
and that's the source
of the problem.

700
00:30:58.246 --> 00:30:59.926
So that's the instancetype
keyword.

701
00:31:00.776 --> 00:31:04.206
Next up, I'd like to talk
about explicitly-typed enum.

702
00:31:04.206 --> 00:31:07.886
Another feature that the SDK
has adopted that will show

703
00:31:07.886 --> 00:31:09.946
up in your code and help
you detect more errors

704
00:31:10.036 --> 00:31:10.946
and be more productive.

705
00:31:12.386 --> 00:31:14.356
So let's look at this code.

706
00:31:15.016 --> 00:31:16.446
Some of you that have experience

707
00:31:16.446 --> 00:31:19.106
with URLs may already
see the bug.

708
00:31:19.966 --> 00:31:22.266
These are not the same enum.

709
00:31:23.166 --> 00:31:26.016
We have an NSURLHandleStatus
on the left.

710
00:31:26.456 --> 00:31:29.086
We have an NSURLSessionTaskState
on the right.

711
00:31:29.986 --> 00:31:34.326
Whoops. Well, again, copy
and paste errors are easy

712
00:31:35.126 --> 00:31:36.736
and refactoring errors
are really easy.

713
00:31:37.646 --> 00:31:40.266
And the reason this is used
to compile in the past is

714
00:31:40.266 --> 00:31:43.276
that enums are essentially
just global integers.

715
00:31:43.276 --> 00:31:45.296
So, we're just assigning
one number to another.

716
00:31:46.476 --> 00:31:51.416
Well now, with the SDKs, you
will get a warning pointing

717
00:31:51.416 --> 00:31:53.366
out that these are
of different types

718
00:31:53.456 --> 00:31:54.666
which is exactly what you want.

719
00:31:54.666 --> 00:31:58.396
So how does the compiler know?

720
00:31:59.446 --> 00:32:01.756
In the past, we declared
enums like this.

721
00:31:59.446 --> 00:32:01.756
In the past, we declared
enums like this.

722
00:32:02.576 --> 00:32:05.536
In one line, we would declare
the enum and enumerate,

723
00:32:05.966 --> 00:32:08.016
you know, ABC, JKL, XYZ.

724
00:32:08.016 --> 00:32:12.396
And the next line, we
declare a typedef where we say

725
00:32:12.396 --> 00:32:17.066
that what the storage is
and then give it a name.

726
00:32:17.066 --> 00:32:21.126
Well, this is where the
first line is just mint.

727
00:32:21.286 --> 00:32:24.466
We haven't actually bound the
two pieces of information here.

728
00:32:26.736 --> 00:32:28.706
And how we fixed this in the SDK

729
00:32:28.706 --> 00:32:31.046
and with the compiler is the
compiler supports a new feature

730
00:32:31.046 --> 00:32:32.766
for explicitly-typed enums.

731
00:32:33.286 --> 00:32:34.016
What you can see here

732
00:32:34.016 --> 00:32:37.266
on the first line is we've
actually moved the storage up

733
00:32:37.266 --> 00:32:39.476
and now the enum knows
what its storage type is

734
00:32:39.476 --> 00:32:42.306
and then now it's no longer
an int, it's an NSUInteger.

735
00:32:42.306 --> 00:32:46.806
Now in the next line,
we actually bind or enum

736
00:32:46.806 --> 00:32:49.126
to a type available for use.

737
00:32:49.796 --> 00:32:53.126
This is all covered last year
in-depth and this version--

738
00:32:53.256 --> 00:32:54.546
in this talk last year.

739
00:32:56.036 --> 00:32:59.346
Now, the Cocoa team have
provided convenient macros

740
00:32:59.456 --> 00:33:00.716
that exposed this feature.

741
00:32:59.456 --> 00:33:00.716
that exposed this feature.

742
00:33:00.996 --> 00:33:04.056
We have NS Enum for a
traditional enumerations,

743
00:33:04.056 --> 00:33:05.326
like we just demonstrated.

744
00:33:06.036 --> 00:33:07.696
You know, ABC, JKL, XYZ.

745
00:33:07.696 --> 00:33:11.826
And they also have a
convenient macro for NS Options.

746
00:33:12.686 --> 00:33:16.756
So, a bit wise operations,
like, you know, different flags.

747
00:33:17.336 --> 00:33:21.416
So I recommend the use of these
macros and you'll see them

748
00:33:21.416 --> 00:33:22.536
in the system frameworks.

749
00:33:24.146 --> 00:33:26.646
But we don't stop
with just warnings.

750
00:33:27.166 --> 00:33:30.816
We also improved code
completion with NS Enum

751
00:33:30.816 --> 00:33:32.146
and explicitly-typed enums.

752
00:33:33.236 --> 00:33:37.186
So before NS Enum, if you tried

753
00:33:37.186 --> 00:33:40.806
to code complete our
example enumeration here

754
00:33:40.806 --> 00:33:45.086
and you typed X, you would see
a bunch of XPC-related APIs

755
00:33:45.086 --> 00:33:46.976
and you wouldn't see your enum.

756
00:33:47.456 --> 00:33:48.396
That's not fun.

757
00:33:49.356 --> 00:33:52.756
Well, if we just switch to
the NS Enum macro and then get

758
00:33:52.756 --> 00:33:53.886
up the compiler feature,

759
00:33:53.886 --> 00:33:55.966
Code Completion gives
us exactly what we want

760
00:33:56.656 --> 00:33:58.736
and we see our enumeration
available

761
00:33:58.736 --> 00:33:59.936
in Code Completion
which is great.

762
00:34:00.426 --> 00:34:04.326
But it just doesn't--
it doesn't stop there.

763
00:34:04.476 --> 00:34:08.376
The power of explicitly-typed
enums manifest in multiple ways.

764
00:34:09.536 --> 00:34:12.476
So in this particular
case, we have an NSArray

765
00:34:12.476 --> 00:34:17.025
that we're trying to
sort using a comparator.

766
00:34:17.116 --> 00:34:19.025
And we do some logic
and then we decide

767
00:34:19.025 --> 00:34:20.666
to return ascending
or descending.

768
00:34:21.646 --> 00:34:22.456
Now if you look closely,

769
00:34:22.456 --> 00:34:24.956
we actually haven't specified
the return type of this block

770
00:34:24.956 --> 00:34:26.946
between the caret and
the opening parenthesis.

771
00:34:27.525 --> 00:34:32.156
And the compiler would actually
give us an error saying that,

772
00:34:32.226 --> 00:34:35.735
"Well, we infer the type of
this block as returning int

773
00:34:35.735 --> 00:34:42.005
but the API actually takes
NS-- comparison result."

774
00:34:42.005 --> 00:34:44.025
All right.

775
00:34:44.676 --> 00:34:46.146
Well, how do we fix this?

776
00:34:46.706 --> 00:34:50.116
Before explicitly-typed
enums, we have the Cast, thus,

777
00:34:50.556 --> 00:34:51.866
assigning the correct type.

778
00:34:53.146 --> 00:34:54.896
And yes, this would
make the warning go away

779
00:34:54.896 --> 00:34:57.366
but now we have this lingering
cast in our code that, you know,

780
00:34:57.406 --> 00:34:58.956
could create future problems.

781
00:34:59.266 --> 00:35:01.686
Because the explicitly-typed
enums allow us to fix this

782
00:34:59.266 --> 00:35:01.686
Because the explicitly-typed
enums allow us to fix this

783
00:35:01.686 --> 00:35:04.146
and make the enum how
many explicit-type,

784
00:35:05.216 --> 00:35:08.186
we can help you avoid casting
and in fact you can now go

785
00:35:08.266 --> 00:35:09.646
and delete these
casts and go back

786
00:35:09.646 --> 00:35:11.966
to the natural looking
code you wanted to have

787
00:35:11.996 --> 00:35:14.506
in the first place and
write it as intended.

788
00:35:16.776 --> 00:35:19.526
Digging deeper on what
NS Enum can do for you,

789
00:35:20.046 --> 00:35:21.666
let's consider the fact

790
00:35:21.666 --> 00:35:24.806
of how implicitly-typed enums
can manifest in different ways.

791
00:35:25.396 --> 00:35:27.396
Again, before explicitly-typed
enums,

792
00:35:27.456 --> 00:35:30.506
these two URL-related enums

793
00:35:30.506 --> 00:35:33.486
that are actually different
were just ints as far

794
00:35:33.486 --> 00:35:35.226
as the compiler was concerned.

795
00:35:36.746 --> 00:35:39.636
And this manifested as a
silent bug in your code.

796
00:35:40.296 --> 00:35:42.966
Now with NS Enum, you get
the warning that you want

797
00:35:43.106 --> 00:35:46.266
and now you have to
decide how to fix the code.

798
00:35:46.266 --> 00:35:48.256
Now, here, this is pointing
out a design problem

799
00:35:48.256 --> 00:35:49.716
so that there is
no quick solution.

800
00:35:49.716 --> 00:35:51.646
You'd have to think about
it and actually figure

801
00:35:51.646 --> 00:35:52.796
out what you originally
intended.

802
00:35:53.306 --> 00:35:56.536
So with that, now
I'd like to move

803
00:35:56.536 --> 00:35:59.216
on to the Objective-C
Runtime and you.

804
00:35:59.216 --> 00:36:02.806
The Objective-C Runtime is
the core of the language.

805
00:35:59.216 --> 00:36:02.806
The Objective-C Runtime is
the core of the language.

806
00:36:03.406 --> 00:36:05.816
It enables a ton of
dynamic behavior.

807
00:36:05.816 --> 00:36:10.286
We have, you know, of course,
dynamic method dispatch.

808
00:36:10.736 --> 00:36:12.296
We have object introspection.

809
00:36:12.826 --> 00:36:14.846
We have object proxies.

810
00:36:15.066 --> 00:36:16.686
And we have dynamic
class construction,

811
00:36:16.686 --> 00:36:18.306
even a dynamic method
replacement.

812
00:36:20.056 --> 00:36:23.596
The runtime enables a ton of
innovation in the language.

813
00:36:24.336 --> 00:36:26.666
We've added many
features over the years

814
00:36:26.666 --> 00:36:28.546
and it's really the heart
of all these features.

815
00:36:29.646 --> 00:36:32.646
So to give you an example, we've
added a new key-value observing,

816
00:36:32.646 --> 00:36:38.326
associated objects, we've added
@synchronized to do locking,

817
00:36:38.936 --> 00:36:41.786
we've added weak references,
we've added tagged pointers,

818
00:36:41.786 --> 00:36:44.236
and the list go on, on and on.

819
00:36:44.286 --> 00:36:46.466
I'd like to actually call
out tagged pointers though

820
00:36:46.466 --> 00:36:50.006
because we have some new
warnings to enable innovation.

821
00:36:51.006 --> 00:36:54.036
So, let's first dive deep
and ask the question,

822
00:36:54.036 --> 00:36:55.136
what are tagged pointers?

823
00:36:56.006 --> 00:37:00.936
They were added in 64-bit Cocoa
for a small value-like objects.

824
00:36:56.006 --> 00:37:00.936
They were added in 64-bit Cocoa
for a small value-like objects.

825
00:37:01.006 --> 00:37:03.336
And examples of a
value-like objects are

826
00:37:03.336 --> 00:37:06.576
like NSNumber, NSDate,
just values.

827
00:37:07.436 --> 00:37:11.416
What we're doing is we're
actually storing the object

828
00:37:11.416 --> 00:37:13.696
in the pointer itself,
so we don't actually need

829
00:37:13.696 --> 00:37:15.066
to call malloc or free.

830
00:37:15.066 --> 00:37:18.456
And when you don't call
malloc or free, you could've--

831
00:37:19.056 --> 00:37:21.976
code gets a ton faster and
it's more space efficient.

832
00:37:22.066 --> 00:37:23.936
It's three times more
space efficient and it's

833
00:37:23.936 --> 00:37:25.506
over 100 times faster
to allocate

834
00:37:25.506 --> 00:37:27.446
and deallocate these
small value-like objects.

835
00:37:28.856 --> 00:37:31.636
Okay, it's great in theory
but I'm a visual person.

836
00:37:31.636 --> 00:37:32.896
Show me how this actually works.

837
00:37:34.116 --> 00:37:35.066
In a normal pointer,

838
00:37:35.436 --> 00:37:37.856
we're actually only
using the top 60 bits.

839
00:37:38.186 --> 00:37:40.616
The bottom four bits of
a pointer are always zero

840
00:37:40.616 --> 00:37:42.476
because objects are
always 16-byte aligned.

841
00:37:43.056 --> 00:37:45.376
We can take advantage
of this fact

842
00:37:45.376 --> 00:37:49.206
to implement what we call tagged
pointers where we actually store

843
00:37:49.206 --> 00:37:52.146
in the bottom bit discriminators
and when it's one,

844
00:37:52.466 --> 00:37:54.886
we can actually store a ton of
data in the rest of the bits.

845
00:37:55.306 --> 00:37:58.076
And this is in fact what we do.

846
00:37:58.286 --> 00:38:01.686
Having said all this, this
is an implementation detail.

847
00:37:58.286 --> 00:38:01.686
Having said all this, this
is an implementation detail.

848
00:38:02.116 --> 00:38:03.876
Some of you have
discovered this feature

849
00:38:03.876 --> 00:38:05.116
and we need you to
undiscover it.

850
00:38:05.966 --> 00:38:10.616
[laughter] The runtime
details are private.

851
00:38:10.616 --> 00:38:13.616
And in fact, what
remaining little tidbits

852
00:38:13.616 --> 00:38:15.756
of data structures you're
finding that are still public

853
00:38:15.756 --> 00:38:17.596
in the data structures
are becoming private.

854
00:38:18.796 --> 00:38:21.926
Most URI-- applications
are well behaved

855
00:38:21.926 --> 00:38:24.256
and we thank you for that.

856
00:38:24.256 --> 00:38:26.176
Use APIs to instropect things

857
00:38:26.776 --> 00:38:28.556
and this lets us
innovate considerably

858
00:38:28.556 --> 00:38:29.596
as we've already described.

859
00:38:30.206 --> 00:38:34.866
But we've added some new
warnings to detect the use

860
00:38:34.866 --> 00:38:39.036
of tagged pointers and a related
problem of Raw 'isa' access.

861
00:38:40.416 --> 00:38:43.896
So, you might have code
like this in your program

862
00:38:44.026 --> 00:38:46.836
where you're testing the tag bit
and then you are like, "Great,

863
00:38:47.036 --> 00:38:50.256
I have discovered the tag bit
isn't set, I'm just going to run

864
00:38:50.256 --> 00:38:53.196
in there and just access
the isa directly and--

865
00:38:53.546 --> 00:38:55.696
because I'm think I'm
optimizing, this is fun."

866
00:38:56.506 --> 00:38:58.446
But in the case when
the tag bit is set,

867
00:38:58.446 --> 00:38:59.796
you actually called
the correct API.

868
00:39:01.326 --> 00:39:04.556
Well now, you're going to get a
warning for that tag bit check.

869
00:39:05.636 --> 00:39:06.936
And you're actually
going to get an error

870
00:39:06.936 --> 00:39:08.626
for the direct usage of the isa.

871
00:39:09.836 --> 00:39:10.916
Well how do you fix this?

872
00:39:11.576 --> 00:39:14.316
You delete the testing of that
bit and direct that access

873
00:39:14.316 --> 00:39:15.846
to the isa and you actually call

874
00:39:15.846 --> 00:39:18.816
like it isKindOfClass
or object getClass.

875
00:39:19.866 --> 00:39:21.126
We really need you to do this

876
00:39:21.126 --> 00:39:22.926
so we can unlock the
next level of innovation.

877
00:39:23.336 --> 00:39:25.726
And failure to do so, might
break your code in the future.

878
00:39:25.876 --> 00:39:28.466
So please, heed these warnings
and errors in your code

879
00:39:28.806 --> 00:39:30.386
and do the right thing.

880
00:39:31.476 --> 00:39:32.506
Thank you.

881
00:39:32.726 --> 00:39:35.706
Finally on the runtime part
of this talk, I'd like to talk

882
00:39:35.706 --> 00:39:36.806
about Garbage Collection.

883
00:39:38.096 --> 00:39:40.186
GC only exists on the Mac.

884
00:39:41.026 --> 00:39:42.176
We have replaced it with ARC

885
00:39:43.126 --> 00:39:47.216
and in fact we deprecated
Garbage Collection as of 10.8.

886
00:39:48.376 --> 00:39:50.006
We're very serious about this.

887
00:39:50.186 --> 00:39:52.566
We're not supporting Garbage
Collection in new frameworks,

888
00:39:52.606 --> 00:39:55.726
things like AVKit or Accounts
or GameController or GameKit,

889
00:39:56.736 --> 00:39:59.626
et cetera, et cetera, we're not
supporting Garbage Collection.

890
00:40:01.176 --> 00:40:03.686
We really need you to
use the ARC Migrator

891
00:40:03.686 --> 00:40:05.866
to transition off GC.

892
00:40:06.676 --> 00:40:09.866
So with that, let's talk about
Automatic Reference Counting

893
00:40:10.276 --> 00:40:13.006
and tell you about updates we've
been doing and some improvements

894
00:40:13.226 --> 00:40:15.276
to help you write better code.

895
00:40:16.706 --> 00:40:18.346
Let's start with the updates.

896
00:40:19.306 --> 00:40:22.636
Cocoa is designed with reference
counting semantics in mind.

897
00:40:22.936 --> 00:40:23.696
This is great.

898
00:40:24.136 --> 00:40:26.016
Being able to deterministically
know

899
00:40:26.016 --> 00:40:27.706
when an object is
destroyed allows you

900
00:40:27.706 --> 00:40:28.996
to better reason
about your code.

901
00:40:29.546 --> 00:40:31.066
It allows you to
better schedule things.

902
00:40:31.066 --> 00:40:32.536
It allows you to better design.

903
00:40:32.536 --> 00:40:34.266
And it's also just
great for debugging.

904
00:40:34.966 --> 00:40:38.296
ARC also helps you
write great code.

905
00:40:38.296 --> 00:40:42.026
It allows you to focus on what
matters and not the minutia

906
00:40:42.026 --> 00:40:45.986
of details of when things
need to be released.

907
00:40:47.256 --> 00:40:51.726
The majority of new App Store
submissions are using ARC.

908
00:40:51.726 --> 00:40:54.776
So a lot of you also agree that
this is a really great tool

909
00:40:54.776 --> 00:40:56.086
for focusing on what matters.

910
00:40:57.736 --> 00:41:01.236
Specific-- another great
example of ARC is Xcode 5.0.

911
00:40:57.736 --> 00:41:01.236
Specific-- another great
example of ARC is Xcode 5.0.

912
00:41:01.716 --> 00:41:03.626
This used to be a GC app.

913
00:41:04.266 --> 00:41:05.266
It was a large app.

914
00:41:06.006 --> 00:41:07.596
Nevertheless, we were
able to convert it

915
00:41:07.596 --> 00:41:08.906
to Automatic Reference Counting

916
00:41:08.966 --> 00:41:10.506
and we're thrilled
with the results.

917
00:41:11.486 --> 00:41:13.226
We're thrilled with
the better determinism.

918
00:41:13.526 --> 00:41:14.786
We love the better debugging.

919
00:41:14.956 --> 00:41:17.426
We love that we're able to offer
tons of better performance.

920
00:41:17.936 --> 00:41:20.996
And we hope that you'll
find the same experience.

921
00:41:20.996 --> 00:41:25.486
Speaking of performance,
we are continuing

922
00:41:25.486 --> 00:41:27.476
to improve the performance
of ARC.

923
00:41:27.876 --> 00:41:30.146
Weak references are
now about twice as fast

924
00:41:30.276 --> 00:41:31.456
and this year's version

925
00:41:31.516 --> 00:41:34.906
of our operating system
iOS 7 and 10.9 for the Mac.

926
00:41:36.316 --> 00:41:39.246
And we're also improving the
debug experience as well.

927
00:41:39.366 --> 00:41:41.946
We have more predictable memory
usage under debug builds.

928
00:41:42.636 --> 00:41:44.376
Specifically, the lifetime

929
00:41:44.376 --> 00:41:47.156
of autoreleased objects is
much more like released builds.

930
00:41:48.586 --> 00:41:49.996
Now when you autorelease
an object,

931
00:41:49.996 --> 00:41:51.696
you don't necessarily
know when it goes away.

932
00:41:52.066 --> 00:41:54.926
And in fact, ARC
optimizations could kick in

933
00:41:54.926 --> 00:41:56.046
and change that timing.

934
00:41:56.736 --> 00:41:58.266
We've improved the compilers

935
00:41:58.266 --> 00:42:02.436
so the debug builds now
release the object much more

936
00:41:58.266 --> 00:42:02.436
so the debug builds now
release the object much more

937
00:42:02.436 --> 00:42:06.166
like when released builds and
we hope you appreciate that.

938
00:42:11.746 --> 00:42:13.926
[applause] So this is our
great [inaudible] ARC.

939
00:42:14.736 --> 00:42:15.766
Well, we have Migrator.

940
00:42:16.326 --> 00:42:17.896
It does all the heavy
lifting for you.

941
00:42:17.896 --> 00:42:19.856
It removes retain,
release, autorelease.

942
00:42:20.616 --> 00:42:24.366
It deletes empty dealloc methods

943
00:42:24.366 --> 00:42:26.656
if all your dealloc method
was doing was calling release,

944
00:42:26.656 --> 00:42:27.386
release, release.

945
00:42:28.846 --> 00:42:30.726
It converts NSAutoreleasePool

946
00:42:30.726 --> 00:42:33.646
to @autoreleasepool
in the modern syntax.

947
00:42:34.986 --> 00:42:36.106
But you have to do the rest.

948
00:42:36.466 --> 00:42:39.966
You need to reason about some
rare things like id in structs.

949
00:42:39.966 --> 00:42:42.556
Usually the easiest thing to
do is convert these to classes

950
00:42:42.556 --> 00:42:44.536
and then, you know,
your code looks prettier

951
00:42:44.536 --> 00:42:45.146
in the end anyway.

952
00:42:45.906 --> 00:42:48.276
You also need to reason
about some atypical uses

953
00:42:48.276 --> 00:42:50.466
of memory management APIs.

954
00:42:51.736 --> 00:42:53.976
This was covered
in depth last year

955
00:42:54.106 --> 00:42:55.856
in the Automatic
Reference Counting talk

956
00:42:56.136 --> 00:42:57.536
and you can get all
the details there.

957
00:42:58.566 --> 00:43:00.436
But if you don't have time
to jump back to the video,

958
00:42:58.566 --> 00:43:00.436
But if you don't have time
to jump back to the video,

959
00:43:00.436 --> 00:43:01.836
here's what you need to do.

960
00:43:02.186 --> 00:43:05.626
Just like with modern syntax,
you can go to the Edit Menu,

961
00:43:05.626 --> 00:43:10.256
go to the Refracturing Submenu,
and you can convert to ARC

962
00:43:10.256 --> 00:43:14.566
and let the tools help
you along the way.

963
00:43:14.796 --> 00:43:18.746
So ARC and your app, we really
want you to switch to ARC

964
00:43:18.746 --> 00:43:21.606
by default and focus on what
matters which is your app

965
00:43:21.606 --> 00:43:22.606
and writing great code.

966
00:43:23.166 --> 00:43:25.876
You can always opt out specific
files if you run into problems.

967
00:43:25.876 --> 00:43:27.956
So you can just go to the
Profile Build Settings

968
00:43:27.956 --> 00:43:32.816
and select the Compiler
Flag for turning off ARC.

969
00:43:33.756 --> 00:43:35.746
And I'd also like to point

970
00:43:35.746 --> 00:43:38.866
out that the ARC Migrator
supports both manual reference

971
00:43:38.916 --> 00:43:41.156
counting code and
garbage-collected code

972
00:43:41.156 --> 00:43:44.436
and it helps you migrate both
easily and straight forward.

973
00:43:45.066 --> 00:43:49.726
Now for an update on
new things we've added

974
00:43:49.796 --> 00:43:51.886
that we think you will love.

975
00:43:51.886 --> 00:43:54.976
Let's talk about some new memory
management warnings we have

976
00:43:54.976 --> 00:43:58.606
added to help you better
reason about life under ARC.

977
00:43:59.356 --> 00:44:02.736
So, there are three things
I'm going to be talking about

978
00:43:59.356 --> 00:44:02.736
So, there are three things
I'm going to be talking about

979
00:44:03.316 --> 00:44:06.056
and we're going to be talking
about the implicit referencing

980
00:44:06.056 --> 00:44:08.716
of self and retain
cycles with blocks.

981
00:44:08.716 --> 00:44:13.876
We're going to be talking about
repeated use of a weak variable

982
00:44:13.876 --> 00:44:15.386
and what does that even mean.

983
00:44:16.046 --> 00:44:18.796
And then thirdly, we'll be
talking about sending messages

984
00:44:18.796 --> 00:44:22.316
to weak and had a better reason
about the behavior thereof.

985
00:44:23.716 --> 00:44:26.856
So let's jump in first and
talk about retain cycles.

986
00:44:27.296 --> 00:44:28.276
As a brief refresher,

987
00:44:28.276 --> 00:44:30.786
let's imagine your app is
just referencing an object.

988
00:44:31.266 --> 00:44:34.076
The reference count of this
object will start out is one.

989
00:44:35.136 --> 00:44:38.826
And similarly, if that object
references another object,

990
00:44:38.946 --> 00:44:41.216
that will be one.

991
00:44:41.216 --> 00:44:44.146
But, if we actually
have a reference back

992
00:44:44.146 --> 00:44:46.786
to the original object, its
reference count would be two.

993
00:44:46.786 --> 00:44:50.676
And if our app lets go of
the object, we have a leak

994
00:44:50.676 --> 00:44:52.766
because now these two
objects are holding references

995
00:44:52.766 --> 00:44:54.976
on to each other and
keeping the object alive.

996
00:44:56.206 --> 00:44:58.836
So with that in mind,
let's look at some code.

997
00:44:59.896 --> 00:45:02.376
Let's say in a method you
have two instance variables.

998
00:44:59.896 --> 00:45:02.376
Let's say in a method you
have two instance variables.

999
00:45:03.546 --> 00:45:05.526
And one of the instance
variables holds the block

1000
00:45:05.526 --> 00:45:06.966
and the other one
is just an object.

1001
00:45:06.966 --> 00:45:08.116
It doesn't really
matter what kind.

1002
00:45:09.146 --> 00:45:10.186
In the block we use ivar2,

1003
00:45:10.266 --> 00:45:12.346
and then we assign
the block to ivar1.

1004
00:45:12.346 --> 00:45:15.796
Well what's actually
going on under the covers

1005
00:45:15.796 --> 00:45:17.226
and how the compiler reasons

1006
00:45:17.226 --> 00:45:19.146
about this is we have
implicit use of self

1007
00:45:19.146 --> 00:45:20.256
in both of these cases.

1008
00:45:20.556 --> 00:45:23.166
And those are the actual
objects in question

1009
00:45:23.166 --> 00:45:26.606
that we need to think about.

1010
00:45:26.606 --> 00:45:30.236
So let's delete that and then
see what warning the compiler

1011
00:45:30.236 --> 00:45:31.036
can now print out.

1012
00:45:32.276 --> 00:45:35.736
So I've enabled this warning,
the compiler will print out,

1013
00:45:36.126 --> 00:45:39.516
they were capturing self
strongly in the ivar2 case,

1014
00:45:39.516 --> 00:45:41.856
and then it points
out the related case

1015
00:45:41.856 --> 00:45:43.546
where it believes
the cycle began.

1016
00:45:44.846 --> 00:45:46.196
Well, again, I'm
a visual person,

1017
00:45:46.196 --> 00:45:47.916
but show what this
looks like in practice.

1018
00:45:48.486 --> 00:45:52.616
So we have an instance of
our class and we have ivar2.

1019
00:45:52.726 --> 00:45:55.506
Again, ivar2 can be any
object, string, whatever.

1020
00:45:56.466 --> 00:45:57.876
And now we're creating
this block.

1021
00:45:59.096 --> 00:46:01.496
Now when we wrote the code,
it may look like this.

1022
00:45:59.096 --> 00:46:01.496
Now when we wrote the code,
it may look like this.

1023
00:46:01.496 --> 00:46:04.206
It may look like we're just
assigning the block to ivar1

1024
00:46:04.206 --> 00:46:05.086
and we're using ivar2.

1025
00:46:05.256 --> 00:46:06.516
What's the problem?

1026
00:46:06.516 --> 00:46:07.376
I don't see any cycle.

1027
00:46:08.866 --> 00:46:11.086
Well because there is
an implicit use of self,

1028
00:46:11.176 --> 00:46:13.326
the block is actually
retaining self.

1029
00:46:13.326 --> 00:46:17.416
And now we have a cycle and now
it's indirectly accessing ivar2.

1030
00:46:17.416 --> 00:46:19.696
And again, we'll
get the same leak

1031
00:46:19.696 --> 00:46:22.916
that we demonstrated earlier
if we let go of the instance

1032
00:46:22.916 --> 00:46:25.296
of our class, the
block will be keeping

1033
00:46:25.296 --> 00:46:28.656
that instance alive
and we have a leak.

1034
00:46:28.796 --> 00:46:30.566
So let's go back to the
code and the warning.

1035
00:46:30.856 --> 00:46:31.936
How do we fix this?

1036
00:46:32.706 --> 00:46:34.996
Well we make some room and
we add a weak variable.

1037
00:46:35.696 --> 00:46:38.716
So what we do is we create
a weak variable on the stack

1038
00:46:39.776 --> 00:46:41.306
and assign self to it.

1039
00:46:41.306 --> 00:46:44.856
And this variable is an instance
of the same type of our class.

1040
00:46:45.926 --> 00:46:49.596
And then what we do is we use
this weak variable in our block.

1041
00:46:50.376 --> 00:46:52.786
And if we do that,
the warning goes away.

1042
00:46:54.476 --> 00:46:56.466
So what's going on here?

1043
00:46:57.746 --> 00:47:01.246
Weak variables do not extend
the lifetime on objects.

1044
00:46:57.746 --> 00:47:01.246
Weak variables do not extend
the lifetime on objects.

1045
00:47:02.116 --> 00:47:04.806
They are-- and therefore,

1046
00:47:04.806 --> 00:47:06.806
they don't implicitly
create retain cycles.

1047
00:47:07.326 --> 00:47:11.636
And the great thing about weak
variables is they safely become

1048
00:47:11.636 --> 00:47:12.826
nil when the reference count

1049
00:47:12.826 --> 00:47:14.906
of the object they're
referring to drops to zero.

1050
00:47:15.686 --> 00:47:18.696
Now in this particular
case, they are tied together

1051
00:47:18.696 --> 00:47:19.646
so we don't have a problem.

1052
00:47:19.646 --> 00:47:21.206
But it allows us
to break the cycle

1053
00:47:21.206 --> 00:47:22.576
and actually get
the paper we want

1054
00:47:22.576 --> 00:47:26.486
when we release the
instance of our class.

1055
00:47:26.636 --> 00:47:29.536
So building on this, let's talk
about weak variables in general.

1056
00:47:30.666 --> 00:47:31.806
Consider this simple method

1057
00:47:31.806 --> 00:47:34.746
where we're logging the
description of a weak ivar.

1058
00:47:36.176 --> 00:47:37.576
Does this method
even called call?

1059
00:47:37.576 --> 00:47:39.096
What happens if the weak is nil?

1060
00:47:39.396 --> 00:47:41.196
You know, what actually
happens here?

1061
00:47:41.856 --> 00:47:45.876
How do we reason
about this at all?

1062
00:47:45.936 --> 00:47:49.526
Well, now the compiler
can warn about this saying

1063
00:47:50.246 --> 00:47:55.516
that we're using weak variable
and it may unpredictably be nil.

1064
00:47:56.686 --> 00:48:00.056
Well what do we do about this?

1065
00:47:56.686 --> 00:48:00.056
Well what do we do about this?

1066
00:48:00.266 --> 00:48:01.706
Well, it's actually
worst than that.

1067
00:48:01.706 --> 00:48:05.406
It can get-- we can have a
weak variable and use it twice.

1068
00:48:05.956 --> 00:48:08.606
Does this get called
zero, one or two times?

1069
00:48:08.886 --> 00:48:10.416
You know, how do we
reason about this?

1070
00:48:11.346 --> 00:48:13.296
Well there's actually a
solution for both of these

1071
00:48:13.436 --> 00:48:16.176
and I'd like to-- oh, sorry.

1072
00:48:17.106 --> 00:48:19.246
In the repeated use case, we
now have a specific warning

1073
00:48:19.246 --> 00:48:21.046
for that too pointing
out that, you know,

1074
00:48:21.116 --> 00:48:23.636
you can't actually reason about
the zero, one or two case.

1075
00:48:24.516 --> 00:48:28.716
[ Pause ]

1076
00:48:29.216 --> 00:48:33.656
So let's go back to the original
code and the original warning

1077
00:48:33.716 --> 00:48:34.826
and look at how we fix this.

1078
00:48:35.266 --> 00:48:39.826
Let's make some room and
do as the compiler advices

1079
00:48:39.826 --> 00:48:42.376
and put a local strong
variable on the stack,

1080
00:48:42.986 --> 00:48:45.056
assign our weak variable
into it.

1081
00:48:45.516 --> 00:48:46.566
And once we've done that,

1082
00:48:47.116 --> 00:48:50.506
that strong variable is
either nil or not nil.

1083
00:48:50.816 --> 00:48:52.106
It's not going to
change magically

1084
00:48:52.106 --> 00:48:53.106
out from underneath us.

1085
00:48:53.836 --> 00:48:56.156
And because we know that,
we can now test for it.

1086
00:48:56.156 --> 00:48:59.886
And if it's not nil, we can now
safely print the description.

1087
00:48:59.886 --> 00:49:02.736
And if we do that, of
course, the warning goes away.

1088
00:48:59.886 --> 00:49:02.736
And if we do that, of
course, the warning goes away.

1089
00:49:03.646 --> 00:49:06.786
So this is great.

1090
00:49:07.216 --> 00:49:10.126
We now can reason about the
lifetime of this variable.

1091
00:49:11.056 --> 00:49:14.396
And the great thing too is
handling the nil case becomes

1092
00:49:14.396 --> 00:49:15.086
very obvious.

1093
00:49:15.086 --> 00:49:20.716
We just add the else block
and do the right thing.

1094
00:49:20.936 --> 00:49:24.206
Next up in the Automatic
Reference Counting Improvements,

1095
00:49:24.476 --> 00:49:26.976
I'd like to talk
about the relationship

1096
00:49:27.066 --> 00:49:28.726
between ARC and CoreFoundation.

1097
00:49:29.296 --> 00:49:31.766
If you've already
been using ARC,

1098
00:49:31.766 --> 00:49:32.956
you may have been writing a code

1099
00:49:32.956 --> 00:49:34.946
like this every time you
interact with CoreFoundation.

1100
00:49:34.946 --> 00:49:38.836
You have a CFDictionary,
getting some value out of it.

1101
00:49:39.246 --> 00:49:43.736
And in order to help ARC reason
about the object lifetime,

1102
00:49:43.846 --> 00:49:46.756
we use a bridge cast saying
that there's no net change

1103
00:49:46.756 --> 00:49:47.696
in the reference count here.

1104
00:49:49.196 --> 00:49:52.546
This is required because
anytime we come in and out

1105
00:49:52.546 --> 00:49:54.396
of the ARC system, we
need the ARC compiler

1106
00:49:54.396 --> 00:49:55.926
to actually be tracking
the reference count

1107
00:49:55.926 --> 00:49:58.386
so that way objects live
only as long as they need to,

1108
00:49:58.386 --> 00:49:59.626
and no longer and no shorter.

1109
00:49:59.626 --> 00:50:06.836
We have a +1-- you can express
+1 to ARC via CFBridgingRetain.

1110
00:49:59.626 --> 00:50:06.836
We have a +1-- you can express
+1 to ARC via CFBridgingRetain.

1111
00:50:07.116 --> 00:50:09.116
You can express a decrement

1112
00:50:09.116 --> 00:50:11.376
of the reference count
via CFBridgingRelease.

1113
00:50:12.036 --> 00:50:18.976
And you can express a no
net change via bridge cast.

1114
00:50:19.156 --> 00:50:22.036
Well, you know, it's
great that we're using ARC

1115
00:50:22.036 --> 00:50:23.806
and we've been able
to make our CF code

1116
00:50:23.806 --> 00:50:25.386
and our Foundation
code work together,

1117
00:50:25.386 --> 00:50:26.926
but can we improve
this situation?

1118
00:50:27.816 --> 00:50:29.716
Well, CoreFoundation
actually has some really

1119
00:50:29.716 --> 00:50:30.796
strong conventions.

1120
00:50:31.296 --> 00:50:33.516
Create and copy methods
return +1

1121
00:50:33.816 --> 00:50:35.526
and everything else returns +0.

1122
00:50:36.456 --> 00:50:39.596
And in fact, we already have
some compiler attributes

1123
00:50:39.596 --> 00:50:42.026
for the exceptions,
like CF RETUNS RETAINED

1124
00:50:42.026 --> 00:50:46.806
and CF RETURNS NOT RETAINED and
CF releases argument for APIs

1125
00:50:46.806 --> 00:50:48.466
that consume their argument.

1126
00:50:49.416 --> 00:50:52.236
And these are there to
help the static analyzer

1127
00:50:52.236 --> 00:50:53.986
and you may have already
seen this kick in,

1128
00:50:53.986 --> 00:50:55.536
in your use of the
static analyzer.

1129
00:50:56.326 --> 00:51:00.696
Well, what if we can just
use these conventions

1130
00:50:56.326 --> 00:51:00.696
Well, what if we can just
use these conventions

1131
00:51:00.696 --> 00:51:03.146
to make this bridge
cast go away?

1132
00:51:04.186 --> 00:51:07.376
In fact, we've formalized
the everything else cast now.

1133
00:51:08.406 --> 00:51:13.096
The common CF APIs you use
now allow implicit bridging

1134
00:51:13.096 --> 00:51:14.846
as opposed to this
explicit bridging.

1135
00:51:15.516 --> 00:51:21.086
[ Applause ]

1136
00:51:21.586 --> 00:51:24.286
There are new macros
available for use too.

1137
00:51:24.286 --> 00:51:26.336
And with that, I'd like to
show you how this works.

1138
00:51:27.126 --> 00:51:29.656
So, how do we enable
implicit bridging?

1139
00:51:30.206 --> 00:51:34.706
Let's imagine we're wrapping
a CoreFoundation Array

1140
00:51:34.706 --> 00:51:36.066
and we have our example
Foo that--

1141
00:51:36.066 --> 00:51:37.896
we have just bunch of
wrappers around the array.

1142
00:51:39.376 --> 00:51:41.716
Well the first API we
have here is great.

1143
00:51:41.716 --> 00:51:43.876
It follows the convention
as copying the name.

1144
00:51:44.266 --> 00:51:45.456
We don't need to do anything.

1145
00:51:46.856 --> 00:51:48.606
The second API is also great.

1146
00:51:48.756 --> 00:51:49.756
We don't need to anything

1147
00:51:49.756 --> 00:51:50.956
because it follows
the convention.

1148
00:51:50.956 --> 00:51:51.936
It returns +1.

1149
00:51:51.936 --> 00:51:53.316
It doesn't consume
any arguments.

1150
00:51:54.376 --> 00:51:57.176
But our third API, we don't
know what we were thinking.

1151
00:51:57.176 --> 00:52:01.486
We decided that we're going
to return retained and--

1152
00:51:57.176 --> 00:52:01.486
We decided that we're going
to return retained and--

1153
00:52:01.746 --> 00:52:03.136
but we're following
the convention.

1154
00:52:03.756 --> 00:52:07.936
Well, what we need to do is put
a CF RETURNS RETAINED attribute

1155
00:52:07.976 --> 00:52:13.016
there via macro and let the
compiler know what's going on.

1156
00:52:13.576 --> 00:52:14.966
Even if we just stop
here and do this,

1157
00:52:14.966 --> 00:52:17.496
we've already help the static
analyzer reason about our code.

1158
00:52:18.066 --> 00:52:20.196
But once we're done auditing,

1159
00:52:20.196 --> 00:52:22.886
what we can do is
add these macros,

1160
00:52:22.936 --> 00:52:26.786
CF IMPLICIT BRIDGING ENABLED and
CF IMPLICIT BRIDGING DISABLED

1161
00:52:26.986 --> 00:52:29.246
to tell the compiler
that we've audited code.

1162
00:52:30.586 --> 00:52:33.636
Now, this must be
after all #includes.

1163
00:52:33.766 --> 00:52:36.006
Obviously, you're not
auditing somebody else's code.

1164
00:52:36.006 --> 00:52:37.226
You're auditing your code.

1165
00:52:38.476 --> 00:52:40.696
And you don't have to
do it around everything.

1166
00:52:40.696 --> 00:52:42.526
If there's code you don't
want to think about right now,

1167
00:52:42.526 --> 00:52:45.466
you could have the explicitly
bridge code remain outside

1168
00:52:45.466 --> 00:52:48.346
of the macros they are using.

1169
00:52:49.786 --> 00:52:51.576
And that is implicit bridging

1170
00:52:51.576 --> 00:52:54.736
and this is all the
common CF plist types

1171
00:52:54.776 --> 00:52:57.876
or have been auditing and you
can go remove this bridge cast

1172
00:52:57.876 --> 00:53:00.316
from your code if you're
using the new SDKs.

1173
00:52:57.876 --> 00:53:00.316
from your code if you're
using the new SDKs.

1174
00:53:00.836 --> 00:53:04.656
So to wrap up, we have Modules.

1175
00:53:05.206 --> 00:53:08.696
This is really great for finally
fixing the textual inclusion

1176
00:53:08.696 --> 00:53:11.236
problem and all the
associated bugs.

1177
00:53:11.706 --> 00:53:13.536
It also adds great performance

1178
00:53:13.536 --> 00:53:15.986
for compilation time
and indexing.

1179
00:53:16.596 --> 00:53:19.076
And it's just a much more
pleasurable experience

1180
00:53:19.076 --> 00:53:20.246
with features like Autolinking.

1181
00:53:20.826 --> 00:53:22.246
We also have improved
productivity

1182
00:53:22.246 --> 00:53:25.946
with better compiler warnings
throughout the SDK adoption

1183
00:53:25.946 --> 00:53:28.686
of these compiler warnings to
help you catch errors early

1184
00:53:29.106 --> 00:53:30.696
and write more productive code.

1185
00:53:31.326 --> 00:53:33.176
And with ARC, we've made
it better and faster

1186
00:53:33.176 --> 00:53:37.356
by allowing you to better
reason about simple retain cycle

1187
00:53:37.356 --> 00:53:40.386
and weak reference bugs,
and also easier in the fact

1188
00:53:40.386 --> 00:53:42.316
that you no longer need
to write bridge cast

1189
00:53:42.316 --> 00:53:45.046
for common CF plist types.

1190
00:53:45.236 --> 00:53:46.986
For more information,
I'd like to point you

1191
00:53:47.086 --> 00:53:48.596
at Dave DeLong, our evangelist.

1192
00:53:49.576 --> 00:53:51.016
We also have tons
of documentation

1193
00:53:51.016 --> 00:53:54.816
on the developer website and
of course the Developer Forums.

1194
00:53:55.576 --> 00:53:58.376
We have two labs,
one tomorrow morning

1195
00:53:58.376 --> 00:54:00.156
and one Thursday afternoon.

1196
00:53:58.376 --> 00:54:00.156
and one Thursday afternoon.

1197
00:54:01.326 --> 00:54:02.666
Oh sorry, related sessions.

1198
00:54:03.006 --> 00:54:04.816
We have What's New
in LLVM Compiler,

1199
00:54:04.816 --> 00:54:07.146
it happened earlier today, you
have to catch them on video.

1200
00:54:07.196 --> 00:54:10.136
But tomorrow, we have
Optimize Your Code Using LLVM

1201
00:54:10.226 --> 00:54:12.306
in Nob Hill at 3:30.

1202
00:54:12.656 --> 00:54:13.706
So, thanks for coming.

1203
00:54:14.516 --> 00:54:21.840
[ Applause ]
