
1
00:00:13.536 --> 00:00:14.126
>> All right.

2
00:00:14.166 --> 00:00:15.086
Good morning, everyone.

3
00:00:15.356 --> 00:00:17.046
Good to see you all
here bright and early.

4
00:00:17.256 --> 00:00:20.216
We're here today to talk to
you about internationalization.

5
00:00:21.786 --> 00:00:24.046
Now if you've been
following along

6
00:00:24.046 --> 00:00:25.346
with our previous years' talks

7
00:00:25.346 --> 00:00:26.836
on international
support then you know

8
00:00:26.836 --> 00:00:28.836
that the App Store
is available in many,

9
00:00:28.836 --> 00:00:31.936
many countries worldwide,
more than 150 by last count.

10
00:00:32.646 --> 00:00:35.476
So I'm sure you've all
made your apps localizable,

11
00:00:35.476 --> 00:00:37.496
so you can send them
out to localizers

12
00:00:37.496 --> 00:00:40.126
and make them available
in multiple languages.

13
00:00:41.246 --> 00:00:42.456
Is that sufficient though?

14
00:00:42.726 --> 00:00:44.676
Well, not necessarily.

15
00:00:45.166 --> 00:00:48.956
You need to take some care with
regard to internationalization,

16
00:00:49.426 --> 00:00:53.056
otherwise you might end up
with complaints like say,

17
00:00:54.176 --> 00:00:57.676
half of the contact names show
up backwards in their app.

18
00:00:57.676 --> 00:01:00.326
Or, the dates in this
application are unreadable.

19
00:00:57.676 --> 00:01:00.326
Or, the dates in this
application are unreadable.

20
00:01:00.326 --> 00:01:02.146
Or, my text is all messed up.

21
00:01:03.176 --> 00:01:06.546
Working in this area we've seen
problems like this occur many,

22
00:01:06.546 --> 00:01:09.406
many times, and we're here today
to tell you how to fix them.

23
00:01:09.406 --> 00:01:13.436
What we're going to
do is, first of all,

24
00:01:13.876 --> 00:01:15.936
we'll run through what
we have that's new

25
00:01:15.936 --> 00:01:18.906
in international support
in Yosemite and iOS 8.

26
00:01:19.446 --> 00:01:22.266
Then we'll go into
detail about language

27
00:01:22.266 --> 00:01:23.536
and locale when you use what.

28
00:01:23.666 --> 00:01:25.166
And then we're going
to run through a number

29
00:01:25.166 --> 00:01:28.136
of case studies,
problems that we've seen

30
00:01:28.456 --> 00:01:32.736
in internationalization
and how to fix them.

31
00:01:32.976 --> 00:01:36.016
So let's start off with what's
new in internationalization

32
00:01:36.386 --> 00:01:38.486
and the latest releases
of our operating systems.

33
00:01:38.486 --> 00:01:41.686
We have a number of nice, new
features, both at the user level

34
00:01:41.906 --> 00:01:44.076
and in APIs at the
developer level.

35
00:01:44.076 --> 00:01:46.886
So at the user level
we have for iOS,

36
00:01:46.886 --> 00:01:51.446
a number of new localizations
and some new keyboards.

37
00:01:51.736 --> 00:01:54.616
We've redone the iOS
language and region settings.

38
00:01:55.916 --> 00:01:58.466
And we have some
new improvements

39
00:01:58.466 --> 00:01:59.736
to lunar Calendar support.

40
00:02:00.266 --> 00:02:04.346
Then in API at the developer
level, we have an API

41
00:02:04.346 --> 00:02:05.946
for string encoding detection.

42
00:02:06.806 --> 00:02:08.765
We have some interesting
new formatters

43
00:02:08.846 --> 00:02:11.926
and something new called
formatting context,

44
00:02:11.926 --> 00:02:13.336
which I'll go into
in a few minutes.

45
00:02:14.736 --> 00:02:16.546
So let's start with
the new localizations

46
00:02:16.546 --> 00:02:18.036
and keyboards we have for iOS.

47
00:02:18.036 --> 00:02:21.126
We have new localizations for
Hindi, for Indian English,

48
00:02:21.126 --> 00:02:25.786
Canadian French, and Hong Kong
Chinese, and some new keyboards.

49
00:02:25.786 --> 00:02:29.856
First of all, for three Indic
languages, Bengali, Marathi

50
00:02:29.856 --> 00:02:32.936
and Urdu, to go along
with our existing Hindi

51
00:02:32.936 --> 00:02:34.116
and Tamil keyboards.

52
00:02:34.116 --> 00:02:36.516
And we also have keyboards
for Indian English,

53
00:02:36.516 --> 00:02:38.066
Filipino and Slovenian.

54
00:02:38.766 --> 00:02:42.866
And there are a number of
other new things like new fonts

55
00:02:43.136 --> 00:02:44.906
for various scripts worldwide.

56
00:02:47.106 --> 00:02:48.776
Second, so you may recall

57
00:02:48.776 --> 00:02:50.686
that in Mavericks we
redid the language

58
00:02:50.686 --> 00:02:52.046
and region settings for OS X.

59
00:02:52.046 --> 00:02:54.636
Well this time around,
it's the turn of iOS.

60
00:02:54.636 --> 00:02:57.826
And in iOS 8, we've redone the
language and region settings,

61
00:02:58.316 --> 00:03:00.936
and they look something
like this now.

62
00:02:58.316 --> 00:03:00.936
and they look something
like this now.

63
00:03:01.316 --> 00:03:04.386
So you can still as always
specify the primary language

64
00:03:04.386 --> 00:03:05.146
for localization.

65
00:03:06.336 --> 00:03:09.536
But now in addition, in
iOS you can also specify,

66
00:03:09.576 --> 00:03:11.836
users can specify the whole list

67
00:03:11.836 --> 00:03:13.606
of their preferred
languages in order.

68
00:03:14.186 --> 00:03:18.506
So one thing this allows you
to do is to localize your apps

69
00:03:18.836 --> 00:03:22.616
into localizations for which
Apple does not provide a primary

70
00:03:22.696 --> 00:03:26.376
OS localization simply because
the users can specify those

71
00:03:26.376 --> 00:03:28.666
ahead of one of the
localizations

72
00:03:28.666 --> 00:03:30.346
that Apple provides, and
then your app will run

73
00:03:30.346 --> 00:03:34.406
in those languages for
the users who need that.

74
00:03:34.616 --> 00:03:36.336
There also is an
advanced setting

75
00:03:36.336 --> 00:03:38.746
that allows specifying
the language

76
00:03:38.746 --> 00:03:40.466
of the region format
independently

77
00:03:40.876 --> 00:03:41.996
of the localization.

78
00:03:43.316 --> 00:03:45.486
We make them the
same by default,

79
00:03:45.486 --> 00:03:47.466
but users can change
them if they like.

80
00:03:47.466 --> 00:03:50.336
And we'll go into that
in more detail later on.

81
00:03:51.456 --> 00:03:54.176
We have some improvements to
our support for lunar calendars.

82
00:03:54.626 --> 00:03:59.186
So in our Calendar applications,
we now have the support

83
00:03:59.186 --> 00:04:03.586
for turning on, as an
overlay, lunar calendar dates

84
00:03:59.186 --> 00:04:03.586
for turning on, as an
overlay, lunar calendar dates

85
00:04:03.586 --> 00:04:05.806
in addition to Gregorian dates.

86
00:04:06.196 --> 00:04:09.096
We also have a couple
of new Calendar options.

87
00:04:09.096 --> 00:04:11.066
These are variants on
the Islamic calendar.

88
00:04:11.366 --> 00:04:13.976
Let's take a little
closer look at what the,

89
00:04:13.976 --> 00:04:18.716
so this is Calendar app
with Chinese calendar,

90
00:04:19.036 --> 00:04:20.666
lunar calendar dates, turned on.

91
00:04:20.666 --> 00:04:23.716
You see, they show up as an
overlay underneath the Gregorian

92
00:04:23.716 --> 00:04:24.156
dates here.

93
00:04:24.156 --> 00:04:27.426
It's very useful for
Chinese customers.

94
00:04:28.596 --> 00:04:30.636
And here's what this
looks like in OS X.

95
00:04:31.996 --> 00:04:33.986
And see here the
Gregorian dates on the right

96
00:04:33.986 --> 00:04:35.966
and the lunar calendar
dates on the left.

97
00:04:36.836 --> 00:04:41.996
At the API level, these
are APIs available

98
00:04:41.996 --> 00:04:46.386
at the foundation level
on both iOS and OS X.

99
00:04:46.386 --> 00:04:48.986
So you may recall from some
previous years' text sessions,

100
00:04:48.986 --> 00:04:51.736
we talked about the unfortunate
situation that can occur

101
00:04:52.076 --> 00:04:55.996
when you have a TXT file or some
other chunk of external text

102
00:04:56.356 --> 00:04:58.966
and you don't happen to
know what encoding it's in.

103
00:04:59.556 --> 00:05:03.516
Well, in that case, you may
have no other option but to try

104
00:04:59.556 --> 00:05:03.516
Well, in that case, you may
have no other option but to try

105
00:05:03.516 --> 00:05:05.806
to guess the encoding
from the text.

106
00:05:06.346 --> 00:05:10.676
We now have a specific API to do
that automatically for you based

107
00:05:10.676 --> 00:05:12.886
on all the evidence that's
available from the text.

108
00:05:14.086 --> 00:05:15.386
And it's very handy.

109
00:05:15.386 --> 00:05:16.566
There are lots of options.

110
00:05:16.886 --> 00:05:20.186
You can have it do the whole
conversion for you once,

111
00:05:20.186 --> 00:05:22.286
or just tell you what it
thinks the encoding is.

112
00:05:23.426 --> 00:05:26.286
You can have lossy or
non-lossy conversion.

113
00:05:26.586 --> 00:05:29.286
And if you happen to think you
known what encoding it's likely

114
00:05:29.286 --> 00:05:32.696
to be in, you can specify those,
or you can require it to be one

115
00:05:32.696 --> 00:05:34.516
of a certain list of encodings.

116
00:05:36.586 --> 00:05:38.806
We also have a number
of nice, new formatters.

117
00:05:39.536 --> 00:05:42.076
So NSDateFormatter is great
if the thing you're trying

118
00:05:42.076 --> 00:05:46.056
to format is a date, a
particular moment in time.

119
00:05:46.676 --> 00:05:49.946
But what if what you're trying
to format is more like an amount

120
00:05:49.946 --> 00:05:51.446
of time, extent, or an interval.

121
00:05:52.466 --> 00:05:54.616
We have
NSDateComponentsFormatter

122
00:05:54.996 --> 00:05:59.966
for displaying durations or
amounts of time, number of hours

123
00:05:59.966 --> 00:06:01.736
or minutes or weeks
or what have you.

124
00:05:59.966 --> 00:06:01.736
or minutes or weeks
or what have you.

125
00:06:03.266 --> 00:06:06.146
You can specify the amount
of time either as a start

126
00:06:06.146 --> 00:06:09.426
and an end date or a time
interval, or you can specify all

127
00:06:09.426 --> 00:06:11.036
of the components
individually if you like.

128
00:06:12.006 --> 00:06:14.086
Then you can specify how
it's supposed to be formatted

129
00:06:14.366 --> 00:06:17.666
with one of a list of
date and time styles.

130
00:06:18.086 --> 00:06:20.676
And you can also get
to specify exactly

131
00:06:20.756 --> 00:06:22.896
which of the components
you want displayed.

132
00:06:24.376 --> 00:06:26.066
And there are some
interesting things too.

133
00:06:26.476 --> 00:06:29.296
You can turn on, in a
locale-sensitive way,

134
00:06:29.296 --> 00:06:33.826
you can add language to it that
says "about" a certain amount

135
00:06:33.826 --> 00:06:35.426
of time, if this is
an approximate time.

136
00:06:35.566 --> 00:06:39.616
Or the locale-sensitive
way of saying "remaining".

137
00:06:39.616 --> 00:06:42.266
For example, if this is a sort
of countdown of some sort.

138
00:06:42.836 --> 00:06:46.236
So here are some examples of
this in various languages.

139
00:06:46.606 --> 00:06:49.346
You can as I say,
choose various styles,

140
00:06:49.346 --> 00:06:52.406
either a lengthy spell-out kind
of style, something shorter,

141
00:06:52.406 --> 00:06:53.916
something very short
and numerical only.

142
00:06:54.286 --> 00:06:56.866
And the last line shows
the "about" option.

143
00:06:57.806 --> 00:07:01.986
Now one thing I want you
to notice here is that some

144
00:06:57.806 --> 00:07:01.986
Now one thing I want you
to notice here is that some

145
00:07:01.986 --> 00:07:05.126
of these have their
first word capitalized.

146
00:07:05.486 --> 00:07:06.406
Well that's appropriate

147
00:07:06.406 --> 00:07:07.886
since they're showing
up in the table here.

148
00:07:08.786 --> 00:07:12.946
But there are other contexts
where you might want these not

149
00:07:12.946 --> 00:07:14.096
to have the first
word capitalized,

150
00:07:14.096 --> 00:07:16.376
say if they were showing up
in the middle of a sentence.

151
00:07:17.016 --> 00:07:19.746
And I'll talk about that
more in just a minute.

152
00:07:19.746 --> 00:07:25.076
Another new formatter,
NSDateIntervalFormatter,

153
00:07:25.596 --> 00:07:29.226
if what you're trying to
display is a range of times

154
00:07:30.026 --> 00:07:33.836
from some beginning time or
date to some end time or date,

155
00:07:34.236 --> 00:07:37.366
you might want in
this case to say,

156
00:07:37.706 --> 00:07:41.346
not to shown only once
the pieces that are common

157
00:07:41.446 --> 00:07:43.026
to the start and end date.

158
00:07:43.026 --> 00:07:44.856
NSDateIntervalFormatter
will do that for you.

159
00:07:45.746 --> 00:07:47.556
You provide the start
date and the end date.

160
00:07:48.666 --> 00:07:53.286
You can specify again any of
a list of date or time styles

161
00:07:53.586 --> 00:07:57.766
or a template for full control
over which pieces get displayed.

162
00:07:58.846 --> 00:08:00.366
So here are some
examples of this.

163
00:07:58.846 --> 00:08:00.366
So here are some
examples of this.

164
00:08:00.516 --> 00:08:01.966
And again, in various languages,

165
00:08:02.286 --> 00:08:05.046
so you can see it can
show a range of dates,

166
00:08:05.046 --> 00:08:07.836
or a range of times, or a
range of dates and times,

167
00:08:08.306 --> 00:08:12.306
and appropriately the pieces
that are common to the start

168
00:08:12.306 --> 00:08:14.506
and end are only shown once.

169
00:08:16.796 --> 00:08:22.376
We also have some specific
formatters for particular kinds

170
00:08:22.416 --> 00:08:24.166
of quantities: energy,
length and mass.

171
00:08:25.146 --> 00:08:26.576
That's NSEnergyFormatter,

172
00:08:26.576 --> 00:08:28.206
NSLengthFormatter,
NSMassFormatter.

173
00:08:28.446 --> 00:08:31.376
This is very useful, for
example, if you're working

174
00:08:31.376 --> 00:08:34.395
with HealthKit and you're
trying to display, say,

175
00:08:35.066 --> 00:08:36.905
the number of calories
a person has consumed,

176
00:08:36.905 --> 00:08:38.885
or how tall they are,
how far they run,

177
00:08:38.885 --> 00:08:40.216
or how much they weigh.

178
00:08:42.056 --> 00:08:46.276
And it will show these numeric
parts plus a localized unit.

179
00:08:46.746 --> 00:08:48.836
You can specify the
exact unit you want,

180
00:08:48.836 --> 00:08:51.746
or you can request
locale-appropriate unit,

181
00:08:51.746 --> 00:08:53.886
whatever's standard in
that particular locale.

182
00:08:54.356 --> 00:08:56.326
There's a number
formatter attached to it,

183
00:08:56.566 --> 00:08:58.546
so you can use all the
number formatter options

184
00:08:58.546 --> 00:08:59.856
for formatting the numeric part.

185
00:09:00.986 --> 00:09:03.016
And there's a special
option you can check

186
00:09:03.386 --> 00:09:05.796
if that mass is particularly
for a person's weight

187
00:09:05.796 --> 00:09:07.206
or if the energy is
particularly for food

188
00:09:07.206 --> 00:09:11.466
because there may be particular
standards for displaying those.

189
00:09:12.106 --> 00:09:18.016
So here are some examples of
that in various languages.

190
00:09:18.056 --> 00:09:24.206
You can see that the units
vary, and the numbers,

191
00:09:24.456 --> 00:09:29.056
you can choose an
appropriate format for those.

192
00:09:29.836 --> 00:09:31.716
Finally, formatting context.

193
00:09:32.006 --> 00:09:34.816
Now remember as I mentioned
before, you may need

194
00:09:34.816 --> 00:09:37.826
to have a piece of
text that's formatted.

195
00:09:37.826 --> 00:09:39.946
You might want to capitalize
differently depending

196
00:09:39.946 --> 00:09:41.036
on where it's showing up.

197
00:09:41.906 --> 00:09:44.556
And for some languages there
are other transformations

198
00:09:44.556 --> 00:09:48.826
that may need to apply depending
on where it shows up in your UI.

199
00:09:49.136 --> 00:09:52.296
So we have a new property of
formatting context available

200
00:09:52.296 --> 00:09:54.886
for date and number formatter
and date components formatter

201
00:09:54.886 --> 00:09:56.276
and byte count formatter
currently.

202
00:09:57.226 --> 00:09:59.136
It's the formatting
context property.

203
00:09:59.336 --> 00:10:02.706
It's one of an enumerated
set of values to specify

204
00:09:59.336 --> 00:10:02.706
It's one of an enumerated
set of values to specify

205
00:10:03.066 --> 00:10:05.226
where this formatted
thing is supposed to end

206
00:10:06.106 --> 00:10:07.676
up so it can be capitalized

207
00:10:07.676 --> 00:10:11.596
or otherwise appropriately
changed for its context.

208
00:10:12.166 --> 00:10:14.466
You can choose the standalone
context, for example,

209
00:10:14.466 --> 00:10:16.526
if it's going to appear
by itself in a field.

210
00:10:17.446 --> 00:10:18.896
So that might be capitalized.

211
00:10:19.366 --> 00:10:22.146
The list item context, say,
if it's going to be in a menu

212
00:10:22.146 --> 00:10:23.036
or something like that.

213
00:10:24.216 --> 00:10:25.636
The beginning of
sentence context,

214
00:10:26.046 --> 00:10:27.876
again usually capitalized.

215
00:10:28.946 --> 00:10:32.176
And the middle of the sentence
context probably will not

216
00:10:32.176 --> 00:10:33.076
be capitalized.

217
00:10:33.446 --> 00:10:38.136
But, it may happen that your
formatted result is going

218
00:10:38.136 --> 00:10:40.166
to show up, it's
going to be inserted

219
00:10:40.166 --> 00:10:43.126
into a localized string, and
you don't know a priority

220
00:10:43.126 --> 00:10:45.746
without having that localized
string yet whether it's going

221
00:10:45.746 --> 00:10:47.296
to be at the start or
somewhere in the middle.

222
00:10:48.046 --> 00:10:50.966
So we have another
value, the dynamic value.

223
00:10:51.256 --> 00:10:54.246
You just specify that and
then once it's inserted

224
00:10:54.296 --> 00:10:58.296
into that format string,
it gets automatically,

225
00:10:58.486 --> 00:11:01.276
it automatically detects whether
it's a start or in the middle,

226
00:10:58.486 --> 00:11:01.276
it automatically detects whether
it's a start or in the middle,

227
00:11:01.276 --> 00:11:02.676
and it will capitalize it

228
00:11:02.676 --> 00:11:06.536
or otherwise change it
appropriately automatically.

229
00:11:08.186 --> 00:11:09.186
So that's what new.

230
00:11:09.736 --> 00:11:12.546
And now I'm going to bring up
my colleague, Deborah Goldsmith

231
00:11:12.626 --> 00:11:16.756
to go into detail about
languages and locales.

232
00:11:17.606 --> 00:11:18.846
>> Thanks, Doug.

233
00:11:20.236 --> 00:11:21.316
Hi, everybody.

234
00:11:21.596 --> 00:11:25.156
Today we're going to talk
about languages and locales,

235
00:11:25.256 --> 00:11:27.906
the differences between
them, and how to use them.

236
00:11:29.316 --> 00:11:31.526
So Doug just showed
us the new language

237
00:11:31.526 --> 00:11:33.556
and region settings in iOS 8.

238
00:11:34.066 --> 00:11:35.666
Here you can see an example.

239
00:11:35.666 --> 00:11:38.216
On the left there's
the language settings.

240
00:11:38.456 --> 00:11:41.296
And you can see there's a list
of three languages, English,

241
00:11:41.356 --> 00:11:43.746
simplified Chinese, and
traditional Chinese.

242
00:11:44.366 --> 00:11:46.866
On the right, you see the
Region or Locale setting,

243
00:11:47.346 --> 00:11:50.286
and that's showing a region
of United States which,

244
00:11:50.286 --> 00:11:53.346
together with English, makes
a locale of U.S. English.

245
00:11:54.206 --> 00:11:56.836
So, why are there
two preferences?

246
00:11:56.836 --> 00:11:57.726
What are they used for?

247
00:11:58.436 --> 00:12:00.636
Well, the language
setting keeps track

248
00:11:58.436 --> 00:12:00.636
Well, the language
setting keeps track

249
00:12:00.636 --> 00:12:03.656
of which languages the
user prefers to use.

250
00:12:04.246 --> 00:12:07.086
The Region or Locale
setting keeps track

251
00:12:07.086 --> 00:12:09.686
of which regional conventions
they want to follow.

252
00:12:10.496 --> 00:12:12.206
It's worth pointing
out that neither

253
00:12:12.206 --> 00:12:15.936
of these indicates the language
that users use in documents.

254
00:12:15.936 --> 00:12:17.556
That might be the same language,

255
00:12:17.586 --> 00:12:19.516
but it might be something
completely different.

256
00:12:19.696 --> 00:12:22.136
And we'll talk more about
that a little later on.

257
00:12:24.416 --> 00:12:26.916
So, let's look a
little more closely

258
00:12:26.916 --> 00:12:28.676
at the preferred language list.

259
00:12:30.316 --> 00:12:31.076
What uses it?

260
00:12:31.646 --> 00:12:33.366
Well, probably the
most important thing

261
00:12:33.366 --> 00:12:35.856
that uses the preferred
language list is NSBundle.

262
00:12:36.306 --> 00:12:39.566
It uses that information
to pick the localization

263
00:12:40.036 --> 00:12:42.026
that your app uses when it runs.

264
00:12:43.376 --> 00:12:45.096
But it's also used by NSString.

265
00:12:45.436 --> 00:12:49.476
NSString has several
language-sensitive operations

266
00:12:49.476 --> 00:12:53.316
such as localized string
comparison or breaking text

267
00:12:53.316 --> 00:12:54.846
into words or sentences.

268
00:12:55.306 --> 00:12:59.106
And NSString uses the preferred
language list to determine

269
00:12:59.106 --> 00:13:00.536
which language to use for that.

270
00:12:59.106 --> 00:13:00.536
which language to use for that.

271
00:13:01.496 --> 00:13:02.976
It's also used by WebKit.

272
00:13:03.536 --> 00:13:06.666
Every time WebKit sends a
request to a web server,

273
00:13:07.246 --> 00:13:11.166
it includes in the HTTP header
a field called Accept-Language,

274
00:13:11.416 --> 00:13:13.666
which is essentially the
preferred language list.

275
00:13:14.076 --> 00:13:16.856
The web server looks at
that information and uses it

276
00:13:16.856 --> 00:13:21.386
to decide which language to
use for the page it sends back.

277
00:13:23.156 --> 00:13:25.286
The list is in preference order

278
00:13:25.646 --> 00:13:27.766
from the user's most
preferred language

279
00:13:27.766 --> 00:13:29.806
to the one they want
to see last.

280
00:13:30.346 --> 00:13:33.256
Any languages that the
user is not interested

281
00:13:33.256 --> 00:13:34.916
in don't appear in
the list at all.

282
00:13:35.896 --> 00:13:38.776
So, effectively, it's a little
more complicated than this,

283
00:13:38.806 --> 00:13:41.986
but effectively what apps
and websites do is step

284
00:13:41.986 --> 00:13:44.646
through the list in
order, and they look

285
00:13:44.646 --> 00:13:46.806
for the first language
that they support.

286
00:13:47.596 --> 00:13:49.776
And then they use that
as their localization.

287
00:13:50.176 --> 00:13:52.416
If they don't find a
language that they support,

288
00:13:52.966 --> 00:13:55.146
then they'll use a
default that depends

289
00:13:55.146 --> 00:13:57.396
on the particular
application or website.

290
00:13:58.206 --> 00:14:02.226
By contrast, NSString will
use the very first language

291
00:13:58.206 --> 00:14:02.226
By contrast, NSString will
use the very first language

292
00:14:02.226 --> 00:14:04.476
in the list always
as the language

293
00:14:04.476 --> 00:14:06.606
for language-sensitive
operations.

294
00:14:07.976 --> 00:14:10.376
It's worth pointing out that

295
00:14:11.026 --> 00:14:13.246
when the user changes
the language preference,

296
00:14:13.856 --> 00:14:16.606
apps don't pick it up until
the next time they restart.

297
00:14:16.656 --> 00:14:20.106
So, they'll keep using the old
setting until that happens.

298
00:14:21.916 --> 00:14:25.266
So now let's talk about the
Locale or Region setting

299
00:14:25.266 --> 00:14:28.676
in a little bit more detail
and see what it's used for.

300
00:14:30.296 --> 00:14:33.796
Well, most importantly,
it's used for the locale,

301
00:14:33.796 --> 00:14:35.416
in particular, the
current locale.

302
00:14:35.516 --> 00:14:37.806
It determines the
properties of that locale,

303
00:14:38.366 --> 00:14:39.926
many different properties

304
00:14:39.926 --> 00:14:42.606
that determine the
regional conventions.

305
00:14:43.886 --> 00:14:46.896
In turn, that controls the
behavior of formatters,

306
00:14:46.896 --> 00:14:50.826
both the familiar daytime and
number formatters that have been

307
00:14:50.826 --> 00:14:54.146
around for a while, and
also all the new formatters

308
00:14:54.146 --> 00:14:55.366
that Doug just talked about.

309
00:14:56.346 --> 00:14:59.966
It controls the behavior of
calendars, both the calendar

310
00:14:59.966 --> 00:15:01.706
that you're using, for example,

311
00:14:59.966 --> 00:15:01.706
that you're using, for example,

312
00:15:02.066 --> 00:15:05.456
you might use the Gregorian
calendar in one country

313
00:15:05.806 --> 00:15:07.296
or the Thai Buddhist calendar.

314
00:15:08.086 --> 00:15:10.776
But it also controls
other calendar aspects

315
00:15:10.776 --> 00:15:13.076
such as what's the
first day of the week?

316
00:15:13.076 --> 00:15:15.156
Is it Monday, Sunday
or something else?

317
00:15:15.786 --> 00:15:19.496
Now in contrast to the
language preference,

318
00:15:20.666 --> 00:15:23.336
when the user changes
the locale preference,

319
00:15:23.736 --> 00:15:25.406
apps don't need to restart.

320
00:15:25.406 --> 00:15:27.906
They're supposed to pick up
that new setting right away.

321
00:15:28.296 --> 00:15:33.486
And we'll talk a little bit
more later on on how to do that.

322
00:15:34.006 --> 00:15:36.046
So, what is the locale anyway?

323
00:15:36.646 --> 00:15:39.756
Earlier we saw one example
of the U.S. English locale.

324
00:15:40.096 --> 00:15:42.326
There was a language,
and there was a region.

325
00:15:42.956 --> 00:15:46.116
But locales can have
many more attributes.

326
00:15:46.416 --> 00:15:48.186
There can be an optional script.

327
00:15:48.286 --> 00:15:51.056
For example, you might need
to indicate whether you want

328
00:15:51.056 --> 00:15:54.716
to use Arabic or Cyrillic script
with a particular language.

329
00:15:55.486 --> 00:15:57.786
There can also be keywords added

330
00:15:57.786 --> 00:16:00.196
which fine-tune the
behavior of the locale.

331
00:15:57.786 --> 00:16:00.196
which fine-tune the
behavior of the locale.

332
00:16:00.926 --> 00:16:03.226
So let's look at one
hypothetical example.

333
00:16:03.776 --> 00:16:06.566
Let's look at a particular
user's current locale

334
00:16:06.946 --> 00:16:08.976
and print out its identifier.

335
00:16:10.146 --> 00:16:11.006
There it is.

336
00:16:11.526 --> 00:16:15.186
So, let's pick it apart and
see what each part means.

337
00:16:16.086 --> 00:16:17.786
So the first part
is the language.

338
00:16:17.886 --> 00:16:19.316
That's Urdu, in this case.

339
00:16:20.046 --> 00:16:24.456
The region is India, so what
the user is saying is they want

340
00:16:24.456 --> 00:16:28.646
to see their dates, times and
so forth in the Urdu language

341
00:16:28.646 --> 00:16:31.216
and following the regional
conventions of India.

342
00:16:32.546 --> 00:16:35.656
But the user also has some
keywords to do some overrides

343
00:16:35.656 --> 00:16:38.496
of the default for
that particular locale.

344
00:16:38.936 --> 00:16:41.756
For example, the
default calendar

345
00:16:41.756 --> 00:16:44.246
in India is the Gregorian
calendar.

346
00:16:44.626 --> 00:16:47.436
But this user wants to
use the Islamic calendar.

347
00:16:47.846 --> 00:16:49.206
Perhaps they do a
lot of business

348
00:16:49.206 --> 00:16:50.446
with people in the Middle East.

349
00:16:51.916 --> 00:16:55.026
In addition, the default
currency for India is the Rupee,

350
00:16:55.296 --> 00:16:58.376
but this user says they
want to use the U.S. dollar

351
00:16:58.376 --> 00:16:59.566
as their default currency.

352
00:16:59.806 --> 00:17:02.766
Again, perhaps because they do
a lot of international business.

353
00:16:59.806 --> 00:17:02.766
Again, perhaps because they do
a lot of international business.

354
00:17:05.556 --> 00:17:08.056
So locales have a lot
of information in them,

355
00:17:08.236 --> 00:17:10.566
but you shouldn't get
all the information

356
00:17:10.566 --> 00:17:11.986
that you need out of the locale.

357
00:17:12.445 --> 00:17:14.336
There are some things you
should get from elsewhere.

358
00:17:15.316 --> 00:17:18.796
So, you might think that because
there's a region in the locale

359
00:17:19.126 --> 00:17:20.806
that that's where
the user is located.

360
00:17:21.326 --> 00:17:23.516
But the region just
indicates their preference

361
00:17:23.516 --> 00:17:24.526
for certain things.

362
00:17:24.816 --> 00:17:26.746
It doesn't mean that that's
where they actually are.

363
00:17:27.455 --> 00:17:29.876
I can have my region
setting as India.

364
00:17:29.876 --> 00:17:31.296
That doesn't mean
that I'm in India.

365
00:17:31.976 --> 00:17:35.066
So if you need to know where
the user is located or,

366
00:17:35.066 --> 00:17:37.456
more precisely, where
their device is located,

367
00:17:37.456 --> 00:17:38.606
use CoreLocation.

368
00:17:38.966 --> 00:17:44.436
Again, the locale has a
language associated with it.

369
00:17:44.816 --> 00:17:47.056
But that's not necessarily
the language

370
00:17:47.056 --> 00:17:48.786
that your application
is running in.

371
00:17:49.376 --> 00:17:52.206
So if you need to ask
localization questions,

372
00:17:52.386 --> 00:17:54.766
use NSBundle, not NSLocale.

373
00:17:55.726 --> 00:17:59.056
As I mentioned earlier,
the language the user uses

374
00:17:59.056 --> 00:18:01.946
in their documents may
not be the same languages

375
00:17:59.056 --> 00:18:01.946
in their documents may
not be the same languages

376
00:18:01.946 --> 00:18:05.216
as either the locale or
the localization language.

377
00:18:06.036 --> 00:18:08.756
Typically you don't need
to know what language is

378
00:18:08.756 --> 00:18:10.606
in a user document
but, if you do,

379
00:18:10.826 --> 00:18:12.776
you can use NSLinguisticTagger.

380
00:18:16.236 --> 00:18:19.516
Again, the region and the
locale is just a preference.

381
00:18:19.896 --> 00:18:22.586
It's not something you
should use for regulatory

382
00:18:22.586 --> 00:18:26.786
or legal purposes or
determining which kind

383
00:18:27.496 --> 00:18:29.186
of credit card to
use or whatever.

384
00:18:29.186 --> 00:18:31.126
For that you'll have
to use other means,

385
00:18:31.506 --> 00:18:33.096
probably talking to a server.

386
00:18:33.576 --> 00:18:40.286
Again, if you're doing financial
or commercial transactions,

387
00:18:40.656 --> 00:18:43.066
they'll be in some
particular currency.

388
00:18:43.496 --> 00:18:46.656
But that's not necessarily
the currency that's indicated

389
00:18:46.656 --> 00:18:47.716
by the current locale.

390
00:18:48.206 --> 00:18:49.426
You should use some other means,

391
00:18:49.466 --> 00:18:52.206
probably having your server
tell you which currency to use.

392
00:18:52.946 --> 00:18:54.746
Now if you know the currency,

393
00:18:55.166 --> 00:18:57.006
if you know the three
letter ISO code,

394
00:18:57.356 --> 00:18:59.366
you can set that on
a number formatter,

395
00:18:59.766 --> 00:19:01.346
and it will then format amounts

396
00:18:59.766 --> 00:19:01.346
and it will then format amounts

397
00:19:01.346 --> 00:19:03.876
in that currency using
the user's preferences.

398
00:19:04.316 --> 00:19:06.276
It won't do conversion
between currencies though.

399
00:19:06.276 --> 00:19:07.926
You'll have to handle
that yourself.

400
00:19:09.366 --> 00:19:11.166
Now we've discussed
some of the differences

401
00:19:11.166 --> 00:19:13.246
between languages and locales.

402
00:19:13.446 --> 00:19:15.296
So how do you read
those preferences?

403
00:19:16.606 --> 00:19:18.136
Well, typically you
don't have to.

404
00:19:18.136 --> 00:19:19.816
The system handles this for you.

405
00:19:20.486 --> 00:19:23.246
All of the formatter objects,
including the new ones,

406
00:19:23.316 --> 00:19:23.986
calendars,

407
00:19:23.986 --> 00:19:28.636
locale objects-they'll all use
the user's locale preference

408
00:19:28.716 --> 00:19:29.366
by default.

409
00:19:29.766 --> 00:19:31.016
You don't have to do anything.

410
00:19:31.896 --> 00:19:35.686
If you're doing localization,
use NSBundle,

411
00:19:35.686 --> 00:19:37.836
and that will use the
user's preferences for you.

412
00:19:37.836 --> 00:19:39.356
You don't need to
read them directly.

413
00:19:40.016 --> 00:19:42.836
And again, if you're doing
language-sensitive operations

414
00:19:42.836 --> 00:19:46.446
using NSString, like localized
comparisons for sorting

415
00:19:46.446 --> 00:19:49.716
or searching, NSString will
do the right thing by default.

416
00:19:50.316 --> 00:19:56.046
But you say, "I have
some application in mind.

417
00:19:56.046 --> 00:19:59.196
I have some kind of
decision I need to make

418
00:19:59.196 --> 00:20:01.416
about behavior of
my application.

419
00:19:59.196 --> 00:20:01.416
about behavior of
my application.

420
00:20:01.736 --> 00:20:04.976
Or I need to get localized
resources that are elsewhere.

421
00:20:05.416 --> 00:20:07.606
So I really need to
read these preferences."

422
00:20:08.516 --> 00:20:11.946
Well, even in that case, you
don't need to quite often.

423
00:20:12.506 --> 00:20:15.616
So for example, you might
think you need the language

424
00:20:15.616 --> 00:20:19.186
that your application is running
in in order to control behavior.

425
00:20:19.706 --> 00:20:22.996
Say you wanted to do something
when it's running in English,

426
00:20:23.026 --> 00:20:25.726
but you don't want it to do that
when it's running in Japanese.

427
00:20:26.646 --> 00:20:28.756
Well you don't need to read
the preference for that.

428
00:20:29.496 --> 00:20:32.096
You can use NSBundle to
make this decision for you.

429
00:20:32.096 --> 00:20:34.826
If you wanted to do something
when it's running in English

430
00:20:34.826 --> 00:20:37.536
but not Japanese, put
a localized resource

431
00:20:37.536 --> 00:20:41.286
in your bundle, which has the
value "yes" for English but "no"

432
00:20:41.286 --> 00:20:44.636
for Japanese, and your
application will pick

433
00:20:44.636 --> 00:20:46.376
up the right behavior
automatically.

434
00:20:47.346 --> 00:20:50.366
Now if you are getting
localized information

435
00:20:50.596 --> 00:20:54.136
from outside your
application, then you might need

436
00:20:54.136 --> 00:20:56.436
to know the language you're
running in, and we'll talk

437
00:20:56.436 --> 00:20:59.836
about that in a little bit.

438
00:21:00.056 --> 00:21:03.676
Similarly, if you have a
set of language resources

439
00:21:03.886 --> 00:21:06.816
from elsewhere, say, they're
stored on a server and you need

440
00:21:06.816 --> 00:21:09.176
to pick the right one,
you might think you'd need

441
00:21:09.176 --> 00:21:10.936
to read the user's
preferred languages.

442
00:21:11.246 --> 00:21:13.216
But NSBundle can
handle this for you.

443
00:21:13.806 --> 00:21:16.956
There's a class method,
preferredLocalizationsFromArray.

444
00:21:17.536 --> 00:21:21.796
You hand it an array, which is
a list of language identifiers

445
00:21:22.686 --> 00:21:26.236
which represent your localized
resources, and it will match

446
00:21:26.236 --> 00:21:28.036
that against the
user's preferences

447
00:21:28.406 --> 00:21:30.136
and pick the right
one for you to use.

448
00:21:30.136 --> 00:21:32.086
You don't need to read
the preferences directly.

449
00:21:32.086 --> 00:21:35.226
And this will use the same
logic that NSBundle uses

450
00:21:35.596 --> 00:21:38.226
when picking localized
resources out of a bundle.

451
00:21:42.156 --> 00:21:46.026
And again, if you need to
know the language content

452
00:21:46.026 --> 00:21:50.186
of a document, which is
unusual but sometimes necessary,

453
00:21:50.296 --> 00:21:52.056
you can use NSLinguisticTagger.

454
00:21:52.706 --> 00:21:54.486
One thing to keep in mind is

455
00:21:54.486 --> 00:21:57.366
that a single document can
have more than one language.

456
00:21:57.726 --> 00:22:00.426
And in fact, you can have
different languages appearing

457
00:21:57.726 --> 00:22:00.426
And in fact, you can have
different languages appearing

458
00:22:00.426 --> 00:22:03.036
even in the same
paragraph or sentence.

459
00:22:06.136 --> 00:22:09.916
So, suppose you do need to
get some localized information

460
00:22:09.916 --> 00:22:12.086
from outside your
application's bundle.

461
00:22:12.486 --> 00:22:14.276
How do you go about doing that?

462
00:22:14.466 --> 00:22:15.736
Well, the first thing you need

463
00:22:15.736 --> 00:22:18.876
to know is what language
your application is running

464
00:22:18.876 --> 00:22:19.616
in right now.

465
00:22:19.966 --> 00:22:21.806
That's actually pretty
straightforward.

466
00:22:21.806 --> 00:22:23.126
You just get your main bundle.

467
00:22:23.476 --> 00:22:25.826
You ask it for its
preferred localizations,

468
00:22:26.176 --> 00:22:29.626
and the first object in that
array will be the language code

469
00:22:29.836 --> 00:22:33.596
for the language your
application is using right now.

470
00:22:34.166 --> 00:22:35.406
So, what's an example

471
00:22:35.406 --> 00:22:36.986
of something you
might use that for?

472
00:22:38.496 --> 00:22:41.886
Say your application displays
the names of currencies.

473
00:22:42.686 --> 00:22:45.366
You could ask your localizers
to localize the names

474
00:22:45.366 --> 00:22:47.606
of all the currencies
for you and put it

475
00:22:47.606 --> 00:22:48.756
in your application bundle.

476
00:22:48.756 --> 00:22:52.056
But that's unnecessary, and
NSLocale has that information.

477
00:22:53.476 --> 00:22:57.666
So you can ask a locale for the
localized name of a currency,

478
00:22:58.126 --> 00:23:01.246
but if you do that with the
current locale, you'll get it

479
00:22:58.126 --> 00:23:01.246
but if you do that with the
current locale, you'll get it

480
00:23:01.436 --> 00:23:03.406
in the language of
the current locale

481
00:23:03.736 --> 00:23:05.476
which may not be
the same language

482
00:23:05.476 --> 00:23:06.946
that your application
is running in.

483
00:23:06.946 --> 00:23:10.246
And then you'll have a mismatch
where the UI of your app is

484
00:23:10.356 --> 00:23:12.776
in one language, but the
currency names are showing

485
00:23:12.776 --> 00:23:13.376
up in another.

486
00:23:14.256 --> 00:23:18.916
So to avoid that, what we do
is we make a locale using the

487
00:23:18.916 --> 00:23:21.646
language ID that we computed
in the previous slide.

488
00:23:22.286 --> 00:23:24.526
So we take the language
ID our app is running in.

489
00:23:24.566 --> 00:23:25.776
We make a locale from it.

490
00:23:26.026 --> 00:23:29.386
And then we ask that locale
what the localized name

491
00:23:29.386 --> 00:23:30.356
of a currency is.

492
00:23:31.186 --> 00:23:33.006
So here's an example
of what you'll get

493
00:23:33.006 --> 00:23:34.706
for three different
localizations

494
00:23:34.996 --> 00:23:41.836
for the ISO currency code CNY:
English, French and Chinese.

495
00:23:46.196 --> 00:23:49.726
Similarly, NSLocale can
give you localized beginning

496
00:23:49.726 --> 00:23:50.526
and end quotes.

497
00:23:51.366 --> 00:23:55.286
And if you want those
quotes to match the language

498
00:23:55.286 --> 00:23:57.356
that your application
is running in, again,

499
00:23:57.736 --> 00:24:00.806
you make a locale using that
language and then query it

500
00:23:57.736 --> 00:24:00.806
you make a locale using that
language and then query it

501
00:24:00.806 --> 00:24:02.116
for the beginning
and end quotes.

502
00:24:02.646 --> 00:24:05.566
If you wanted the quotes to
match a different language,

503
00:24:05.896 --> 00:24:07.996
say you've retrieved
a webpage and you want

504
00:24:07.996 --> 00:24:11.796
to insert quote marks in it,
then you would use that language

505
00:24:11.796 --> 00:24:15.096
to create the locale and
query it for the quote marks.

506
00:24:15.606 --> 00:24:17.876
So here again is an
example of what you'll get

507
00:24:17.876 --> 00:24:19.586
for three different
localizations:

508
00:24:20.146 --> 00:24:22.486
English, French and Japanese.

509
00:24:26.916 --> 00:24:30.206
So I mentioned a few slides back

510
00:24:30.386 --> 00:24:32.726
that the user can change
their locale preference,

511
00:24:32.756 --> 00:24:35.736
their Region setting, and
apps don't need to restart

512
00:24:35.736 --> 00:24:36.916
for that to take effect.

513
00:24:36.976 --> 00:24:38.566
Apps are supposed
to react to it.

514
00:24:39.136 --> 00:24:41.076
So let me show you
what a lot of apps do

515
00:24:41.076 --> 00:24:43.386
when the user changes
the locale.

516
00:24:45.216 --> 00:24:47.856
Well, unfortunately,
they don't react to it.

517
00:24:48.276 --> 00:24:52.276
And the user is forced to quit
the app and restart it in order

518
00:24:52.276 --> 00:24:53.596
for the change to take effect.

519
00:24:54.976 --> 00:24:57.576
So let's talk about how we're
supposed to handle this.

520
00:24:58.496 --> 00:25:01.346
So the first thing you
need to do is listen

521
00:24:58.496 --> 00:25:01.346
So the first thing you
need to do is listen

522
00:25:01.346 --> 00:25:03.996
for the notification which
is NSCurrentLocaleDid

523
00:25:03.996 --> 00:25:05.236
ChangeNotification.

524
00:25:06.246 --> 00:25:08.916
. If you have objects
around that use the locale

525
00:25:08.916 --> 00:25:11.616
like formatters or
locale objects,

526
00:25:12.306 --> 00:25:15.156
you'll need to update
their locale property.

527
00:25:15.926 --> 00:25:17.616
But there's a workaround
for this.

528
00:25:17.616 --> 00:25:20.246
If you set up the
object in the first place

529
00:25:20.246 --> 00:25:23.926
to use the auto-updating
variant of the current locale,

530
00:25:24.416 --> 00:25:25.616
you don't need to do anything.

531
00:25:25.746 --> 00:25:27.166
They'll be updated
automatically.

532
00:25:28.166 --> 00:25:30.146
But there's still some
work that needs to be done.

533
00:25:30.716 --> 00:25:32.886
If you have a date
formatter, for example,

534
00:25:33.176 --> 00:25:35.456
that is using template formats,

535
00:25:35.726 --> 00:25:38.506
you'll need to regenerate
those based on the new locale.

536
00:25:39.406 --> 00:25:40.866
And, of course, any strings

537
00:25:40.866 --> 00:25:43.646
that you formatted using
your formatters need

538
00:25:43.646 --> 00:25:46.456
to be created again to
reflect the new locale.

539
00:25:46.506 --> 00:25:51.756
And, finally, if you want
the change in the locale

540
00:25:51.756 --> 00:25:55.396
to be reflected on the display,
you need to invalidate any views

541
00:25:55.396 --> 00:25:57.906
that are showing that
kind of information.

542
00:25:59.916 --> 00:26:02.246
So here's a very simple example.

543
00:25:59.916 --> 00:26:02.246
So here's a very simple example.

544
00:26:03.956 --> 00:26:05.256
First, we set up a listener

545
00:26:05.406 --> 00:26:08.476
for the NSCurrentLocaleDid
ChangeNotification.

546
00:26:08.946 --> 00:26:11.056
. And when the user
changes their preference,

547
00:26:11.616 --> 00:26:12.536
here's what we do.

548
00:26:12.786 --> 00:26:14.416
So assume there's
a date formatter.

549
00:26:14.786 --> 00:26:18.486
The first thing I'm going to do
is update the locale property

550
00:26:18.546 --> 00:26:20.546
with the new value of
the current locale.

551
00:26:20.986 --> 00:26:23.756
Now again, if I set
that locale property

552
00:26:23.756 --> 00:26:27.166
with the auto-updating current
locale, I could skip this step.

553
00:26:28.226 --> 00:26:32.236
This particular date formatter
is using a date format generated

554
00:26:32.236 --> 00:26:33.046
from a template.

555
00:26:33.556 --> 00:26:36.456
And since that generation
depends on the locale,

556
00:26:36.456 --> 00:26:37.766
I have to do it over again.

557
00:26:38.296 --> 00:26:41.406
So I call the class
method on NSDateFormatter,

558
00:26:41.836 --> 00:26:43.866
pass it the new locale
of the formatter

559
00:26:43.866 --> 00:26:45.506
and regenerate the date format.

560
00:26:46.306 --> 00:26:48.526
Finally, I mark myView dirty

561
00:26:48.916 --> 00:26:51.086
so that everything
gets redisplayed.

562
00:26:51.086 --> 00:26:53.706
And in this case, I'm
assuming that the draw method

563
00:26:53.706 --> 00:26:55.966
of the view will
call the formatters

564
00:26:55.966 --> 00:26:59.476
to regenerate all the strings
for dates, times and so on.

565
00:27:00.836 --> 00:27:04.506
And now I'd like to ask Karan
Misra to come up to talk

566
00:27:04.506 --> 00:27:05.756
about some case studies.

567
00:27:06.516 --> 00:27:07.076
Karan.

568
00:27:07.516 --> 00:27:10.586
>> Thank you, Debbie.

569
00:27:10.766 --> 00:27:15.056
Hello. I'm Karan Misra and I'd
like to talk to you a little bit

570
00:27:15.056 --> 00:27:19.186
about making your app work
for international customers.

571
00:27:20.336 --> 00:27:26.116
Now this is a very normal
looking time string.

572
00:27:26.116 --> 00:27:28.616
And this is a time that's
appropriately formatted

573
00:27:28.616 --> 00:27:30.186
for U.S. English.

574
00:27:30.926 --> 00:27:34.116
What you might not have
seen before is that iOS

575
00:27:34.116 --> 00:27:36.026
and OS actually support
dates and times

576
00:27:36.026 --> 00:27:37.046
in many different languages.

577
00:27:37.156 --> 00:27:39.616
And here are just a few of
them to show you the variety.

578
00:27:40.116 --> 00:27:41.916
So some of the differences
are, of course,

579
00:27:42.066 --> 00:27:44.616
you might not even
have an AM/PM marker

580
00:27:44.616 --> 00:27:45.916
because it is 24-hour time.

581
00:27:46.296 --> 00:27:48.926
But, of course, even if
that marker is there,

582
00:27:48.926 --> 00:27:50.766
it can take many
different shapes and sizes

583
00:27:50.766 --> 00:27:51.836
and go in different places.

584
00:27:52.576 --> 00:27:54.486
So what do you need to
keep in mind about this?

585
00:27:55.156 --> 00:27:56.796
Well, let's take two examples.

586
00:27:57.736 --> 00:27:59.966
On the left, you
have U.S. English.

587
00:27:59.966 --> 00:28:02.426
And, on the right, you
have simplified Chinese

588
00:27:59.966 --> 00:28:02.426
And, on the right, you
have simplified Chinese

589
00:28:02.426 --> 00:28:04.166
as spoken in mainland China.

590
00:28:06.576 --> 00:28:08.996
This is a common problem
that we see in many apps,

591
00:28:09.056 --> 00:28:13.746
which is that a format for U.S.
English is applied to Chinese.

592
00:28:14.286 --> 00:28:16.476
To a Chinese user,
this looks very wrong.

593
00:28:18.796 --> 00:28:21.966
Similarly, here's a perfectly
formatted date for U.S. English.

594
00:28:22.446 --> 00:28:25.956
This is not a perfectly
formatted date in Chinese.

595
00:28:26.036 --> 00:28:27.316
In fact, it looks like nonsense.

596
00:28:28.046 --> 00:28:32.286
The date on the right is what
a Chinese user would expect

597
00:28:32.286 --> 00:28:33.076
to see instead.

598
00:28:33.076 --> 00:28:37.206
And, just to turn
the tables around,

599
00:28:37.956 --> 00:28:40.426
here's a date that's well
formatted for Chinese

600
00:28:40.426 --> 00:28:42.216
with the day, month and year.

601
00:28:42.216 --> 00:28:44.986
Of course, in Chinese,
it's year, month, day.

602
00:28:45.696 --> 00:28:48.396
And here's what happens
if you take that order

603
00:28:48.396 --> 00:28:50.016
and apply it to an English date.

604
00:28:50.016 --> 00:28:52.656
As you can see, what you would
expect to see is something

605
00:28:52.656 --> 00:28:53.576
on the right-hand side.

606
00:28:53.576 --> 00:28:55.666
And when you see
something on the left,

607
00:28:55.666 --> 00:28:56.766
it doesn't just look wrong,

608
00:28:56.766 --> 00:28:59.186
it looks blatantly
wrong like it's broken.

609
00:28:59.996 --> 00:29:03.446
So how do we avoid
making these faux pas?

610
00:28:59.996 --> 00:29:03.446
So how do we avoid
making these faux pas?

611
00:29:03.856 --> 00:29:08.186
Well, the first thing is,
don't use a fixed format.

612
00:29:08.186 --> 00:29:11.016
Fixed formats will work for
a fixed language and not work

613
00:29:11.016 --> 00:29:11.796
for all the languages.

614
00:29:12.586 --> 00:29:16.806
So, now you might look
at the English UK example

615
00:29:16.886 --> 00:29:19.706
in the second row and say,
"Well, that looks fine.

616
00:29:19.706 --> 00:29:21.146
It's English and
it makes sense".

617
00:29:21.826 --> 00:29:23.926
But what you might
not imagine is,

618
00:29:24.466 --> 00:29:26.066
even if you just
cross the Atlantic,

619
00:29:26.236 --> 00:29:28.046
the formats change
pretty drastically.

620
00:29:28.306 --> 00:29:32.126
So in UK English, for example,
it's 3 June instead of June 3,

621
00:29:32.736 --> 00:29:35.366
and they use 24-hour
time by default,

622
00:29:35.366 --> 00:29:36.886
so you don't have
the AM/PM marker.

623
00:29:37.986 --> 00:29:40.036
So what's the right way to
do this at the API level?

624
00:29:40.036 --> 00:29:45.626
Well, localizedStringFromDate
is going to get you a date

625
00:29:45.626 --> 00:29:48.176
that is properly formatted
for the current locale.

626
00:29:48.396 --> 00:29:50.956
And you pass in a
dateStyle and a timeStyle,

627
00:29:51.276 --> 00:29:54.486
and that determines how succinct

628
00:29:54.486 --> 00:29:56.406
or verbose you want your
dates and times to be.

629
00:29:57.556 --> 00:29:59.676
And it formats the
date appropriately

630
00:29:59.676 --> 00:30:00.616
for all your locales.

631
00:29:59.676 --> 00:30:00.616
for all your locales.

632
00:30:01.246 --> 00:30:03.096
Now you might come back
to me and say, "Well,

633
00:30:03.096 --> 00:30:04.456
that's not working for me.

634
00:30:04.736 --> 00:30:05.906
I need something more custom."

635
00:30:06.726 --> 00:30:09.506
So, the first step
on your journey

636
00:30:09.506 --> 00:30:11.186
to custom dates should
be looking

637
00:30:11.186 --> 00:30:12.976
at dateFormatFromTemplate.

638
00:30:13.576 --> 00:30:16.396
Now this allows you to
specify a template and,

639
00:30:16.396 --> 00:30:19.066
within the template, the
template contains information

640
00:30:19.066 --> 00:30:21.336
about exactly what
elements of the date

641
00:30:21.336 --> 00:30:22.276
and time you want to show.

642
00:30:22.276 --> 00:30:26.716
And then you pass in a
locale so that the template,

643
00:30:26.716 --> 00:30:29.716
it gives you a format
back from the template.

644
00:30:29.776 --> 00:30:32.876
And then that format is
appropriately, is appropriate

645
00:30:32.926 --> 00:30:34.266
for the locale that
you passed in.

646
00:30:34.506 --> 00:30:37.276
And then finally you set
that format on the formatter

647
00:30:37.276 --> 00:30:39.646
to get your dates and times.

648
00:30:40.056 --> 00:30:42.806
Now of course, you might still
come back to me and say, "Well,

649
00:30:42.806 --> 00:30:45.156
none of the preset
styles work for me,

650
00:30:45.446 --> 00:30:48.886
and none of the template
formats they work for me.

651
00:30:48.886 --> 00:30:49.676
So what should I do?"

652
00:30:50.496 --> 00:30:52.946
Well, it becomes a little more
complicated as you can see.

653
00:30:53.056 --> 00:30:57.646
But the basic idea is you
might have a custom format

654
00:30:57.986 --> 00:31:01.766
but you probably have not
considered every possible locale

655
00:30:57.986 --> 00:31:01.766
but you probably have not
considered every possible locale

656
00:31:01.766 --> 00:31:02.266
in the world.

657
00:31:02.856 --> 00:31:05.756
So, don't apply your
custom format

658
00:31:05.756 --> 00:31:07.176
to every possible
locale in the world.

659
00:31:07.346 --> 00:31:09.826
If you have a custom
format for U.S. English,

660
00:31:10.416 --> 00:31:14.426
check for English U.S. and
apply just to English U.S..

661
00:31:14.526 --> 00:31:15.936
And, of course, if you
have custom formats

662
00:31:15.936 --> 00:31:18.786
for other locales, check
for those specific locales

663
00:31:18.786 --> 00:31:21.986
and make sure to fall back to
the default in your else case.

664
00:31:23.396 --> 00:31:25.766
And that's all there
is to dates and times.

665
00:31:25.836 --> 00:31:27.246
Next, let's move on to names.

666
00:31:28.316 --> 00:31:30.136
Now very similar
to dates and times,

667
00:31:30.386 --> 00:31:32.476
names come in many
different languages

668
00:31:32.476 --> 00:31:34.526
and scripts and formats.

669
00:31:34.826 --> 00:31:40.196
And here is what happens if you
apply a name format intended

670
00:31:40.196 --> 00:31:41.996
for Chinese to an English name.

671
00:31:42.156 --> 00:31:43.476
It doesn't look very good.

672
00:31:45.086 --> 00:31:48.916
And believe me that this Chinese
name looks just as awkward

673
00:31:49.296 --> 00:31:51.756
to a Chinese user because it's
using an English name format.

674
00:31:52.756 --> 00:31:54.376
So, what's wrong here?

675
00:31:55.466 --> 00:31:57.626
Well, most commonly
what we see is

676
00:31:57.626 --> 00:32:01.016
that a fixed format
has been hard coded.

677
00:31:57.626 --> 00:32:01.016
that a fixed format
has been hard coded.

678
00:32:01.546 --> 00:32:04.516
And when you use a fixed
format, it's only going

679
00:32:04.516 --> 00:32:05.366
to work for some names.

680
00:32:05.366 --> 00:32:07.346
So clearly, this is
not the right approach.

681
00:32:07.846 --> 00:32:11.136
Now what might not
be super intuitive is

682
00:32:11.136 --> 00:32:13.666
that even using a
format obtained

683
00:32:13.826 --> 00:32:17.676
from the current localization
will not give you the right

684
00:32:17.676 --> 00:32:18.596
formatting every time.

685
00:32:18.986 --> 00:32:21.896
Why? Now, if you're
living in the US,

686
00:32:21.896 --> 00:32:23.766
most of your contacts
might be in English.

687
00:32:24.096 --> 00:32:27.216
But a lot of customers,
especially those in Asia,

688
00:32:27.796 --> 00:32:29.876
most often have contacts

689
00:32:29.966 --> 00:32:32.096
in at least two languages,
if not more.

690
00:32:32.216 --> 00:32:34.336
Say Chinese and English
or Japanese and English.

691
00:32:35.506 --> 00:32:37.876
So with the fixed
format obtained

692
00:32:37.876 --> 00:32:40.926
from the current localization,
you might format, say,

693
00:32:40.926 --> 00:32:42.166
all Chinese names right.

694
00:32:42.466 --> 00:32:44.316
But you might then get all
the English names wrong.

695
00:32:44.506 --> 00:32:46.156
So that's just not
a good experience.

696
00:32:47.296 --> 00:32:48.066
So what should you do?

697
00:32:48.456 --> 00:32:52.296
Well, there's a great API called
ABRecordCopyCompositeName.

698
00:32:53.066 --> 00:32:55.506
You pass it a record
from Address Book.

699
00:32:55.766 --> 00:32:57.256
It'll give you back
the name to display.

700
00:32:57.536 --> 00:32:58.546
It's that simple.

701
00:32:59.646 --> 00:33:00.766
There's no code underneath.

702
00:32:59.646 --> 00:33:00.766
There's no code underneath.

703
00:33:01.136 --> 00:33:06.576
And this API, of course, it
encapsulates a lot of logic

704
00:33:06.746 --> 00:33:10.266
that we have designed that
takes into account the language

705
00:33:10.266 --> 00:33:12.176
of the contact, the
user settings,

706
00:33:12.366 --> 00:33:14.726
and of course it has a lot
of language-specific logic

707
00:33:14.726 --> 00:33:17.206
to then find the right format
to show the contact in.

708
00:33:17.546 --> 00:33:18.816
But you don't need
to worry about that.

709
00:33:18.876 --> 00:33:19.606
Just use this API.

710
00:33:20.816 --> 00:33:23.836
Of course you might say,
my contacts don't come

711
00:33:23.836 --> 00:33:25.396
from the Address Book, they
come from somewhere else.

712
00:33:26.026 --> 00:33:26.526
That's fine.

713
00:33:27.216 --> 00:33:29.166
You can take the name
information that you get

714
00:33:29.166 --> 00:33:32.456
from another source,
create a temporary ABRecord,

715
00:33:32.456 --> 00:33:36.326
assign these values, and then
ask for the display name again.

716
00:33:37.266 --> 00:33:40.226
And of course, if
you're using OS X,

717
00:33:40.726 --> 00:33:42.856
then there's a displayName
API there too.

718
00:33:43.636 --> 00:33:45.166
And that's really all
there is to names.

719
00:33:45.526 --> 00:33:47.116
Just use these APIs,
and it'll be all right.

720
00:33:49.256 --> 00:33:52.426
Next, I'd like to talk to
you about right-to-left text.

721
00:33:52.426 --> 00:33:56.156
So, first of all,
don't think that just

722
00:33:56.156 --> 00:33:58.686
because you don't have a
right-to-left localization,

723
00:33:58.816 --> 00:34:00.576
like Arabic or Hebrew, that
you can stop listening.

724
00:33:58.816 --> 00:34:00.576
like Arabic or Hebrew, that
you can stop listening.

725
00:34:00.576 --> 00:34:03.946
This is important even if
you localize just in English.

726
00:34:05.006 --> 00:34:06.686
So what's different
about these languages?

727
00:34:07.036 --> 00:34:10.275
Well, they run right-to-left.

728
00:34:10.275 --> 00:34:10.956
That's what's different.

729
00:34:11.255 --> 00:34:13.686
And that actually
causes a lot of issues.

730
00:34:15.275 --> 00:34:17.315
So, there are two
main topics here.

731
00:34:17.616 --> 00:34:20.076
One is alignment, and the
other is directionality.

732
00:34:20.156 --> 00:34:21.646
Let me talk about
alignment first.

733
00:34:22.876 --> 00:34:25.366
This looks like a
perfectly innocuous line

734
00:34:25.456 --> 00:34:27.216
of code, set alignment left.

735
00:34:27.216 --> 00:34:29.406
I mean, what's the alignment
for if not for setting it?

736
00:34:30.025 --> 00:34:32.626
Well, it works fine
for English text.

737
00:34:33.176 --> 00:34:36.496
But if you set Arabic
text in left alignment,

738
00:34:36.926 --> 00:34:40.525
it's kind of like setting
English text in right alignment.

739
00:34:40.676 --> 00:34:44.206
You might do it for a heading
or for some special cases,

740
00:34:44.206 --> 00:34:46.755
but you don't format
entire paragraphs of text

741
00:34:47.386 --> 00:34:48.585
in right alignment for English.

742
00:34:49.116 --> 00:34:52.596
So that text is not
very easy to read.

743
00:34:52.735 --> 00:34:53.585
What's the answer?

744
00:34:53.846 --> 00:34:56.795
Well, the answer is you
should use natural alignment.

745
00:34:57.096 --> 00:35:01.166
Now this lets the underlying
frameworks determine what the

746
00:34:57.096 --> 00:35:01.166
Now this lets the underlying
frameworks determine what the

747
00:35:01.166 --> 00:35:04.356
appropriate alignment is
left to right depending

748
00:35:04.386 --> 00:35:05.316
on the language and use.

749
00:35:05.916 --> 00:35:09.386
And if you use this, you'll get
nice left alignment for English

750
00:35:09.386 --> 00:35:10.666
and other left-to-right
languages.

751
00:35:10.666 --> 00:35:13.346
And you'll get nice right
alignment for Arabic

752
00:35:13.346 --> 00:35:14.486
and other right-to-left
languages.

753
00:35:15.226 --> 00:35:15.806
So that's easy.

754
00:35:17.096 --> 00:35:19.256
Let's move on to something
less easy, directionality.

755
00:35:19.726 --> 00:35:23.996
Now, directionality, in
contrast to alignment,

756
00:35:24.286 --> 00:35:28.186
determines what the logical
order and the visual order

757
00:35:28.186 --> 00:35:30.496
of the words is within
a given run of text,

758
00:35:30.496 --> 00:35:31.706
like within a single sentence.

759
00:35:32.316 --> 00:35:36.056
So what we see most
commonly going wrong is

760
00:35:36.056 --> 00:35:39.126
that someone is trying
actually to be helpful,

761
00:35:39.126 --> 00:35:42.476
and they take the fact that
the app is running in Arabic

762
00:35:42.476 --> 00:35:47.086
or Hebrew, and they hard-code
the base writing direction

763
00:35:47.086 --> 00:35:49.096
to right-to-left.

764
00:35:49.746 --> 00:35:50.506
Why is this wrong?

765
00:35:50.666 --> 00:35:54.796
Well, this is wrong because user
content can be in any language,

766
00:35:54.856 --> 00:35:56.406
as Debbie mentioned before.

767
00:35:56.586 --> 00:35:59.096
And you cannot assume the
language of user content.

768
00:35:59.556 --> 00:36:01.956
Now this is a sentence that's
supposed to be in English,

769
00:35:59.556 --> 00:36:01.956
Now this is a sentence that's
supposed to be in English,

770
00:36:02.426 --> 00:36:04.656
with one Urdu word
in the middle.

771
00:36:04.656 --> 00:36:07.296
So it's supposed to say,
"WWDC is a fun conference."

772
00:36:07.636 --> 00:36:09.066
It's not really saying
that right now

773
00:36:09.206 --> 00:36:12.596
because it's using right-to-left
text directionality,

774
00:36:13.146 --> 00:36:16.686
and that doesn't make sense.

775
00:36:16.686 --> 00:36:18.556
So, what should you do?

776
00:36:18.816 --> 00:36:20.986
Well, for any text
view or text field

777
00:36:20.986 --> 00:36:23.176
in which you expect the
user to type content,

778
00:36:23.916 --> 00:36:26.226
set the writing direction
to natural.

779
00:36:26.536 --> 00:36:30.286
Now again, that lets the
underlying frameworks determine

780
00:36:30.586 --> 00:36:34.546
what a good best guess for
the writing direction is.

781
00:36:35.256 --> 00:36:38.326
In this case, it will take a
look at the first few letters

782
00:36:38.326 --> 00:36:40.836
of the string, which is WWDC,

783
00:36:41.256 --> 00:36:43.336
and since those are
left-to-right characters,

784
00:36:43.716 --> 00:36:46.626
it will take a guess that this
string should go left-to-right.

785
00:36:46.626 --> 00:36:51.166
And in this case, that produces
the expected sentence, which is,

786
00:36:51.166 --> 00:36:53.086
"WWDC is a must conference."

787
00:36:55.156 --> 00:37:00.456
So, of course, as I
mentioned, it's a best guess.

788
00:36:55.156 --> 00:37:00.456
So, of course, as I
mentioned, it's a best guess.

789
00:37:00.686 --> 00:37:03.496
And so you might have
a sentence like this.

790
00:37:03.706 --> 00:37:06.916
Now since you saw it animate
in, you can see the order.

791
00:37:07.066 --> 00:37:08.706
So you can see it one more time.

792
00:37:09.196 --> 00:37:10.696
So Safari first, then
[foreign language]

793
00:37:10.696 --> 00:37:13.216
in Arabic, and then Mac.

794
00:37:13.856 --> 00:37:18.096
So, you might be able to tell,
if you saw it being typed,

795
00:37:18.426 --> 00:37:20.666
that the user wants to
say, "Safari on Mac."

796
00:37:21.186 --> 00:37:23.456
But because it started
with Latin letters

797
00:37:23.456 --> 00:37:24.506
that would go left-to-right,

798
00:37:24.896 --> 00:37:28.166
the directionality was
assumed as left-to-right.

799
00:37:28.166 --> 00:37:30.976
And so, you have the opposite
sentence, "Mac on Safari."

800
00:37:33.266 --> 00:37:35.236
So how do you fix this?

801
00:37:35.486 --> 00:37:40.106
Well, this is the
sentence you want to get.

802
00:37:40.516 --> 00:37:45.966
And in order to get this order
of the words, what you need

803
00:37:45.966 --> 00:37:49.226
to do is you need to
insert a right-to-left mark

804
00:37:49.426 --> 00:37:51.516
at the beginning
of the sentence.

805
00:37:51.866 --> 00:37:55.306
This is an invisible
character that you insert

806
00:37:55.826 --> 00:37:58.836
to control the directionality
of the string.

807
00:38:00.756 --> 00:38:05.326
And, of course, you might have
a case that is the opposite,

808
00:38:05.326 --> 00:38:08.476
in fact, in which you start
with, say, an Arabic word,

809
00:38:08.756 --> 00:38:11.006
which is right-to-left,
and the OS will guess

810
00:38:11.126 --> 00:38:12.736
that the whole sentence
is supposed

811
00:38:12.736 --> 00:38:13.756
to flow from right-to-left.

812
00:38:13.756 --> 00:38:17.996
But what you intended
was for the sentence

813
00:38:18.186 --> 00:38:19.406
to flow from left-to-right.

814
00:38:19.406 --> 00:38:20.966
And, if you have
a translation app,

815
00:38:20.966 --> 00:38:23.296
you might actually have already
encountered a case like this.

816
00:38:24.646 --> 00:38:27.186
And, in this case,
the solution is

817
00:38:27.256 --> 00:38:28.466
to insert a left-to-right mark.

818
00:38:29.646 --> 00:38:32.816
So, what you're probably
thinking is, "Well,

819
00:38:32.816 --> 00:38:34.636
that's great, but who's supposed

820
00:38:34.636 --> 00:38:36.736
to insert these marks
into the strings?"

821
00:38:36.786 --> 00:38:38.996
because you might not
have heard about them.

822
00:38:39.726 --> 00:38:42.466
So the answer is,
well it is you.

823
00:38:43.046 --> 00:38:46.226
But, probably not exactly you.

824
00:38:46.476 --> 00:38:49.226
What you need to do is to
talk to your localizers.

825
00:38:49.776 --> 00:38:53.426
Your localizers, and not just
your right-to-left language

826
00:38:53.426 --> 00:38:55.776
localizers like localizers
for Arabic and Hebrew,

827
00:38:55.896 --> 00:38:58.986
all of your localizers need to
understand how these marks work.

828
00:38:59.446 --> 00:39:02.456
Because they need to insert
these in, for example,

829
00:38:59.446 --> 00:39:02.456
Because they need to insert
these in, for example,

830
00:39:02.456 --> 00:39:05.626
if there's a localizable
string that starts

831
00:39:05.626 --> 00:39:07.226
with a format argument.

832
00:39:07.966 --> 00:39:12.306
Now, when the user
content comes in,

833
00:39:12.306 --> 00:39:15.406
that format argument could be
replaced by an English word

834
00:39:15.406 --> 00:39:17.926
or an Arabic word or a
Hebrew word or a French word,

835
00:39:18.326 --> 00:39:21.366
so you don't know at compile
time what it's going to be.

836
00:39:21.586 --> 00:39:24.816
So you need to insert, if you're
in a left-to-right localization

837
00:39:24.816 --> 00:39:26.196
like English or French
or German,

838
00:39:26.476 --> 00:39:29.566
you need to have a left-to-right
mark there to tell it that even

839
00:39:29.566 --> 00:39:31.596
if an Arabic word comes
in, I want the sentence

840
00:39:31.596 --> 00:39:32.446
to flow left-to-right.

841
00:39:32.446 --> 00:39:35.116
And the same and the opposite
for right-to-left localizations.

842
00:39:37.186 --> 00:39:40.866
Of course, this is just
a brief introduction

843
00:39:41.326 --> 00:39:45.126
to handling right-to-left
text, or actually,

844
00:39:45.126 --> 00:39:48.716
mixed text I should say,
and you should check our

845
00:39:48.716 --> 00:39:50.536
internationalization
and localization guide

846
00:39:50.916 --> 00:39:53.756
for more details about
handling more advanced cases.

847
00:39:55.316 --> 00:39:58.616
Lastly, for right-to-left,
I should mention

848
00:39:59.696 --> 00:40:01.696
that Xcode 6 has a
great new feature

849
00:39:59.696 --> 00:40:01.696
that Xcode 6 has a
great new feature

850
00:40:01.696 --> 00:40:04.396
which lets you simulate a
right-to-left localization

851
00:40:04.656 --> 00:40:07.146
so you can run in English
but in right-to-left

852
00:40:07.146 --> 00:40:09.896
and see how your layout flows
in a right-to-left localization.

853
00:40:10.416 --> 00:40:11.966
And of course, I
highly encourage you

854
00:40:11.966 --> 00:40:14.696
to attend the Localizing
with Xcode session

855
00:40:14.696 --> 00:40:17.596
which is later today to
learn more about Xcode 6

856
00:40:17.596 --> 00:40:18.856
and what it brings
for localization.

857
00:40:20.966 --> 00:40:23.206
Next, let me talk
about the keyboard.

858
00:40:24.106 --> 00:40:25.906
Now this is the U.S.
English keyboard.

859
00:40:25.906 --> 00:40:29.046
And, as you probably
know from yesterday,

860
00:40:29.596 --> 00:40:30.716
we now have predictive typing.

861
00:40:31.736 --> 00:40:34.646
So, what does this mean
for you as a developer?

862
00:40:35.456 --> 00:40:40.636
Well, even more than before, you
need to keep track of the height

863
00:40:40.636 --> 00:40:41.796
and size of the keyboard.

864
00:40:42.446 --> 00:40:44.496
So, I first of all
hope that none

865
00:40:44.496 --> 00:40:45.876
of you have hard-coded the size

866
00:40:45.876 --> 00:40:48.416
of the keyboard anywhere
in your apps.

867
00:40:49.026 --> 00:40:51.806
And now, of course, if
you do that, you're going

868
00:40:51.806 --> 00:40:53.206
to get a lot of one
star ratings.

869
00:40:54.096 --> 00:40:57.436
So, first of all
notice that even

870
00:40:57.436 --> 00:41:00.956
when predictive typing
is off, like on the left,

871
00:40:57.436 --> 00:41:00.956
when predictive typing
is off, like on the left,

872
00:41:01.506 --> 00:41:03.156
there's still a thin bar
on top of the keyboard.

873
00:41:03.156 --> 00:41:04.696
So the height of the
keyboard is still different

874
00:41:04.696 --> 00:41:05.516
from what it used to be.

875
00:41:06.316 --> 00:41:08.216
But, not all the keyboards

876
00:41:08.216 --> 00:41:11.236
on iOS are predictive
typing enabled.

877
00:41:11.636 --> 00:41:13.286
So you still might
have a keyboard

878
00:41:13.286 --> 00:41:15.596
like the Bengali keyboard,
which is new in iOS 8,

879
00:41:16.096 --> 00:41:18.116
which does not have even
the thin bar on top.

880
00:41:18.116 --> 00:41:21.046
So already you have
three different sizes.

881
00:41:21.656 --> 00:41:26.596
Then we also have keyboards like
Japanese and Chinese in which,

882
00:41:26.776 --> 00:41:29.586
before the user starts
typing, it's the short height.

883
00:41:29.586 --> 00:41:31.846
And, once they start
typing, there's a bar on top

884
00:41:31.846 --> 00:41:33.096
and it becomes a tall height.

885
00:41:33.096 --> 00:41:34.096
So, your app needs

886
00:41:34.096 --> 00:41:36.106
to accommodate these
size changes on the fly.

887
00:41:36.106 --> 00:41:38.276
And, of course, users
will switch back and forth

888
00:41:38.326 --> 00:41:39.236
between these keyboards.

889
00:41:41.036 --> 00:41:43.696
Not only that, but this is
something you're probably aware

890
00:41:43.776 --> 00:41:47.676
of for sure is that when the
keyboard comes up, your UI needs

891
00:41:47.676 --> 00:41:49.256
to move away if you
don't want it

892
00:41:49.256 --> 00:41:50.426
to get hidden behind
the keyboard.

893
00:41:51.506 --> 00:41:52.556
So how do we do all of this?

894
00:41:53.256 --> 00:41:56.316
Well, helpfully, the
keyboard lets you know

895
00:41:56.316 --> 00:41:59.136
when it's coming in, going
out, or changing size.

896
00:41:59.596 --> 00:42:01.556
So all you need to do is
watch for those notifications.

897
00:41:59.596 --> 00:42:01.556
So all you need to do is
watch for those notifications.

898
00:42:02.956 --> 00:42:04.916
Now, what can you do with these?

899
00:42:05.186 --> 00:42:07.856
Well, here's an example
of Safari.

900
00:42:08.886 --> 00:42:11.756
When the keyboard comes
in, as you can see,

901
00:42:11.906 --> 00:42:14.546
the search field shrinks.

902
00:42:15.356 --> 00:42:17.566
And I'll play it
again so you can see

903
00:42:17.846 --> 00:42:21.436
that these two animations are
actually happening in tandem.

904
00:42:22.106 --> 00:42:24.206
So how do you make this
happen in your apps?

905
00:42:25.166 --> 00:42:28.256
Well, the keyboard will show,

906
00:42:28.476 --> 00:42:30.926
notification actually
contains a lot of information.

907
00:42:31.146 --> 00:42:33.416
First of all, it contains
information about the frame,

908
00:42:33.666 --> 00:42:34.756
where the keyboard will start

909
00:42:34.756 --> 00:42:36.686
and where the keyboard
will end its animation.

910
00:42:38.006 --> 00:42:39.556
It also contains information

911
00:42:39.666 --> 00:42:41.796
about the animation
duration and curve.

912
00:42:42.146 --> 00:42:44.716
So actually you can
use these two pieces

913
00:42:44.716 --> 00:42:48.736
of information together and make
sure that your UI moves away

914
00:42:48.736 --> 00:42:51.806
from the keyboard and also moves
in tandem with the keyboard

915
00:42:51.806 --> 00:42:55.916
so it gives a very smooth
experience to the user.

916
00:42:56.076 --> 00:42:57.646
We also have hardware keyboards.

917
00:42:58.196 --> 00:43:02.336
So, iOS, any iOS device can
attach to a hardware keyboard

918
00:42:58.196 --> 00:43:02.336
So, iOS, any iOS device can
attach to a hardware keyboard

919
00:43:02.336 --> 00:43:03.086
if you have Bluetooth.

920
00:43:03.426 --> 00:43:05.056
And of course if you
want to simulate it,

921
00:43:05.056 --> 00:43:07.816
there's an optional
Simulator to do that as well.

922
00:43:07.816 --> 00:43:10.446
So what does this
mean for your apps?

923
00:43:10.856 --> 00:43:14.106
Well, if you have an app like
this, which has a toolbar

924
00:43:14.106 --> 00:43:17.896
above the keyboard, the
important thing to keep

925
00:43:17.896 --> 00:43:20.416
in mind is that there's
functionality like Choose Font

926
00:43:20.416 --> 00:43:23.306
in this case, which you
don't want the user to lose

927
00:43:23.306 --> 00:43:24.976
when they attach a
hardware keyboard.

928
00:43:25.806 --> 00:43:27.876
So, this is not what you want

929
00:43:27.986 --> 00:43:29.066
when a hardware keyboard
is attached.

930
00:43:30.246 --> 00:43:33.316
What you want is this
in which the toolbar

931
00:43:33.316 --> 00:43:34.446
at the bottom remains,

932
00:43:34.446 --> 00:43:36.196
even though a hardware
keyboard is attached.

933
00:43:37.076 --> 00:43:38.246
So how do you make this happen?

934
00:43:38.846 --> 00:43:41.396
Well, if you do have a
view that just goes on top

935
00:43:41.396 --> 00:43:45.736
of the keyboard, it's a one
line code change, which is,

936
00:43:45.966 --> 00:43:47.466
to use inputAccessoryView.

937
00:43:48.316 --> 00:43:51.456
inputAccessoryView allows
you to specify the view,

938
00:43:51.866 --> 00:43:53.986
and that view is stuck
on top of the keyboard.

939
00:43:54.036 --> 00:43:56.216
And the keyboard takes
care of animating it in,

940
00:43:56.216 --> 00:43:58.876
animating it out, and making
sure it docks at the bottom

941
00:43:59.026 --> 00:44:01.376
when the hardware
keyboard is attached.

942
00:43:59.026 --> 00:44:01.376
when the hardware
keyboard is attached.

943
00:44:01.376 --> 00:44:05.036
Moving on to another
keyboard topic: keyboard type.

944
00:44:06.586 --> 00:44:10.396
Now keyboard types
basically allow you to specify

945
00:44:10.396 --> 00:44:13.976
within the same keyboard
different, specific,

946
00:44:14.036 --> 00:44:15.436
optimized keyboard types.

947
00:44:15.436 --> 00:44:18.096
So for example, here we have
the email type which is meant

948
00:44:18.096 --> 00:44:21.296
for email addresses, user
names, etc. And as you can see,

949
00:44:21.526 --> 00:44:24.486
it has the @ and full-stop
keys on the first plane

950
00:44:24.696 --> 00:44:25.856
to let you easily type those.

951
00:44:27.016 --> 00:44:30.766
Of course, the punctuation
planes are also optimized

952
00:44:30.766 --> 00:44:32.326
for email address typing.

953
00:44:32.846 --> 00:44:35.646
And so you have more
frequently used symbols there.

954
00:44:36.996 --> 00:44:39.826
What you might not know
is that in the keyboards

955
00:44:39.826 --> 00:44:43.896
for many languages, like
simplified Chinese, Arabic,

956
00:44:43.896 --> 00:44:47.606
etc. many of the commonly
used punctuation symbols

957
00:44:47.936 --> 00:44:51.216
for other languages are not
the same symbols that are used

958
00:44:51.216 --> 00:44:53.796
for email address or URLs.

959
00:44:53.966 --> 00:44:58.386
And so the problem is that,
if you expect a certain kind

960
00:44:58.386 --> 00:44:59.586
of input in your text field

961
00:44:59.586 --> 00:45:01.146
and you don't specify
the right type,

962
00:44:59.586 --> 00:45:01.146
and you don't specify
the right type,

963
00:45:01.586 --> 00:45:04.266
the user might actually be
forced to switch keyboards just

964
00:45:04.266 --> 00:45:05.836
to type an email
address or username.

965
00:45:05.836 --> 00:45:07.136
And that's not a
very good experience.

966
00:45:07.996 --> 00:45:10.216
So, make sure to specify
the right keyboard type.

967
00:45:10.216 --> 00:45:11.936
And, of course, we have
more than just email.

968
00:45:12.026 --> 00:45:14.636
We have URL, Twitter, NumberPad.

969
00:45:15.266 --> 00:45:17.586
In fact, we have a whole host
of different keyboard types.

970
00:45:18.146 --> 00:45:20.576
And another one I would
like to call your attention

971
00:45:20.576 --> 00:45:21.876
to is ASCIICapable.

972
00:45:22.396 --> 00:45:24.086
Now if you have a
textField or textView

973
00:45:24.086 --> 00:45:26.936
in which you are expecting
content that is only in ASCII,

974
00:45:27.476 --> 00:45:29.566
go ahead and specify
the ASCIICapable type.

975
00:45:29.676 --> 00:45:32.226
That'll make sure that the
user's keyboard is switched,

976
00:45:32.226 --> 00:45:36.576
for example, from Chinese to an
ASCII keyboard automatically.

977
00:45:37.316 --> 00:45:41.996
And they don't have to manually
switch keyboards to do that.

978
00:45:42.226 --> 00:45:44.306
You should also know about
the autocorrection type.

979
00:45:44.656 --> 00:45:46.546
So, for some of your
textViews and textFields,

980
00:45:46.926 --> 00:45:48.296
autocorrection might
not be useful.

981
00:45:48.296 --> 00:45:50.606
In fact, it might
actually hamper user input.

982
00:45:50.606 --> 00:45:53.006
So, make sure to turn
autocorrection off

983
00:45:53.096 --> 00:45:53.876
where appropriate.

984
00:45:55.506 --> 00:46:00.596
Similarly, auto-capitalization
has four options

985
00:45:55.506 --> 00:46:00.596
Similarly, auto-capitalization
has four options

986
00:46:00.596 --> 00:46:02.756
which are very useful
for different contexts.

987
00:46:02.756 --> 00:46:05.106
And these are all
also language aware.

988
00:46:05.106 --> 00:46:07.886
So you should use these
appropriately depending

989
00:46:07.886 --> 00:46:09.276
on what kind of input
you're expecting

990
00:46:09.276 --> 00:46:10.786
in a certain textView
or textField.

991
00:46:14.616 --> 00:46:17.806
And lastly, I want to
talk about mark text.

992
00:46:18.486 --> 00:46:20.776
Now you might never
have seen this

993
00:46:20.776 --> 00:46:23.266
if you've never used a
Chinese or Japanese keyboard.

994
00:46:23.686 --> 00:46:26.946
But for these languages,
when the user types,

995
00:46:27.096 --> 00:46:30.046
they do not directly type
the output characters

996
00:46:30.046 --> 00:46:30.986
like they do in English.

997
00:46:31.246 --> 00:46:34.076
But they first type usually
a phonetic or other kind

998
00:46:34.076 --> 00:46:38.676
of input string and then
they choose a candidate

999
00:46:38.676 --> 00:46:39.586
from the bar below.

1000
00:46:39.586 --> 00:46:40.866
Or it's above the keyboard.

1001
00:46:42.436 --> 00:46:44.976
So what does this mean
for you as a developer?

1002
00:46:46.086 --> 00:46:51.056
The important thing to know
here is when a textView

1003
00:46:51.056 --> 00:46:52.986
or textField has
marked text in it.

1004
00:46:53.806 --> 00:46:56.026
Because when it does
have marked text in it,

1005
00:46:56.526 --> 00:46:58.686
the number one thing
you want to make sure is

1006
00:46:58.686 --> 00:47:02.226
to not edit the content of
that textView or textField.

1007
00:46:58.686 --> 00:47:02.226
to not edit the content of
that textView or textField.

1008
00:47:02.556 --> 00:47:04.166
Why? Because if you do that,

1009
00:47:04.556 --> 00:47:07.846
their marked text will get
committed to the document.

1010
00:47:09.596 --> 00:47:11.796
Pretty much no user
wants that to happen

1011
00:47:11.796 --> 00:47:13.716
because that is not the text
they were trying to type.

1012
00:47:13.716 --> 00:47:16.196
And you're going to have
some very frustrated users

1013
00:47:16.196 --> 00:47:16.796
if you do that.

1014
00:47:18.166 --> 00:47:23.136
And of course, while the marked
text is there, you can use it

1015
00:47:23.216 --> 00:47:25.136
for other things
like autocompletion

1016
00:47:25.136 --> 00:47:28.716
or showing some predictions
to the user.

1017
00:47:28.716 --> 00:47:31.026
But what you should remember is

1018
00:47:31.026 --> 00:47:32.806
that this is not
their final text.

1019
00:47:33.066 --> 00:47:35.126
And often the marked
text is not going

1020
00:47:35.126 --> 00:47:37.776
to contain meaningful
linguistic content

1021
00:47:37.776 --> 00:47:40.756
because it's just the input
codes for that input method.

1022
00:47:41.406 --> 00:47:44.706
So, use it for live
search if you'd like,

1023
00:47:44.916 --> 00:47:48.586
but note that it might not
be the user's final content.

1024
00:47:50.496 --> 00:47:56.696
And that is really all, well,
that's not all, but I would say

1025
00:47:56.696 --> 00:47:59.046
that those are the most common
things you should keep in mind.

1026
00:47:59.986 --> 00:48:03.896
And let me just reiterate some
of the items that we talked

1027
00:47:59.986 --> 00:48:03.896
And let me just reiterate some
of the items that we talked

1028
00:48:03.896 --> 00:48:08.466
about earlier that will help
prevent you getting a one-star

1029
00:48:08.466 --> 00:48:11.176
rating from someone in
Asia or the Middle East.

1030
00:48:12.266 --> 00:48:18.316
So, first of all, localize your
app into tons of languages.

1031
00:48:18.886 --> 00:48:23.716
Of course, iOS and OS X both
support a lot of languages,

1032
00:48:23.716 --> 00:48:26.226
and we added new ones
for both platforms.

1033
00:48:27.336 --> 00:48:32.586
And, starting in iOS 8, you can
localize into many languages

1034
00:48:32.586 --> 00:48:38.566
that Apple doesn't localize
into, so don't let us stop you.

1035
00:48:38.566 --> 00:48:41.206
Secondly, understand the
differences between language

1036
00:48:41.206 --> 00:48:42.926
and locale and when to use them

1037
00:48:42.926 --> 00:48:46.686
and when you don't
need to use them.

1038
00:48:47.446 --> 00:48:50.956
Of course, format dates,
times and names correctly.

1039
00:48:50.956 --> 00:48:55.296
As you saw, it's
really easy to do.

1040
00:48:56.566 --> 00:49:00.126
And, note that there are a lot

1041
00:48:56.566 --> 00:49:00.126
And, note that there are a lot

1042
00:49:00.126 --> 00:49:02.946
of right-to-left users
on both iOS and OS X.

1043
00:49:02.946 --> 00:49:05.626
In fact, it's one of the
most popular languages

1044
00:49:05.626 --> 00:49:08.206
for input on iOS and OS X.

1045
00:49:08.206 --> 00:49:12.786
So, regardless of whether you
localize into Arabic or Hebrew

1046
00:49:12.786 --> 00:49:14.126
or another right-to-left
language or not,

1047
00:49:14.336 --> 00:49:16.676
make sure that you're
not breaking text input

1048
00:49:16.926 --> 00:49:17.716
for these users.

1049
00:49:18.876 --> 00:49:23.526
Keyboards, of course, come
in many different shapes

1050
00:49:23.526 --> 00:49:28.026
and sizes and-well actually,
one shape, many sizes-and,

1051
00:49:28.886 --> 00:49:31.436
of course, they come in
new sizes with iOS 8.

1052
00:49:31.436 --> 00:49:33.346
So make sure you
keep that in mind.

1053
00:49:34.166 --> 00:49:37.806
Of course, choose the right
keyboard type for the context

1054
00:49:37.946 --> 00:49:42.496
so that you make the input
experience smooth and easy.

1055
00:49:42.686 --> 00:49:47.616
And don't touch the marked text
if-don't touch the document

1056
00:49:47.696 --> 00:49:53.426
while there's marked
text in the document.

1057
00:49:53.426 --> 00:49:55.066
For more information, of course,

1058
00:49:55.066 --> 00:49:59.056
you can contact Jake who's
our App Frameworks Evangelist.

1059
00:49:59.556 --> 00:50:01.686
And we also have the
Internationalization

1060
00:49:59.556 --> 00:50:01.686
And we also have the
Internationalization

1061
00:50:01.686 --> 00:50:03.676
and Localization Guide
that I mentioned previously

1062
00:50:03.856 --> 00:50:08.146
up on our website that you
should really check out.

1063
00:50:09.386 --> 00:50:13.266
We also have two sessions that
you should definitely check out.

1064
00:50:13.266 --> 00:50:16.376
One is Localizing with Xcode
6, which is later this morning.

1065
00:50:17.006 --> 00:50:21.246
And, actually, we covered a
lot of new material this year

1066
00:50:21.246 --> 00:50:23.366
and we didn't actually
repeat a lot of the material

1067
00:50:23.366 --> 00:50:26.816
from previous years'
internationalization talks,

1068
00:50:27.096 --> 00:50:29.956
which are actually still
relevant for your apps today.

1069
00:50:30.116 --> 00:50:33.296
So definitely go ahead and check
out Making Your App World-Ready,

1070
00:50:33.296 --> 00:50:35.476
which is last year's
internationalization session.

1071
00:50:36.186 --> 00:50:37.016
Thank you very much.
