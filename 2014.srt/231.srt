
1
00:00:14.616 --> 00:00:16.976
>> Hi. Welcome to the
Advanced CloudKit session.

2
00:00:17.516 --> 00:00:20.546
[ Cheering & Applause ]

3
00:00:21.046 --> 00:00:21.416
Thank you.

4
00:00:21.546 --> 00:00:23.526
My name is Jacob Farkas.

5
00:00:23.526 --> 00:00:25.496
I'm a Software Engineer
at Apple and one

6
00:00:25.496 --> 00:00:26.896
of the designers of
the CloudKit API.

7
00:00:27.656 --> 00:00:29.766
And my colleagues and I
have put a lot of hard work

8
00:00:29.766 --> 00:00:30.706
into the CloudKit API.

9
00:00:30.706 --> 00:00:33.356
I'm really excited to talk
to you guys about it today.

10
00:00:33.356 --> 00:00:35.306
So, let's jump right into it.

11
00:00:36.276 --> 00:00:40.616
So, CloudKit is this thing
that we've built on top

12
00:00:40.616 --> 00:00:41.886
of our iCloud servers.

13
00:00:41.886 --> 00:00:45.286
We've built a lot of iCloud
services, and what we're doing

14
00:00:45.286 --> 00:00:48.626
with CloudKit is exposing those
database servers that we use

15
00:00:48.626 --> 00:00:51.246
at Apple to all of
you developers.

16
00:00:52.186 --> 00:00:54.026
So, we're actually using this.

17
00:00:54.026 --> 00:00:56.796
This is something that we
use in the new iCloud Photos

18
00:00:56.796 --> 00:00:58.956
and iCloud Drive feature
that we're introducing,

19
00:00:59.516 --> 00:01:02.366
and we're building all of
that on top of CloudKit.

20
00:00:59.516 --> 00:01:02.366
and we're building all of
that on top of CloudKit.

21
00:01:03.366 --> 00:01:06.056
If all of this is unfamiliar to
you, you might want to go back

22
00:01:06.056 --> 00:01:08.206
and check out the
Introducing CloudKit session.

23
00:01:08.206 --> 00:01:11.506
It was given on Tuesday and
there should be videos online.

24
00:01:12.876 --> 00:01:14.306
So, we're going to
jump right into this.

25
00:01:14.456 --> 00:01:15.886
What we're going to learn today,

26
00:01:15.886 --> 00:01:18.736
we're going to over the CloudKit
private database, which is a way

27
00:01:18.736 --> 00:01:21.236
for you store private user
information in iCloud.

28
00:01:22.266 --> 00:01:24.386
We're going to talk about
modeling your data in CloudKit.

29
00:01:25.516 --> 00:01:27.956
We're going to talk about
advanced record manipulation

30
00:01:27.956 --> 00:01:30.066
and different ways of saving
records to the server.

31
00:01:31.466 --> 00:01:34.276
We're going to go over how to
handle notifications reliably,

32
00:01:34.526 --> 00:01:36.156
if you miss a push, what to do.

33
00:01:37.666 --> 00:01:39.866
And finally, we're going to
go over the iCloud Dashboard

34
00:01:39.866 --> 00:01:41.456
which is a web-based interface

35
00:01:41.456 --> 00:01:43.126
for managing your
CloudKit application.

36
00:01:45.496 --> 00:01:47.246
So, let's start off by looking

37
00:01:47.246 --> 00:01:48.916
at the CloudKit API
really quick.

38
00:01:50.346 --> 00:01:53.606
We designed the CloudKit API
to be highly asynchronous.

39
00:01:53.606 --> 00:01:57.416
Everything has a callback,
nothing is synchronous.

40
00:01:57.486 --> 00:01:59.056
And we did this because all

41
00:01:59.056 --> 00:02:00.836
of these requests are
going out over the network.

42
00:01:59.056 --> 00:02:00.836
of these requests are
going out over the network.

43
00:02:01.316 --> 00:02:03.686
When you get the network
involved, anything can happen,

44
00:02:03.686 --> 00:02:06.446
you know, the server might
not be responding quickly,

45
00:02:06.446 --> 00:02:08.036
there might be a bad
network connection.

46
00:02:08.395 --> 00:02:11.736
We don't want to block the UI
and cause a bad user experience.

47
00:02:12.816 --> 00:02:16.036
And to help do this, we've used
NSOperation almost everywhere

48
00:02:16.036 --> 00:02:16.516
in our API.

49
00:02:17.576 --> 00:02:20.636
I say almost everywhere
because if you went

50
00:02:20.636 --> 00:02:21.986
to the introductory session,

51
00:02:21.986 --> 00:02:24.406
you remember seeing what we
called the Convenience API.

52
00:02:25.276 --> 00:02:29.086
And the Convenience API is our
way of helping you get started

53
00:02:29.086 --> 00:02:30.916
with CloudKit really
quickly and simply.

54
00:02:31.406 --> 00:02:35.046
All of these APIs are, you
know, single calls that work

55
00:02:35.046 --> 00:02:36.986
on one record at a time.

56
00:02:36.986 --> 00:02:39.116
So, in this case, we're
fetching one record

57
00:02:39.606 --> 00:02:41.076
and it's asynchronous.

58
00:02:41.076 --> 00:02:43.286
We get that one record back
in our completionHandler.

59
00:02:44.156 --> 00:02:46.496
But, as you use CloudKit
more, you might find

60
00:02:46.496 --> 00:02:48.026
that you need some
additional functionality.

61
00:02:48.676 --> 00:02:51.376
And that's where the
NSOperation-based API comes in.

62
00:02:52.066 --> 00:02:55.506
So, what we've got here is
the CKFetchRecordsOperation.

63
00:02:55.556 --> 00:02:58.696
And this is an NSOperation
that does the equivalent

64
00:02:58.696 --> 00:03:00.436
of that convenience
API we just saw.

65
00:02:58.696 --> 00:03:00.436
of that convenience
API we just saw.

66
00:03:01.136 --> 00:03:02.656
We give you a lot
more functionality

67
00:03:02.656 --> 00:03:04.996
when you use the
NSOperation-based API.

68
00:03:05.596 --> 00:03:09.316
So, you can see here that our
initializer takes an array

69
00:03:09.316 --> 00:03:09.876
of record IDs.

70
00:03:09.876 --> 00:03:13.046
You can fetch a whole batch
of records all at once.

71
00:03:14.286 --> 00:03:16.296
We also give you more
feedback on what's happening.

72
00:03:16.296 --> 00:03:18.886
We've got a completion
block for each record,

73
00:03:18.886 --> 00:03:20.326
and we also give you progress

74
00:03:20.326 --> 00:03:22.056
as we download those
records from the server.

75
00:03:22.646 --> 00:03:28.306
And finally, these operations
give you more knobs and levers

76
00:03:28.306 --> 00:03:32.196
to tweak what is returned
and what the operation does.

77
00:03:32.196 --> 00:03:34.816
In this case, we've got
a desiredKeys property

78
00:03:34.816 --> 00:03:36.916
that lets you specify
what key should come back

79
00:03:36.916 --> 00:03:40.436
on the records that you fetch.

80
00:03:40.656 --> 00:03:43.086
So, since all of this
is built on NSOperation,

81
00:03:43.086 --> 00:03:44.176
let's do a quick overview

82
00:03:44.176 --> 00:03:46.366
of what the NSOperation
class looks like.

83
00:03:47.466 --> 00:03:50.446
What we've got in NSOperation
is a completionBlock

84
00:03:50.446 --> 00:03:53.176
and a cancel call so that
you can manage the life cycle

85
00:03:53.176 --> 00:03:53.946
of your operation.

86
00:03:55.406 --> 00:03:56.586
We've got a couple of variables

87
00:03:56.586 --> 00:03:58.606
that tell you some state
about the operation.

88
00:03:59.756 --> 00:04:01.916
And NSOperations
have dependencies,

89
00:03:59.756 --> 00:04:01.916
And NSOperations
have dependencies,

90
00:04:01.916 --> 00:04:04.376
so you can link two
NSOperations together.

91
00:04:06.956 --> 00:04:09.336
Once you have an NSOperation,
you're going to want to start

92
00:04:09.336 --> 00:04:11.566
that operation, and you
do that by adding it

93
00:04:11.566 --> 00:04:13.266
to an NSOperationQueue.

94
00:04:13.806 --> 00:04:16.276
When you have an
NSOperationQueue,

95
00:04:16.276 --> 00:04:19.276
you can also manage the life
cycle of that operation queue.

96
00:04:19.276 --> 00:04:21.156
You can suspend it
and resume it,

97
00:04:21.456 --> 00:04:23.826
and you can cancel
the operations in it.

98
00:04:26.156 --> 00:04:28.836
So, if you go to look at
our NSOperation-based API,

99
00:04:28.836 --> 00:04:30.906
you might just see this
big list of a bunch

100
00:04:30.906 --> 00:04:32.026
of different operations.

101
00:04:32.026 --> 00:04:33.896
It's kind of overwhelming
and confusing.

102
00:04:34.396 --> 00:04:36.796
The best way to think
about this API is to think

103
00:04:36.796 --> 00:04:38.736
about the objects that
you want to deal with.

104
00:04:39.236 --> 00:04:41.076
If you remember from
the introductory talk,

105
00:04:41.756 --> 00:04:44.936
CloudKits-based objects
are records and zones

106
00:04:44.936 --> 00:04:48.546
and subscriptions, and you'll
see that up here we have a fetch

107
00:04:48.546 --> 00:04:50.926
and a modify operation
for all of those items.

108
00:04:50.926 --> 00:04:57.476
One of the really cool
things about NSOperation is

109
00:04:57.476 --> 00:04:58.616
that is has dependencies.

110
00:04:58.616 --> 00:05:01.656
So, you can set a dependency
between two operations

111
00:04:58.616 --> 00:05:01.656
So, you can set a dependency
between two operations

112
00:05:02.226 --> 00:05:04.506
and the second operation
won't fire

113
00:05:04.506 --> 00:05:06.226
until the first operation
is completed.

114
00:05:06.786 --> 00:05:09.796
This is really handy
with CloudKit if you want

115
00:05:09.796 --> 00:05:13.146
to do something like fetch a
record, add a property to it,

116
00:05:13.146 --> 00:05:14.936
and save that record
back to the server.

117
00:05:15.576 --> 00:05:17.696
You can make the
FetchRecordsOperation,

118
00:05:17.856 --> 00:05:21.646
make the modify operation at the
same time, set up a dependency,

119
00:05:22.046 --> 00:05:24.046
and when the fetch completes,
you can put that data

120
00:05:24.046 --> 00:05:26.286
in the modify operation, and
it'll start automatically.

121
00:05:26.836 --> 00:05:30.786
These dependencies also
work between queues.

122
00:05:30.786 --> 00:05:34.566
So, even though CloudKit has
its own internal operation queue

123
00:05:34.566 --> 00:05:37.006
that you can use to run
operations, you're welcome

124
00:05:37.326 --> 00:05:39.486
to create your own
NSOperation queue,

125
00:05:39.856 --> 00:05:41.436
and you can then
manage its life cycle.

126
00:05:41.436 --> 00:05:47.716
You can stop operations or
suspend them or cancel them.

127
00:05:47.926 --> 00:05:51.326
One tip with using
NSOperation though is

128
00:05:51.326 --> 00:05:55.146
that the NSOperation-based class
has a completionBlock on it.

129
00:05:55.766 --> 00:05:56.926
This completionBlock ends

130
00:05:56.926 --> 00:05:59.496
up firing asynchronously
with dependencies.

131
00:05:59.496 --> 00:06:01.056
So, if you've set
up dependencies

132
00:05:59.496 --> 00:06:01.056
So, if you've set
up dependencies

133
00:06:01.096 --> 00:06:03.466
and you're using the
NSOperation's completion block,

134
00:06:03.916 --> 00:06:05.586
they might happen
at the same time,

135
00:06:05.996 --> 00:06:07.586
and that data you
were trying to funnel

136
00:06:07.586 --> 00:06:10.596
into the next operation won't
get there in time, you know,

137
00:06:10.596 --> 00:06:11.876
that operation has
already started.

138
00:06:12.576 --> 00:06:15.056
So, what we've done with
the CloudKit API is we have

139
00:06:15.106 --> 00:06:16.996
CloudKit-specific
completion blocks.

140
00:06:17.416 --> 00:06:21.316
And if we look at what we had
for that fetchRecords operation,

141
00:06:21.806 --> 00:06:23.766
we have a
fetchRecordsCompletionBlock.

142
00:06:24.456 --> 00:06:26.946
You'll see this pattern on
all of our NSOperations.

143
00:06:26.946 --> 00:06:29.366
And these completion
blocks hand back all

144
00:06:29.366 --> 00:06:30.906
of the information
you needed to know

145
00:06:30.906 --> 00:06:32.286
about the operation
that just ran.

146
00:06:32.806 --> 00:06:35.756
In this case, we've got the
errors for that operation,

147
00:06:35.756 --> 00:06:38.396
and we've also got the
records that were fetched.

148
00:06:40.466 --> 00:06:43.146
And finally, NSOperations can
have their own priorities.

149
00:06:43.146 --> 00:06:45.856
So, you can set background
operations and have them run

150
00:06:45.856 --> 00:06:48.656
at a really low priority
and keep your UI responsive.

151
00:06:49.066 --> 00:06:52.226
So, when we were
designing CloudKit,

152
00:06:52.306 --> 00:06:53.406
one of the things we noticed is

153
00:06:53.406 --> 00:06:55.546
that there's two general
classes of applications.

154
00:06:56.366 --> 00:06:59.816
There's one class of application
that stores a whole bunch

155
00:06:59.816 --> 00:07:02.836
of data up on the server, and
when you use the application,

156
00:06:59.816 --> 00:07:02.836
of data up on the server, and
when you use the application,

157
00:07:02.836 --> 00:07:04.476
it's just presenting
the view of that data.

158
00:07:04.476 --> 00:07:07.556
It downloads it on demand,
displays it to the user,

159
00:07:07.556 --> 00:07:10.096
and then, you know,
tosses it out because it's,

160
00:07:10.096 --> 00:07:11.446
the real copy's on the server.

161
00:07:12.266 --> 00:07:13.866
But there's another
class of application

162
00:07:13.866 --> 00:07:16.346
that has just a little
bit of data, but you want

163
00:07:16.346 --> 00:07:18.376
that same data on
all of your clients.

164
00:07:19.706 --> 00:07:21.536
So, if you remember from
the introductory talk,

165
00:07:21.536 --> 00:07:24.446
we talked about what we
called Big Data, Little Phone.

166
00:07:24.446 --> 00:07:26.826
That's that case where we have
a lot of data on the server.

167
00:07:27.306 --> 00:07:30.156
It's not all going to fit on
one phone, and you download it

168
00:07:30.156 --> 00:07:31.196
and view it on demand.

169
00:07:31.456 --> 00:07:33.886
So, you can see these clients
are downloading records,

170
00:07:33.916 --> 00:07:37.156
viewing them, and the truth
lives up on the server.

171
00:07:38.716 --> 00:07:40.966
However, there's another
class of application,

172
00:07:41.626 --> 00:07:43.686
where it's a small
amount of data.

173
00:07:43.686 --> 00:07:46.816
It lives on one client, but you
want it on all your clients.

174
00:07:47.086 --> 00:07:48.986
An example of this
is an application

175
00:07:48.986 --> 00:07:50.076
that manages your receipts.

176
00:07:50.146 --> 00:07:53.836
So, every time you buy
something, you take a picture

177
00:07:53.836 --> 00:07:57.846
of the receipt, and you want
that information on your phone,

178
00:07:57.846 --> 00:08:00.746
in your iPad, in your Mac,
and you want them all to be

179
00:07:57.846 --> 00:08:00.746
in your iPad, in your Mac,
and you want them all to be

180
00:08:00.746 --> 00:08:02.306
up to date with the
same receipts.

181
00:08:05.716 --> 00:08:07.556
So, what we've done
to help you solve

182
00:08:07.556 --> 00:08:11.146
that is we've got something
in CloudKit that does that.

183
00:08:11.146 --> 00:08:13.946
If you remember, we have, every
application gets a container.

184
00:08:14.756 --> 00:08:17.146
In every container is a
public and private database.

185
00:08:18.016 --> 00:08:20.296
And just as a refresher,

186
00:08:20.296 --> 00:08:22.676
that private database is
actually one private database

187
00:08:22.676 --> 00:08:23.476
for every user.

188
00:08:26.156 --> 00:08:27.516
Inside of those databases,

189
00:08:27.516 --> 00:08:29.196
we then subdivide
them down into zones.

190
00:08:29.316 --> 00:08:32.706
So, both the public and the
private database have a default

191
00:08:32.736 --> 00:08:33.265
zone in them.

192
00:08:34.426 --> 00:08:37.275
But we've also given you
what we call custom zones,

193
00:08:37.275 --> 00:08:40.486
and these custom zones allow us
to give you some extra features

194
00:08:40.486 --> 00:08:42.816
that we can't provide
in the default zones.

195
00:08:44.536 --> 00:08:47.786
You can create these custom
zones and use the new features.

196
00:08:47.846 --> 00:08:50.556
Let's go over a couple of them.

197
00:08:50.756 --> 00:08:53.246
The first feature
is atomic commits.

198
00:08:54.516 --> 00:08:57.286
So, CloudKit has
relationships between records.

199
00:08:57.286 --> 00:09:00.596
And if you start using CloudKit
and using these relationships,

200
00:08:57.286 --> 00:09:00.596
And if you start using CloudKit
and using these relationships,

201
00:09:00.596 --> 00:09:03.476
you're going to build up an
object graph, and you're going

202
00:09:03.476 --> 00:09:06.966
to realize you want
consistency in your data.

203
00:09:06.966 --> 00:09:09.466
If, you know, you might have
an object graph that you want

204
00:09:09.466 --> 00:09:10.556
to commit all at once.

205
00:09:10.586 --> 00:09:13.186
And if some of those
things don't get committed,

206
00:09:13.186 --> 00:09:15.996
the data on the server
doesn't make sense.

207
00:09:16.296 --> 00:09:18.296
On the public database,
we can't guarantee

208
00:09:18.296 --> 00:09:20.616
that because there might
be thousands or millions

209
00:09:20.616 --> 00:09:22.246
of users hitting
the same database.

210
00:09:22.246 --> 00:09:25.496
So, there's no way to lock the
database while we, you know,

211
00:09:25.496 --> 00:09:27.106
commit your very
special records.

212
00:09:27.916 --> 00:09:31.416
But in the private database,
you only have one user.

213
00:09:31.416 --> 00:09:33.156
It's the current user's account.

214
00:09:33.196 --> 00:09:40.506
And in that case, we can provide
you things like atomic commits.

215
00:09:40.586 --> 00:09:43.176
So, with atomic commits,
these batch operations

216
00:09:43.206 --> 00:09:46.726
in the NSOperation API will
succeed or fail as a whole.

217
00:09:47.106 --> 00:09:49.216
So, if any record had a problem,

218
00:09:49.926 --> 00:09:52.886
you will get back a
CKErrorPartialFailure.

219
00:09:54.546 --> 00:09:56.846
Inside of that partial
failure error, you're going

220
00:09:56.846 --> 00:09:59.526
to see a user, the
userInfo dictionary is going

221
00:09:59.576 --> 00:10:02.246
to have this
CKPartialErrorsByItemID key.

222
00:09:59.576 --> 00:10:02.246
to have this
CKPartialErrorsByItemID key.

223
00:10:03.386 --> 00:10:05.796
And that's going to be a
dictionary of record IDs

224
00:10:06.306 --> 00:10:08.336
to errors for each
of those records.

225
00:10:09.116 --> 00:10:10.556
And some of those
errors are going

226
00:10:10.556 --> 00:10:12.416
to be the real failures
that you care about.

227
00:10:12.476 --> 00:10:14.636
These are the reasons that
the atomic commit failed.

228
00:10:15.376 --> 00:10:17.486
But, you know, the rest
of the records failed

229
00:10:17.486 --> 00:10:19.726
because it was atomic commit,
and we need to let you know

230
00:10:19.726 --> 00:10:21.476
that they failed,
so you're also going

231
00:10:21.556 --> 00:10:23.576
to see
CKErrorBatchRequestFailed.

232
00:10:24.306 --> 00:10:26.006
That's just a way of
saying that something else

233
00:10:26.006 --> 00:10:27.816
in this batch failed,
and, you know,

234
00:10:27.816 --> 00:10:32.726
this wasn't the real problem, it
was that other record in here.

235
00:10:32.946 --> 00:10:34.466
Another great feature
that we give you

236
00:10:34.466 --> 00:10:36.566
with custom zones
are delta downloads.

237
00:10:37.946 --> 00:10:40.656
So, delta downloads are a
way for that second class

238
00:10:40.656 --> 00:10:43.586
of application to be
possible in CloudKit.

239
00:10:43.966 --> 00:10:46.456
You can download only the
changes that were made

240
00:10:46.456 --> 00:10:48.996
in that zone, and you can
cache them all locally.

241
00:10:48.996 --> 00:10:51.926
So, what does that look like?

242
00:10:52.236 --> 00:10:55.306
Well, we've got our Mac here,
and we've got our iPhone,

243
00:10:55.736 --> 00:10:57.126
and we've got a custom zone.

244
00:10:57.936 --> 00:11:00.096
So, let's step through a
delta download really quick.

245
00:10:57.936 --> 00:11:00.096
So, let's step through a
delta download really quick.

246
00:11:00.896 --> 00:11:02.966
We've got an orange
record and a green record

247
00:11:02.966 --> 00:11:05.496
over on the Mac here, and we
want them on the phone as well.

248
00:11:05.856 --> 00:11:08.346
So, we're going to first
upload those both into CloudKit

249
00:11:08.346 --> 00:11:12.346
in our custom zone, and
then our iPhone is going

250
00:11:12.346 --> 00:11:15.946
to perform a delta
download to get up to date.

251
00:11:17.456 --> 00:11:19.396
So, these delta downloads
are based

252
00:11:19.396 --> 00:11:20.836
on what we call change tokens.

253
00:11:20.836 --> 00:11:23.406
And a change token is a
way of tracking the state

254
00:11:23.406 --> 00:11:25.226
of the server the last
time you talked to it.

255
00:11:26.176 --> 00:11:28.256
So, this phone has never
talked to the server,

256
00:11:28.726 --> 00:11:31.536
and what it's going to do is
send up a nil change token.

257
00:11:31.536 --> 00:11:33.466
And that's a way of saying,
"I've never talked to you,

258
00:11:33.466 --> 00:11:35.216
just send me all the
records in the zone."

259
00:11:36.106 --> 00:11:38.176
So, the server is the going
to take that nil change token,

260
00:11:38.936 --> 00:11:41.376
send down an, the orange
record and green record.

261
00:11:41.876 --> 00:11:44.056
The phone is going to save
them into its local database.

262
00:11:44.646 --> 00:11:47.106
And then the server is going to
send down a new change token.

263
00:11:47.556 --> 00:11:50.466
In this case, it's change
token A, and that means that,

264
00:11:50.466 --> 00:11:53.566
you know, the records you
have are all from state A.

265
00:11:53.566 --> 00:11:56.766
If the phone came back
again with change tag A,

266
00:11:56.766 --> 00:11:58.296
the server will go, "Well,
I don't have anything

267
00:11:58.296 --> 00:11:59.856
for you, A is good enough.

268
00:11:59.986 --> 00:12:00.916
There's nothing to download."

269
00:11:59.986 --> 00:12:00.916
There's nothing to download."

270
00:12:01.446 --> 00:12:05.796
But let's say the Mac
comes along and it creates

271
00:12:05.796 --> 00:12:08.386
that purple record, and it
deletes the green record.

272
00:12:08.626 --> 00:12:10.736
And it uploads those
changes to the server.

273
00:12:11.716 --> 00:12:14.076
The server is going to track
the changes, so it'll note

274
00:12:14.076 --> 00:12:15.476
that that green record
was deleted.

275
00:12:15.556 --> 00:12:17.346
It'll note that there's
a new purple record.

276
00:12:18.106 --> 00:12:20.566
And now, when the iPhone
comes back with change tag A,

277
00:12:21.106 --> 00:12:23.786
the server goes, "All right,
well, we're are at B now.

278
00:12:24.186 --> 00:12:25.086
That's farther than A.

279
00:12:25.916 --> 00:12:27.336
Here's a delete of
the green record

280
00:12:27.336 --> 00:12:30.136
and here's a new purple record
that happened while, you know,

281
00:12:30.136 --> 00:12:31.286
since the last time we talked."

282
00:12:32.686 --> 00:12:34.696
Then it sends back
that new change token

283
00:12:34.986 --> 00:12:37.026
and everyone is up to date.

284
00:12:38.356 --> 00:12:40.526
So, you can use this
delta download

285
00:12:40.526 --> 00:12:43.016
to implement an offline
cache in your application.

286
00:12:43.736 --> 00:12:46.146
If you want to do
that, there's a couple

287
00:12:46.146 --> 00:12:47.156
of steps your app
should to take.

288
00:12:47.156 --> 00:12:49.936
This is kind of an outline
of a basic state machine

289
00:12:49.936 --> 00:12:52.196
for every time you talk
to the server and you want

290
00:12:52.196 --> 00:12:53.146
to do a delta download.

291
00:12:54.556 --> 00:12:56.776
The first thing you're going
to want to do in your app is

292
00:12:56.846 --> 00:12:58.456
to track the local changes.

293
00:12:58.916 --> 00:13:00.716
You're going to want
to make a change table,

294
00:12:58.916 --> 00:13:00.716
You're going to want
to make a change table,

295
00:13:01.286 --> 00:13:03.966
and every time the user makes
an edit in your application,

296
00:13:03.966 --> 00:13:04.916
you want to write that down.

297
00:13:04.916 --> 00:13:07.766
You're going to want to do this
because you might be offline

298
00:13:07.766 --> 00:13:10.266
when the user makes the changes,
and you're going to need

299
00:13:10.266 --> 00:13:12.496
to replay all those
changes back to the server

300
00:13:12.496 --> 00:13:14.106
when you can talk to it.

301
00:13:16.116 --> 00:13:17.166
Then, you're going to need

302
00:13:17.166 --> 00:13:19.046
to send all those
changes up to the server.

303
00:13:19.046 --> 00:13:21.006
You want to do that before
you fetch the changes

304
00:13:21.056 --> 00:13:23.666
because someone else might
have changed the record

305
00:13:23.666 --> 00:13:26.356
in the meantime, and you need
to resolve these conflicts.

306
00:13:27.606 --> 00:13:29.776
So, we'll go over conflict
handling in just a little bit,

307
00:13:29.866 --> 00:13:31.196
but just keep in mind

308
00:13:31.196 --> 00:13:33.186
that that's an important
step in this process here.

309
00:13:34.666 --> 00:13:37.086
Finally, you're ready to
do the delta download.

310
00:13:37.086 --> 00:13:38.146
This is the point
where you're going

311
00:13:38.146 --> 00:13:40.526
to call
CKFetchRecordChangesOperation.

312
00:13:41.666 --> 00:13:45.576
The server is going to send
you back updates and deletes

313
00:13:45.576 --> 00:13:48.766
and modifies and adds of
records, and you're going

314
00:13:48.766 --> 00:13:50.496
to save those into
your local database.

315
00:13:51.696 --> 00:13:53.016
Finally, the server is going

316
00:13:53.016 --> 00:13:54.646
to send you back a
new change token.

317
00:13:54.716 --> 00:13:56.396
And that's the change
token you want to save

318
00:13:56.396 --> 00:13:58.296
so that the next time
you talk to the server,

319
00:13:58.746 --> 00:13:59.916
you can get only the records

320
00:13:59.916 --> 00:14:01.646
that have changed
and not everything.

321
00:13:59.916 --> 00:14:01.646
that have changed
and not everything.

322
00:14:04.476 --> 00:14:07.296
So, one of the other features
we give you with custom zones

323
00:14:07.296 --> 00:14:09.346
and delta downloads
are zone subscriptions.

324
00:14:09.346 --> 00:14:12.956
In the case of that state
machine I just talked about,

325
00:14:13.276 --> 00:14:16.376
you could pull every, you
know, 10 minutes or 5 minutes

326
00:14:16.376 --> 00:14:18.466
or whatever and hope that
there are changes up there.

327
00:14:19.136 --> 00:14:21.256
But wouldn't it be great if
the server just told you,

328
00:14:21.256 --> 00:14:22.226
"Hey, I've got changes.

329
00:14:22.226 --> 00:14:23.356
It's time for delta download."

330
00:14:23.946 --> 00:14:24.816
Well, we give you that.

331
00:14:24.886 --> 00:14:27.296
We give you what we
call zone subscriptions.

332
00:14:27.766 --> 00:14:29.646
These look like query
subscriptions,

333
00:14:29.706 --> 00:14:30.826
but they're a little
bit different.

334
00:14:31.586 --> 00:14:34.746
What they do is every
time something changes

335
00:14:34.746 --> 00:14:37.336
in a custom zone, you'll
get a push notification.

336
00:14:38.076 --> 00:14:39.556
When you see that
push notification,

337
00:14:39.556 --> 00:14:42.056
you know you should go do a
delta download with the server,

338
00:14:42.366 --> 00:14:43.456
and you'll get new records.

339
00:14:43.536 --> 00:14:50.696
So, a couple of notes on
designing custom zones

340
00:14:50.696 --> 00:14:51.716
and when you should use them.

341
00:14:52.956 --> 00:14:56.206
These custom zones are meant
to compartmentalize your data.

342
00:14:56.656 --> 00:14:59.696
Because of that, there's a
couple of restrictions on them.

343
00:14:59.696 --> 00:15:02.416
The first is that you can't
move records between zones.

344
00:14:59.696 --> 00:15:02.416
The first is that you can't
move records between zones.

345
00:15:03.226 --> 00:15:05.096
You can pick these
records up and copy them

346
00:15:05.096 --> 00:15:09.806
and make a new copy in the new
zone, but you can't move them.

347
00:15:09.806 --> 00:15:12.676
You also can't make
any cross-zone delete

348
00:15:12.676 --> 00:15:13.916
self relationships.

349
00:15:14.006 --> 00:15:17.656
So, you have to think of
these zones as self-contained.

350
00:15:17.656 --> 00:15:20.096
If you have records that need to
go across zones, you might want

351
00:15:20.096 --> 00:15:21.086
to rethink your model.

352
00:15:23.696 --> 00:15:26.306
And finally, these zones
determine the level of updates.

353
00:15:26.306 --> 00:15:28.476
If you're using a zone
subscription, you're going

354
00:15:28.476 --> 00:15:30.976
to get a push every single
time something has changed

355
00:15:30.976 --> 00:15:31.526
in that zone.

356
00:15:31.526 --> 00:15:36.006
If you have a lot of data on
the server and you only care

357
00:15:36.006 --> 00:15:38.196
about getting updates for
one part of that data,

358
00:15:38.196 --> 00:15:41.486
you might want to make that a
zone so that you can ignore the,

359
00:15:41.486 --> 00:15:43.956
you know, really busy
stuff going on over here

360
00:15:43.956 --> 00:15:51.236
and just download the
things you care about.

361
00:15:52.276 --> 00:15:54.776
So, let's talk about some
advanced record operations.

362
00:15:55.826 --> 00:15:59.266
When you're using CKRecord,
any changes you make

363
00:15:59.266 --> 00:16:03.676
to a CKRecord object locally get
tracked, and then when we talk

364
00:15:59.266 --> 00:16:03.676
to a CKRecord object locally get
tracked, and then when we talk

365
00:16:03.676 --> 00:16:06.076
to the server, we're only
going to send the changes

366
00:16:06.076 --> 00:16:07.466
that you made to that CKRecord.

367
00:16:08.636 --> 00:16:10.926
This is the default behavior,
and it works great most

368
00:16:10.926 --> 00:16:14.286
of the time, but you might
want some additional control

369
00:16:14.286 --> 00:16:15.906
over what we're sending
to the server.

370
00:16:16.666 --> 00:16:18.606
And we give you that
with save policies.

371
00:16:19.846 --> 00:16:23.156
So, these save policies,
we have three of them.

372
00:16:23.276 --> 00:16:25.226
They're
CKRecordSaveIfServerUnchanged.

373
00:16:26.266 --> 00:16:32.046
We have CKRecordSaveChangedKeys,
and we have CKRecordSaveAllKeys.

374
00:16:34.236 --> 00:16:37.186
So, let's look at the
differences between those.

375
00:16:38.236 --> 00:16:42.336
The biggest difference is
what they determine for a,

376
00:16:42.376 --> 00:16:43.866
what I'm going to
call a locked save.

377
00:16:44.636 --> 00:16:46.856
And a locked save is
a way of making sure

378
00:16:46.856 --> 00:16:48.646
that you don't overwrite
data on the server

379
00:16:48.646 --> 00:16:50.716
that someone else
has already written.

380
00:16:50.716 --> 00:16:52.156
When you perform a locked save,

381
00:16:52.156 --> 00:16:56.576
it says that if the record has
changed since-on the server

382
00:16:56.576 --> 00:16:57.736
since the time you fetched it,

383
00:16:58.206 --> 00:17:00.336
the server will give you an
error saying your record is

384
00:16:58.206 --> 00:17:00.336
the server will give you an
error saying your record is

385
00:17:00.336 --> 00:17:03.466
out of date, you need to resolve
this conflict and try again.

386
00:17:04.596 --> 00:17:09.816
So, the only thing that performs
a locked save here is CKRecord

387
00:17:09.816 --> 00:17:12.086
save policy
SaveIfServerUnchanged.

388
00:17:12.786 --> 00:17:16.076
The other two actually force
these changes to the server.

389
00:17:16.076 --> 00:17:17.336
So, SaveChangedKeys

390
00:17:17.336 --> 00:17:20.386
and SaveAllKeys always overwrite
the values on the server.

391
00:17:22.435 --> 00:17:25.626
These policies also determine
how much data we're sending

392
00:17:25.626 --> 00:17:26.106
to the server.

393
00:17:27.546 --> 00:17:29.756
In the case of
SaveIfServerUnchanged

394
00:17:29.816 --> 00:17:34.286
and SaveChangedKeys, we're only
going to send up the, sorry,

395
00:17:34.286 --> 00:17:35.626
we're only going to
send up the values

396
00:17:35.626 --> 00:17:37.466
on the record that have changed.

397
00:17:38.036 --> 00:17:39.386
In the case of SaveAllKeys,

398
00:17:39.386 --> 00:17:41.686
we're going to send the
entire record, all the values,

399
00:17:41.746 --> 00:17:43.726
whether you've changed
them or not.

400
00:17:45.216 --> 00:17:48.486
So, back to locked updates.

401
00:17:48.486 --> 00:17:50.676
We've got this thing
called locking,

402
00:17:50.676 --> 00:17:53.526
and if you don't use it,
here's what could go wrong

403
00:17:53.526 --> 00:17:54.526
with an unlocked update.

404
00:17:54.676 --> 00:17:57.026
Right now, we've got
this contact card.

405
00:17:57.076 --> 00:17:59.456
We've got the same name,
first name, last name,

406
00:17:59.456 --> 00:18:02.496
picture on two clients,
and in iCloud.

407
00:17:59.456 --> 00:18:02.496
picture on two clients,
and in iCloud.

408
00:18:02.496 --> 00:18:03.626
Everything is good right now.

409
00:18:04.526 --> 00:18:07.466
But let's say the iPhone
changes that contact completely.

410
00:18:07.466 --> 00:18:10.136
So it modifies the picture,
it modifies the first name,

411
00:18:10.136 --> 00:18:11.476
and it modifies the last name.

412
00:18:12.436 --> 00:18:15.296
Well, it's going to perform a
SaveChangedKeys to the server,

413
00:18:15.616 --> 00:18:17.806
which is going to send up
the things that have changed,

414
00:18:18.156 --> 00:18:20.286
and that's going to overwrite
whatever is on the server.

415
00:18:20.286 --> 00:18:25.536
Next, before the Mac gets a
chance to download that record,

416
00:18:25.536 --> 00:18:26.896
the user edited the first name

417
00:18:26.896 --> 00:18:28.466
of that record and
just changed it.

418
00:18:29.496 --> 00:18:33.456
And that Mac then sends- does a
SaveChangedKeys with the server,

419
00:18:34.156 --> 00:18:36.496
and it sent up just the
property that was modified.

420
00:18:37.176 --> 00:18:40.556
And now, we've got a problem
here, oops, we've got a problem.

421
00:18:40.556 --> 00:18:44.206
This contact record isn't
what either the clients meant

422
00:18:44.206 --> 00:18:45.036
to have.

423
00:18:45.866 --> 00:18:49.096
So, to work around this,
we have locked updates.

424
00:18:49.736 --> 00:18:52.346
And locked updates are
a way of making sure

425
00:18:52.346 --> 00:18:55.376
that the server knows that
you're updating the same values

426
00:18:55.446 --> 00:18:56.536
that are already on the server.

427
00:18:57.376 --> 00:18:58.836
And we do this with
a change tag.

428
00:18:59.266 --> 00:19:01.606
So, the change tag is a
property on the record

429
00:18:59.266 --> 00:19:01.606
So, the change tag is a
property on the record

430
00:19:02.286 --> 00:19:05.976
that necessarily changes anytime
a value in the record changes.

431
00:19:06.626 --> 00:19:09.416
In this case, we've got change
tag A both on the server

432
00:19:09.416 --> 00:19:12.926
and locally, and so we know that
they both have the same values.

433
00:19:13.796 --> 00:19:17.396
If we go and we add a new
property on the local record,

434
00:19:18.296 --> 00:19:21.256
when we save that to the server
using the default save policy,

435
00:19:21.366 --> 00:19:23.356
it's going to send up
both the change tag

436
00:19:23.946 --> 00:19:25.476
and the property that changed.

437
00:19:26.866 --> 00:19:29.096
The servers then,
before it does anything,

438
00:19:29.096 --> 00:19:30.756
it's going to check
the two change tags,

439
00:19:31.216 --> 00:19:34.296
and if they're equal, it'll
apply the change that you made.

440
00:19:34.996 --> 00:19:40.096
If on the other hand we have
another client that, oh, sorry,

441
00:19:40.096 --> 00:19:43.056
and then the server is going
to send back a new change tag

442
00:19:43.086 --> 00:19:44.586
because we did change
a property.

443
00:19:45.586 --> 00:19:49.386
We return this new record to
you with the updated change tag

444
00:19:49.386 --> 00:19:50.576
in the completion block.

445
00:19:50.576 --> 00:19:53.716
So, if you take the record that
we gave you at the end of a save

446
00:19:54.286 --> 00:19:56.836
and you do all your subsequent
modifications on that,

447
00:19:57.316 --> 00:19:59.136
you'll be using the
updated change token,

448
00:19:59.166 --> 00:20:01.586
and you shouldn't have any
conflicts with the server.

449
00:19:59.166 --> 00:20:01.586
and you shouldn't have any
conflicts with the server.

450
00:20:03.716 --> 00:20:05.656
Now, let's say we had
another client that, you know,

451
00:20:05.656 --> 00:20:07.896
hadn't seen that change and
he was still at version A.

452
00:20:08.556 --> 00:20:10.506
And he decides to add
a different property

453
00:20:10.506 --> 00:20:11.036
on the record.

454
00:20:11.766 --> 00:20:13.996
Well, he's going to save it to
the server, he's going to send

455
00:20:13.996 --> 00:20:16.716
up the change tag and
the modified property,

456
00:20:17.416 --> 00:20:19.476
and the server is going
to realize that, hey,

457
00:20:19.476 --> 00:20:20.836
those two values
aren't the same.

458
00:20:21.626 --> 00:20:24.266
And the client is going to
get back an error saying,

459
00:20:24.266 --> 00:20:25.286
you know, you have a conflict.

460
00:20:26.496 --> 00:20:28.146
So, how do we handle
these conflicts?

461
00:20:29.876 --> 00:20:32.976
Well, if you run into this
case of a locked save failing,

462
00:20:33.456 --> 00:20:36.616
you're going to get an error
that CKErrorServerRecordChanged.

463
00:20:37.236 --> 00:20:39.726
And because you guys all
went to the introductory talk

464
00:20:39.726 --> 00:20:42.206
and you learned about how
great error handling is

465
00:20:42.206 --> 00:20:43.076
and how important it is,

466
00:20:43.076 --> 00:20:46.226
you've got some fantastic error
handling here, and it's going

467
00:20:46.226 --> 00:20:48.676
to check for
CKErrorServerRecordChanged.

468
00:20:49.946 --> 00:20:52.656
When you see that, you know that
you're out of date, you're going

469
00:20:52.656 --> 00:20:54.236
to need to get the new
record from the server.

470
00:20:54.506 --> 00:20:56.296
You're going to need to
take your local changes,

471
00:20:56.296 --> 00:20:58.506
apply them to that record
and try to save again.

472
00:20:59.566 --> 00:21:01.066
And we've already
anticipated that.

473
00:20:59.566 --> 00:21:01.066
And we've already
anticipated that.

474
00:21:01.156 --> 00:21:03.596
So, what we're going to do
is help you out a little bit,

475
00:21:03.596 --> 00:21:06.366
and we're going to return
those records to you already

476
00:21:06.416 --> 00:21:09.386
because we know that's the
next logical thing to do.

477
00:21:10.096 --> 00:21:12.686
So, inside of the userInfo
dictionary of this error,

478
00:21:12.806 --> 00:21:14.526
you're going to find three
copies of the record.

479
00:21:15.826 --> 00:21:18.176
You're going to find the record
that you attempted to save

480
00:21:18.176 --> 00:21:20.866
to the server, the one
that encountered the error.

481
00:21:22.116 --> 00:21:23.536
You're going to find
the original copy

482
00:21:23.536 --> 00:21:26.736
of the local record, which
is the copy we downloaded

483
00:21:26.736 --> 00:21:28.696
from the server before
you made any changes.

484
00:21:29.816 --> 00:21:32.126
And finally, we're going to
give you the server record back.

485
00:21:32.276 --> 00:21:34.006
This is the copy of the
record with the most

486
00:21:34.006 --> 00:21:36.906
up to date change tag.

487
00:21:37.086 --> 00:21:40.216
You're going to want to figure
out what makes sense out of all

488
00:21:40.216 --> 00:21:42.196
of those copies of
values and keys.

489
00:21:42.766 --> 00:21:44.746
You're going to apply them
all to the server version

490
00:21:44.746 --> 00:21:50.326
of the record, and then you're
going to retry that save.

491
00:21:50.526 --> 00:21:52.186
So, you might be wondering
at this point, you know,

492
00:21:52.186 --> 00:21:55.006
what type of save
policy should you use?

493
00:21:55.476 --> 00:21:57.286
And the simple answer to that is

494
00:21:57.286 --> 00:22:00.846
that you should just always
use CKRecordSaveIfUnchanged,

495
00:21:57.286 --> 00:22:00.846
that you should just always
use CKRecordSaveIfUnchanged,

496
00:22:01.436 --> 00:22:02.686
and it's the default.

497
00:22:02.686 --> 00:22:03.936
It's the default for a reason,

498
00:22:04.006 --> 00:22:05.896
and that's because
it's the safest.

499
00:22:06.086 --> 00:22:08.816
If you remember that example
of an unlocked update gone bad,

500
00:22:09.486 --> 00:22:11.676
you could end up with really
mixed-up, corrupt data

501
00:22:11.676 --> 00:22:13.626
on the server if you're
not using locking.

502
00:22:15.196 --> 00:22:17.446
However, there is
always a time and place

503
00:22:17.446 --> 00:22:19.226
for using unlocked updates.

504
00:22:19.816 --> 00:22:23.226
And the biggest case for these
are highly contentious updates.

505
00:22:23.746 --> 00:22:25.676
If you're doing anything
in the public database,

506
00:22:25.676 --> 00:22:27.886
you might have hundreds
or thousands or millions

507
00:22:27.886 --> 00:22:29.866
of clients accessing
it at the same time.

508
00:22:30.766 --> 00:22:33.706
And if every one of those
clients is trying to save if,

509
00:22:34.226 --> 00:22:36.706
save the same record and
you're locking on that,

510
00:22:37.616 --> 00:22:39.696
most of those clients are going
to be hitting locking errors,

511
00:22:39.736 --> 00:22:41.676
they're going to hit
conflicts, and they're going

512
00:22:41.676 --> 00:22:43.116
to be retrying really
frequently.

513
00:22:43.976 --> 00:22:46.456
So, if you know this is going to
be a really contentious update,

514
00:22:46.996 --> 00:22:50.096
you can structure your client
to do unlocked updates as long

515
00:22:50.096 --> 00:22:52.496
as you know you're always
writing consistent properties.

516
00:22:53.286 --> 00:22:55.636
On the case of that unlocked
update that failed, you know,

517
00:22:55.636 --> 00:22:57.786
you could make sure you
always write both the first

518
00:22:57.786 --> 00:23:00.196
and last name, and you
know it'll be consistent.

519
00:22:57.786 --> 00:23:00.196
and last name, and you
know it'll be consistent.

520
00:23:02.176 --> 00:23:05.956
The other reason to use an
unlocked update in the case

521
00:23:06.056 --> 00:23:07.666
of SaveAllKeys would
be if you want

522
00:23:07.696 --> 00:23:08.976
to force something
to the server.

523
00:23:09.086 --> 00:23:11.816
The client might say, you know,
the copy on the server is bad,

524
00:23:11.816 --> 00:23:13.716
but I know I have a good
copy of the record here.

525
00:23:14.296 --> 00:23:18.376
I want to just force that all
on top of the server's copy.

526
00:23:19.836 --> 00:23:23.566
There are some catches
to using SaveAllKeys,

527
00:23:23.606 --> 00:23:27.846
and one of the problems is
that any property on the server

528
00:23:28.406 --> 00:23:30.846
that doesn't exist in the
local record that you're trying

529
00:23:30.846 --> 00:23:32.276
to save isn't going

530
00:23:32.276 --> 00:23:36.116
to get removed unless
you explicitly remove

531
00:23:36.116 --> 00:23:37.676
that property on the record.

532
00:23:38.496 --> 00:23:41.536
All those words are
really confusing,

533
00:23:41.616 --> 00:23:43.006
and it's really hard to explain.

534
00:23:43.006 --> 00:23:44.346
So instead, I'm going
to try and explain

535
00:23:44.346 --> 00:23:45.266
that with the picture here.

536
00:23:46.376 --> 00:23:48.346
So, we've got our
contact record again.

537
00:23:48.436 --> 00:23:51.086
What we're going to do is
add a couple of properties.

538
00:23:51.086 --> 00:23:52.386
We're going to change
the first name,

539
00:23:52.386 --> 00:23:53.556
we're going to add
a new property,

540
00:23:54.006 --> 00:23:55.346
and we're going to
delete the hobby.

541
00:23:56.786 --> 00:23:59.756
We're now going to do a
SaveAllKeys to the server.

542
00:24:01.306 --> 00:24:04.316
What that's going to do is send
up all of these properties,

543
00:24:04.846 --> 00:24:07.986
even the ones we didn't change
locally, and they're going

544
00:24:07.986 --> 00:24:09.516
to update the values
on the server.

545
00:24:10.216 --> 00:24:12.026
But what you'll notice here is

546
00:24:12.026 --> 00:24:14.016
that the server had
an additional property

547
00:24:14.016 --> 00:24:17.446
that we didn't have in our
original copy of the record.

548
00:24:17.446 --> 00:24:19.406
This hometown property
wasn't removed.

549
00:24:20.736 --> 00:24:23.756
We do this to help you with
versioning of your app.

550
00:24:24.046 --> 00:24:28.156
You might release a version 2
of your app that adds hometowns

551
00:24:28.216 --> 00:24:30.386
but version 1 didn't ever
know about the hometown.

552
00:24:30.926 --> 00:24:33.506
And if version 1 was
using SaveAllKeys,

553
00:24:33.926 --> 00:24:35.966
it's going to overwrite these
properties on the server

554
00:24:35.966 --> 00:24:38.766
that it never knew about, and
that's kind of a bad thing.

555
00:24:38.766 --> 00:24:42.086
You can't have backwards
compatible code easily that way.

556
00:24:43.386 --> 00:24:46.406
So, what we do instead is we
still allow you to remove that,

557
00:24:46.496 --> 00:24:48.936
but you need to explicitly
tell us that you want

558
00:24:48.936 --> 00:24:50.416
that property deleted
on the server.

559
00:24:51.216 --> 00:24:53.376
So, even though there's
no hometown property

560
00:24:53.376 --> 00:24:57.696
on this record, we can still
call CKRecordSetValueForKey nil

561
00:24:58.066 --> 00:25:00.246
or we can call
removeObjectForKey.

562
00:24:58.066 --> 00:25:00.246
or we can call
removeObjectForKey.

563
00:25:01.246 --> 00:25:02.466
We're going to remove
the hometown,

564
00:25:02.466 --> 00:25:04.246
and now when we save
it up to the server,

565
00:25:04.526 --> 00:25:08.996
that delete will also
go up with the save.

566
00:25:09.146 --> 00:25:12.646
Finally, one of the really
neat things about CKRecord is

567
00:25:12.646 --> 00:25:14.346
that we allow you to
have partial records.

568
00:25:15.126 --> 00:25:17.736
So, you might have a really
big record on the server,

569
00:25:17.736 --> 00:25:20.056
and you only care about one
or two properties of that.

570
00:25:20.736 --> 00:25:23.346
Well, with the desiredKeys
property, we allow you

571
00:25:23.346 --> 00:25:26.306
to fetch just a certain
subset of the properties

572
00:25:26.306 --> 00:25:27.216
that are on the server.

573
00:25:28.546 --> 00:25:32.406
And we expose this desiredKeys
property on any operation

574
00:25:32.406 --> 00:25:34.116
that fetches a record,
so you're going to see it

575
00:25:34.116 --> 00:25:37.956
on CKFetchRecordsOperation,
CKQueryOperation,

576
00:25:37.956 --> 00:25:40.476
and
CKFetchRecordChangesOperation.

577
00:25:42.146 --> 00:25:43.346
And the really neat thing

578
00:25:43.346 --> 00:25:46.006
about this is you can then
take these partial records

579
00:25:46.006 --> 00:25:47.636
and save them back
up to the server.

580
00:25:47.716 --> 00:25:50.316
You don't need to work
with entirely full records.

581
00:25:50.856 --> 00:25:53.096
You can, you know, if you
want to update just one value

582
00:25:53.096 --> 00:25:55.676
on a record, fetch that
one value from the record,

583
00:25:55.796 --> 00:25:58.206
update it, and do a
save of just that record

584
00:25:58.206 --> 00:25:59.186
that has that one value.

585
00:25:59.836 --> 00:26:01.956
If you're doing this
with locking enabled,

586
00:25:59.836 --> 00:26:01.956
If you're doing this
with locking enabled,

587
00:26:02.306 --> 00:26:05.266
you know it's safe because
if the record is changed

588
00:26:05.266 --> 00:26:13.216
on the server since then,
you're going to get a conflict.

589
00:26:13.436 --> 00:26:14.736
So now, let's talk a little bit

590
00:26:14.736 --> 00:26:16.626
about modeling your
data for CloudKit.

591
00:26:17.976 --> 00:26:20.446
If we go back to that
example of a Receipts app,

592
00:26:20.796 --> 00:26:23.926
let's say we have a shoebox
that holds all our receipts

593
00:26:24.456 --> 00:26:27.126
and that's going to be
one object in the cloud,

594
00:26:27.596 --> 00:26:28.766
and we're going to
have an object

595
00:26:28.766 --> 00:26:29.946
for each one of our receipts.

596
00:26:31.036 --> 00:26:34.586
And the initial way you might
design this is you create a

597
00:26:34.586 --> 00:26:36.456
receipts array inside
of your shoebox,

598
00:26:37.156 --> 00:26:39.596
and every time you add a
new receipt, you're going

599
00:26:39.596 --> 00:26:42.576
to add new entry to that
array and that entry is going

600
00:26:42.576 --> 00:26:44.626
to be a reference to the
record you just created.

601
00:26:45.376 --> 00:26:47.136
We call these forward
references.

602
00:26:47.136 --> 00:26:49.636
These are references from
a parent to its child.

603
00:26:50.666 --> 00:26:52.086
And the problem with
these is that you end

604
00:26:52.086 --> 00:26:54.046
up getting bottlenecked
on that receipts array.

605
00:26:54.046 --> 00:26:57.746
If this was a public database,
you might have hundreds

606
00:26:57.746 --> 00:26:59.606
of clients trying to
save this record at once.

607
00:27:00.386 --> 00:27:03.166
And every time a client
tries to add a new record,

608
00:27:03.866 --> 00:27:06.616
they need to update that
array on the shoebox,

609
00:27:06.816 --> 00:27:08.976
and even though the clients
might be adding different

610
00:27:08.976 --> 00:27:13.216
records, different receipts,
they're all going to run

611
00:27:13.266 --> 00:27:16.376
into conflicts on the shoebox
app, or on the shoebox record.

612
00:27:17.146 --> 00:27:20.106
So, we recommend that you try
and avoid forward references

613
00:27:20.106 --> 00:27:24.496
in your design, and instead, use
what we call back references.

614
00:27:25.056 --> 00:27:26.886
So, instead of having
the shoebox point

615
00:27:26.886 --> 00:27:29.736
at the receipt that's in
it, have the receipt point

616
00:27:29.736 --> 00:27:30.906
at the shoebox that it's in.

617
00:27:32.506 --> 00:27:35.566
The great thing about this
is it's very scalable.

618
00:27:35.566 --> 00:27:39.376
You can have millions of clients
adding receipts all at once,

619
00:27:39.476 --> 00:27:40.586
and there's no bottleneck.

620
00:27:40.586 --> 00:27:42.956
They can create their receipt,
point at who owns them,

621
00:27:43.596 --> 00:27:47.296
and none of them are going
to run into conflicts.

622
00:27:47.296 --> 00:27:49.476
When you need to go get
everything that's in a shoebox,

623
00:27:49.476 --> 00:27:51.706
rather than fetching that
shoebox, getting the array

624
00:27:51.706 --> 00:27:54.186
of records in it, and
fetching all those records,

625
00:27:54.646 --> 00:27:56.186
you can instead just
use a query.

626
00:27:56.976 --> 00:27:59.636
That query is going to select
all of the records that have

627
00:27:59.636 --> 00:28:04.446
that shoebox as an owner.

628
00:27:59.636 --> 00:28:04.446
that shoebox as an owner.

629
00:28:04.446 --> 00:28:05.696
One other neat feature
we give you

630
00:28:05.696 --> 00:28:08.416
with the relationships
are cascading deletes.

631
00:28:09.116 --> 00:28:10.866
So, cascading deletes
are a way for you

632
00:28:10.866 --> 00:28:14.656
to make your object graph
get cleaned up automatically,

633
00:28:15.356 --> 00:28:17.556
and you do this by
marking your references

634
00:28:17.596 --> 00:28:20.356
with a
CKReferenceActionDeleteSelf,

635
00:28:21.036 --> 00:28:23.636
and that means that
when the record

636
00:28:23.636 --> 00:28:26.586
that you referenced is deleted,
you will also be deleted.

637
00:28:26.826 --> 00:28:28.616
In this case, the
green record has

638
00:28:28.676 --> 00:28:30.946
that reference action
pointed in the orange record.

639
00:28:31.646 --> 00:28:32.976
When the orange record
gets deleted,

640
00:28:33.476 --> 00:28:34.356
the green record is going

641
00:28:34.356 --> 00:28:36.266
to get automatically
deleted by the server.

642
00:28:38.016 --> 00:28:39.836
These deletes also cascade.

643
00:28:39.976 --> 00:28:42.556
So, if we had a whole
tree of objects hang off

644
00:28:42.556 --> 00:28:45.236
of that one orange record,
those deletes are going

645
00:28:45.236 --> 00:28:49.806
to cascade all the way down
and clean up our graph for us.

646
00:28:54.496 --> 00:28:56.076
But one thing to keep in mind

647
00:28:56.076 --> 00:28:57.986
with these delete
self references is

648
00:28:57.986 --> 00:29:00.216
that they're not
reference counted.

649
00:28:57.986 --> 00:29:00.216
that they're not
reference counted.

650
00:29:00.216 --> 00:29:03.606
That means that if you have
multiple references coming

651
00:29:03.606 --> 00:29:05.666
out of one record, the first one

652
00:29:05.666 --> 00:29:12.076
of those records that's deleted
will cause you to get deleted.

653
00:29:12.166 --> 00:29:16.436
And finally, these delete
self references give you one

654
00:29:16.436 --> 00:29:17.256
additional feature.

655
00:29:17.526 --> 00:29:20.866
If you're doing a batch save and
you've got a jumble of records

656
00:29:20.866 --> 00:29:23.666
in this graph, and they
have delete self references

657
00:29:23.666 --> 00:29:25.316
between them, CloudKit is going

658
00:29:25.316 --> 00:29:27.906
to do an automatic
topological sort for you.

659
00:29:27.906 --> 00:29:30.586
We're going to upload
the records in order

660
00:29:30.586 --> 00:29:33.146
so that all the records that
are referenced will be up there

661
00:29:33.146 --> 00:29:35.586
by the time the record
reference in them is uploaded.

662
00:29:36.076 --> 00:29:38.196
This is really great
in the public database

663
00:29:38.196 --> 00:29:41.606
where you don't have atomic
commits but you still want

664
00:29:41.606 --> 00:29:44.636
to be able to upload data that
looks consistent at any point

665
00:29:44.636 --> 00:29:46.326
when a client downloads it.

666
00:29:48.846 --> 00:29:51.956
So, while developing CloudKit
internally, we've had a couple

667
00:29:51.956 --> 00:29:54.016
of our clients ask us,
you know, why do I need

668
00:29:54.016 --> 00:29:55.346
to use these reference objects?

669
00:29:55.346 --> 00:29:58.306
I have to, you know, alloc and
omit and it's so much work.

670
00:29:58.306 --> 00:30:01.646
You know, I've got a record
ID, why can't I just put it

671
00:29:58.306 --> 00:30:01.646
You know, I've got a record
ID, why can't I just put it

672
00:30:01.646 --> 00:30:02.976
in the string and put
that in my record?

673
00:30:03.696 --> 00:30:04.896
You can, so, you know, you come

674
00:30:04.896 --> 00:30:06.806
up with this clever
little RecordIDToString,

675
00:30:07.366 --> 00:30:09.196
but then you look at
the recordID class

676
00:30:09.196 --> 00:30:11.696
and you realize it's
actually two properties,

677
00:30:11.696 --> 00:30:14.426
and you can't just store the
description of the record

678
00:30:14.426 --> 00:30:16.966
on the server so you
get a little smarter

679
00:30:16.966 --> 00:30:21.346
and you store the recordID
and the name and the zoneID.

680
00:30:21.986 --> 00:30:25.686
But then, you look at zoneID
and that's also composite.

681
00:30:26.426 --> 00:30:30.676
We need to know what, where
zone is and whose account it is.

682
00:30:31.256 --> 00:30:32.986
So, you get a little more clever

683
00:30:32.986 --> 00:30:34.976
and you make this
RecordIDToString

684
00:30:34.976 --> 00:30:39.066
and ZoneIDToString, and now
you call that everywhere.

685
00:30:39.226 --> 00:30:41.936
The problem is now you're
not forwards compatible.

686
00:30:42.006 --> 00:30:45.346
If anything ever gets added to
references, all of your records

687
00:30:45.346 --> 00:30:47.856
on the server are already going
to have this hard coded format,

688
00:30:48.256 --> 00:30:49.996
and you're going to have
to go through a lot of work

689
00:30:49.996 --> 00:30:51.156
when you query records.

690
00:30:52.316 --> 00:30:54.726
Instead, just use references.

691
00:30:54.726 --> 00:30:56.166
It's going to make
your code really clean.

692
00:30:56.166 --> 00:30:58.356
I mean that shoebox
could be a recordID,

693
00:30:58.356 --> 00:31:01.106
that shoebox could be a record
itself, it could be a reference.

694
00:30:58.356 --> 00:31:01.106
that shoebox could be a record
itself, it could be a reference.

695
00:31:01.566 --> 00:31:04.046
All of those will just work as
long as you use the CKReference.

696
00:31:04.946 --> 00:31:10.556
A couple last notes on
modeling your data in CloudKit.

697
00:31:11.896 --> 00:31:14.866
One of them is that CloudKit
is a transport mechanism.

698
00:31:14.986 --> 00:31:17.776
What we've tried to do here
is give you an easy way

699
00:31:17.776 --> 00:31:21.446
to access the CloudKit
servers, but we're not meant

700
00:31:21.446 --> 00:31:23.296
to be a local persistence layer.

701
00:31:23.296 --> 00:31:26.516
We want that to be up to
you, and you need to figure

702
00:31:26.516 --> 00:31:28.096
out the best way to
store your objects.

703
00:31:28.746 --> 00:31:33.336
And to that extent, we recommend
that you don't subclass CKItems.

704
00:31:33.526 --> 00:31:36.516
You should take those items when
you receive them from the server

705
00:31:37.216 --> 00:31:40.896
and translate them into your own
model objects, and you can do

706
00:31:40.896 --> 00:31:42.046
that on the way out as well.

707
00:31:42.046 --> 00:31:44.606
When you need to save one of
your model objects, translate it

708
00:31:44.606 --> 00:31:55.036
into a CKRecord and upload
all of that to the server.

709
00:31:55.216 --> 00:31:57.136
So, if you remember from
the introductory talk,

710
00:31:57.136 --> 00:31:59.466
we have these things that
we call subscriptions.

711
00:31:59.596 --> 00:32:01.686
They're persistent queries
that run on the server,

712
00:31:59.596 --> 00:32:01.686
They're persistent queries
that run on the server,

713
00:32:02.536 --> 00:32:05.396
and every time something
changes that matches that query,

714
00:32:06.186 --> 00:32:07.616
you're going to get
a push notification.

715
00:32:08.546 --> 00:32:11.206
And these push notifications
are sent via the Apple Push

716
00:32:11.206 --> 00:32:14.026
Notification Service, just the
same way that it would work

717
00:32:14.026 --> 00:32:15.106
if you built your own server.

718
00:32:16.766 --> 00:32:18.356
But there are some drawbacks

719
00:32:18.356 --> 00:32:20.336
with Apple Push Notification
Service.

720
00:32:20.336 --> 00:32:22.966
One of them is that they
can't make any guarantees

721
00:32:22.966 --> 00:32:24.366
on delivery of these pushes.

722
00:32:24.446 --> 00:32:26.536
They're kind of meant to
be these ephemeral, little,

723
00:32:26.536 --> 00:32:28.086
you know, here's a
push, here's a push.

724
00:32:28.586 --> 00:32:31.096
If one of them gets dropped
because of a bad network

725
00:32:31.096 --> 00:32:35.306
or anything else going
on, there's no guarantee.

726
00:32:35.636 --> 00:32:37.316
So, in practice,
they're really good

727
00:32:37.316 --> 00:32:38.536
about delivering these pushes.

728
00:32:39.006 --> 00:32:40.606
And one of the reasons is

729
00:32:40.656 --> 00:32:42.346
because the server
will store pushes

730
00:32:42.346 --> 00:32:43.596
for you if you're offline.

731
00:32:44.246 --> 00:32:45.936
So, if you put your
phone in Airplane Mode

732
00:32:45.936 --> 00:32:48.216
and you get a push, as
soon as you come back

733
00:32:48.216 --> 00:32:50.366
out of Airplane Mode, the
server will have that saved

734
00:32:50.366 --> 00:32:51.806
and still deliver
the push on to you.

735
00:32:52.976 --> 00:32:56.226
But the problem with this is
the server only stores one push

736
00:32:56.296 --> 00:32:56.796
per client.

737
00:32:57.776 --> 00:33:00.376
So, if you received a bunch of
pushes while you're offline,

738
00:32:57.776 --> 00:33:00.376
So, if you received a bunch of
pushes while you're offline,

739
00:33:00.376 --> 00:33:02.086
you're only going to
get the most recent one.

740
00:33:03.676 --> 00:33:04.416
What does that look like?

741
00:33:04.456 --> 00:33:07.026
Well, we've got our
CloudKit server,

742
00:33:07.026 --> 00:33:09.866
we've got the APS server, and
we've got the iPhone up here.

743
00:33:10.366 --> 00:33:13.486
And we send a push, and we're
online, everything goes through,

744
00:33:13.486 --> 00:33:15.036
we get our badge,
everyone's happy.

745
00:33:16.536 --> 00:33:18.196
But then, we get on an airplane.

746
00:33:18.196 --> 00:33:21.126
Our phone is in Airplane Mode;
we have no network connection.

747
00:33:22.136 --> 00:33:24.176
And when that push gets sent,

748
00:33:24.176 --> 00:33:26.176
the APS server helpfully
stores it for us.

749
00:33:26.306 --> 00:33:28.126
If we were going to come
back online right now,

750
00:33:28.126 --> 00:33:30.636
we would get our subscription
push and we'd be happy.

751
00:33:31.626 --> 00:33:34.596
But this is a long plane flight
and while we're on the plane,

752
00:33:34.716 --> 00:33:37.696
we got a zone update push,
that new zone subscription

753
00:33:37.696 --> 00:33:38.546
that I was talking about.

754
00:33:39.556 --> 00:33:42.916
When that gets to the APS
server, it's going to drop

755
00:33:42.916 --> 00:33:44.416
that previous subscription push,

756
00:33:44.916 --> 00:33:48.296
and now when your phone comes
back online, all you're going

757
00:33:48.296 --> 00:33:49.566
to receive is the zone update.

758
00:33:51.096 --> 00:33:52.736
The problem with this
is that you never heard

759
00:33:52.736 --> 00:33:54.096
about that subscription
that fired.

760
00:33:54.806 --> 00:33:56.016
So, how do we solve this?

761
00:33:56.016 --> 00:33:59.356
Well, we've created a
notification collection

762
00:33:59.356 --> 00:34:00.006
in CloudKit.

763
00:33:59.356 --> 00:34:00.006
in CloudKit.

764
00:34:01.406 --> 00:34:04.376
Every time the server sends
a push to the APS server,

765
00:34:04.836 --> 00:34:06.616
it also makes a copy
of that push

766
00:34:06.616 --> 00:34:07.936
in the notification collection.

767
00:34:08.896 --> 00:34:11.356
So, you can see we have that
same problem where we're

768
00:34:11.356 --> 00:34:13.686
in Airplane Mode, we dropped
our subscription push,

769
00:34:14.446 --> 00:34:16.346
our phone comes online,
and it gets the push,

770
00:34:17.416 --> 00:34:19.406
and because this is a
well-behaved client,

771
00:34:19.406 --> 00:34:21.485
it knows every time
it receives a push,

772
00:34:21.545 --> 00:34:23.726
it should go check the
notification collection to find

773
00:34:23.726 --> 00:34:25.846
out about anything
it might have missed.

774
00:34:26.896 --> 00:34:28.116
So, how does that work?

775
00:34:28.116 --> 00:34:30.786
Well, this notification
collection is a lot

776
00:34:30.786 --> 00:34:32.686
like the delta downloads
I talked about earlier.

777
00:34:33.275 --> 00:34:34.676
It's all change token-based.

778
00:34:35.126 --> 00:34:36.656
You hand a change
token to the server,

779
00:34:37.005 --> 00:34:39.116
and the server hands back
all the notifications

780
00:34:39.116 --> 00:34:41.016
that have changed
since then along

781
00:34:41.016 --> 00:34:42.255
with an updated change token.

782
00:34:42.826 --> 00:34:45.716
So, since this is our
first time talking

783
00:34:45.716 --> 00:34:47.366
to the notification
collection, we're going to send

784
00:34:47.366 --> 00:34:48.456
up a nil change token.

785
00:34:49.576 --> 00:34:51.676
We're going to get back
both of those pushes,

786
00:34:51.676 --> 00:34:53.045
one of them which we missed.

787
00:34:53.525 --> 00:34:57.005
And then we're also going to
get an updated change token

788
00:34:57.005 --> 00:34:59.566
for the current state.

789
00:35:00.376 --> 00:35:04.396
One thing with subscriptions is
that you might want to use those

790
00:35:04.396 --> 00:35:06.516
to change some UI
in your application.

791
00:35:07.056 --> 00:35:10.946
For example in our Receipts app,
we might want a subscription

792
00:35:11.006 --> 00:35:14.176
for any receipt that
was over 100 dollars.

793
00:35:14.176 --> 00:35:16.986
If that happens, we want to mark

794
00:35:17.626 --> 00:35:19.256
that receipt in a
different color.

795
00:35:19.446 --> 00:35:21.736
So we're going to get this
push for a subscription,

796
00:35:22.656 --> 00:35:24.226
and now that receipt is blue

797
00:35:24.226 --> 00:35:26.036
because it was a big
expensive receipt.

798
00:35:27.396 --> 00:35:30.046
But, you know, this is going
to happen on all your clients,

799
00:35:30.046 --> 00:35:32.336
so you're going to have you iPad
showing that receipt in blue,

800
00:35:32.336 --> 00:35:34.536
you're going to have your Mac
showing that receipt in blue,

801
00:35:35.016 --> 00:35:38.356
and once this acknowledges
it, you want that UI state

802
00:35:38.396 --> 00:35:40.776
to go away on all your clients.

803
00:35:41.666 --> 00:35:44.476
Well, the way we do that is we
let you mark a subscription,

804
00:35:44.646 --> 00:35:46.806
sorry, we let you mark
a notification as red.

805
00:35:46.856 --> 00:35:49.366
And when you do that,
you're going to get a push

806
00:35:49.366 --> 00:35:51.576
for the updated subscription,

807
00:35:51.856 --> 00:35:53.816
updated notification
on every client.

808
00:35:54.486 --> 00:35:56.136
So, in this case,
we mark our receipt.

809
00:35:56.136 --> 00:35:58.826
We're going to go mark
that subscription as red

810
00:35:58.826 --> 00:36:00.846
on the server, and now
there's a new entry.

811
00:35:58.826 --> 00:36:00.846
on the server, and now
there's a new entry.

812
00:36:02.406 --> 00:36:04.786
And if we switch over to our
Mac which is still showing it

813
00:36:04.786 --> 00:36:06.286
in blue, it's going
to get a push,

814
00:36:06.516 --> 00:36:08.356
it's going to check the
notification collection,

815
00:36:09.126 --> 00:36:11.856
it's going to get that
subscription notification,

816
00:36:12.006 --> 00:36:14.466
and it can tear down
its UI and now all

817
00:36:14.466 --> 00:36:16.926
of your clients are
in the same state.

818
00:36:19.426 --> 00:36:20.966
So, with the notification
collection,

819
00:36:20.966 --> 00:36:22.976
keep in mind every
time you get a push,

820
00:36:22.976 --> 00:36:24.826
you should check the
notification collection.

821
00:36:25.086 --> 00:36:27.306
You never know what
you might have missed.

822
00:36:28.236 --> 00:36:31.366
And this isn't just for
Airplane Mode or bad networks.

823
00:36:31.526 --> 00:36:34.946
This can happen if you get
multiple pushes in a row.

824
00:36:34.946 --> 00:36:36.836
If there's a lot of changes
that happen all at once,

825
00:36:37.376 --> 00:36:39.256
the CloudKit server
might coalesce them,

826
00:36:39.256 --> 00:36:43.646
or the push server might
coalesce those pushes.

827
00:36:43.646 --> 00:36:46.836
And of course, because a lot
of these are mobile devices,

828
00:36:46.836 --> 00:36:48.966
they're iPhones, they're
going to be moving in

829
00:36:48.966 --> 00:36:50.056
and out of network states.

830
00:36:50.096 --> 00:36:53.786
They might be on Wi-Fi, or they
might be on a bad cell network.

831
00:36:53.786 --> 00:36:55.516
You never know what
your network is like.

832
00:36:56.356 --> 00:36:58.686
Just assume that there
might have been more pushes

833
00:36:58.726 --> 00:37:00.206
that you didn't hear about.

834
00:36:58.726 --> 00:37:00.206
that you didn't hear about.

835
00:37:04.176 --> 00:37:06.696
So, now we're going to go
over the iCloud Dashboard.

836
00:37:07.036 --> 00:37:09.996
And the iCloud Dashboard
is our web-based interface

837
00:37:10.076 --> 00:37:13.166
for managing your
application in CloudKit.

838
00:37:14.536 --> 00:37:17.346
The iCloud Dashboard
lets you view your data.

839
00:37:18.076 --> 00:37:20.636
It lets you manage the schema
that we're creating for you.

840
00:37:21.666 --> 00:37:25.926
It lets you control what's
indexed, and it helps you moving

841
00:37:25.926 --> 00:37:27.136
from development to production.

842
00:37:27.136 --> 00:37:29.486
I'm going to explain all of
those in detail in a bit.

843
00:37:29.756 --> 00:37:31.526
Let's start with viewing data.

844
00:37:33.596 --> 00:37:38.166
So, if you remember the view
of our containers up here,

845
00:37:38.166 --> 00:37:40.466
we've got a public database
and a private database.

846
00:37:41.556 --> 00:37:44.706
And when you're viewing your
data in the iCloud Dashboard,

847
00:37:45.426 --> 00:37:48.506
all of that data in the public
database is of course public.

848
00:37:48.936 --> 00:37:52.356
So, in the dashboard, you'll
be able to see every record

849
00:37:52.356 --> 00:37:53.536
in your public database.

850
00:37:54.996 --> 00:37:58.266
But if you remember, the private
database is again one database

851
00:37:58.336 --> 00:37:59.706
for each individual user.

852
00:38:00.646 --> 00:38:03.266
And in this case, we're
only logged in as one user.

853
00:38:03.266 --> 00:38:04.976
We're logged in as
our developer account.

854
00:38:05.826 --> 00:38:09.126
So, all we're going to see in
the iCloud Dashboard is the data

855
00:38:09.426 --> 00:38:13.036
in the private database
for our developer account.

856
00:38:13.036 --> 00:38:13.966
This is really important.

857
00:38:13.966 --> 00:38:16.006
You know, you might use a
different account for testing

858
00:38:16.006 --> 00:38:17.586
and a different account
for viewing data

859
00:38:17.586 --> 00:38:18.696
in the iCloud Dashboard.

860
00:38:19.196 --> 00:38:20.476
If you do that, you
won't be able

861
00:38:20.476 --> 00:38:22.696
to view your private
data in the dashboard.

862
00:38:22.696 --> 00:38:26.226
So, what does the
dashboard look like?

863
00:38:26.266 --> 00:38:29.736
Well, we log in, and the
first thing we're going

864
00:38:29.736 --> 00:38:31.856
to see here are our
different record types.

865
00:38:32.376 --> 00:38:34.856
So, you can see we're
using the Party app.

866
00:38:34.856 --> 00:38:37.226
We've got parties,
and over here,

867
00:38:37.226 --> 00:38:39.476
we see the different schema

868
00:38:39.576 --> 00:38:41.676
for those values
that's been created.

869
00:38:43.426 --> 00:38:45.556
When you're developing
a CloudKit application,

870
00:38:45.996 --> 00:38:47.736
you're talking at the
development environment,

871
00:38:48.386 --> 00:38:49.286
and the server

872
00:38:49.286 --> 00:38:52.166
in the development environment
creates a just-in-time schema

873
00:38:52.246 --> 00:38:52.566
for you.

874
00:38:53.256 --> 00:38:55.946
So, we did this because we
wanted you to be able to develop

875
00:38:55.946 --> 00:38:57.256
as rapidly as possible.

876
00:38:57.256 --> 00:39:01.706
We didn't want you have to go
to a, this dashboard and plan

877
00:38:57.256 --> 00:39:01.706
We didn't want you have to go
to a, this dashboard and plan

878
00:39:01.706 --> 00:39:03.576
out what you were going
to do in your application

879
00:39:03.576 --> 00:39:05.066
and choose all the data types.

880
00:39:05.066 --> 00:39:07.746
That's not as much fun as
just writing some code.

881
00:39:08.016 --> 00:39:10.856
So, we let you dive right
in, you write some code,

882
00:39:11.436 --> 00:39:14.726
and the things that you upload
to CloudKit as you upload them,

883
00:39:15.146 --> 00:39:17.376
those values get
locked in into a schema.

884
00:39:18.526 --> 00:39:20.496
So, you can see here
that we've got a couple

885
00:39:20.496 --> 00:39:23.426
of different values, and we've
got their, couple different keys

886
00:39:23.426 --> 00:39:26.146
and their values but we
notice that we made a mistake

887
00:39:26.146 --> 00:39:27.476
when we're developing this app.

888
00:39:27.666 --> 00:39:30.666
We uploaded a date
value or a date key,

889
00:39:31.106 --> 00:39:32.276
but we use a string value.

890
00:39:32.276 --> 00:39:34.136
And what we really want
there is a date value.

891
00:39:34.886 --> 00:39:37.306
The iCloud Dashboard is
going to let us fix that up.

892
00:39:37.826 --> 00:39:40.026
So we can go to this
and we can delete it.

893
00:39:41.016 --> 00:39:42.386
We can remove it
from our schema,

894
00:39:43.336 --> 00:39:46.296
and now we can recompile
our app, use a date value,

895
00:39:46.756 --> 00:39:49.696
upload that record again,
and when the server sees

896
00:39:49.696 --> 00:39:52.446
that record, it will
create a new schema entry

897
00:39:52.556 --> 00:39:59.866
for the date value using an
actual date instead of a string.

898
00:40:00.066 --> 00:40:02.306
So next up, you can
view all the records

899
00:40:02.306 --> 00:40:05.376
in your public database
using the iCloud Dashboard.

900
00:40:05.696 --> 00:40:07.486
So, you can see here,
we already have a couple

901
00:40:07.486 --> 00:40:09.496
of different parties
in the public database.

902
00:40:10.736 --> 00:40:14.306
What you can also do is create
records in the public database.

903
00:40:14.396 --> 00:40:18.356
So, you can tap on this Plus
button and fill out a new entry.

904
00:40:19.026 --> 00:40:22.226
We're going to make a new
party for coffee on Friday,

905
00:40:23.276 --> 00:40:26.966
and we can save that and you'll
see that that actually got saved

906
00:40:27.036 --> 00:40:28.276
into the public database.

907
00:40:28.316 --> 00:40:31.256
Any clients that are fetching
records are going to see

908
00:40:31.256 --> 00:40:33.316
that change in the
public database.

909
00:40:33.876 --> 00:40:37.796
We can also search for records.

910
00:40:37.796 --> 00:40:39.136
This is just like CKQuery.

911
00:40:39.136 --> 00:40:41.866
So we can click on
that magnifying glass,

912
00:40:42.816 --> 00:40:46.326
and we can type any
string, and we can filter

913
00:40:46.326 --> 00:40:49.316
down to any party
that mentions WWDC.

914
00:40:50.566 --> 00:40:52.856
Additionally, this gives
us all the functionality

915
00:40:52.856 --> 00:40:54.246
that we have in CKQuery.

916
00:40:54.246 --> 00:40:56.836
We can build compound queries
right in the dashboard.

917
00:40:57.326 --> 00:41:01.516
So, if you click on the Plus
button, let's choose location,

918
00:40:57.326 --> 00:41:01.516
So, if you click on the Plus
button, let's choose location,

919
00:41:01.516 --> 00:41:03.716
and let's filter down
to everything that's

920
00:41:03.716 --> 00:41:06.246
within 5 kilometers
of Moscone Center.

921
00:41:06.366 --> 00:41:08.016
I happen to have
those memorized.

922
00:41:08.636 --> 00:41:12.826
So, that filtered everything
down just to the two parties

923
00:41:12.826 --> 00:41:13.726
that are in this area.

924
00:41:16.556 --> 00:41:18.766
Finally, in the public database,

925
00:41:19.076 --> 00:41:22.336
by default every record
can be read by every user,

926
00:41:23.346 --> 00:41:25.426
and it can be created
by any user.

927
00:41:25.726 --> 00:41:29.016
Once you create a record, that
record can only be updated

928
00:41:29.016 --> 00:41:31.096
or deleted by the
user that created it.

929
00:41:32.106 --> 00:41:34.296
But we understand that that
doesn't provide all the

930
00:41:34.296 --> 00:41:36.746
functionality that you might
need to make an application

931
00:41:36.746 --> 00:41:37.766
in the public database.

932
00:41:38.356 --> 00:41:41.186
So, what we've given you
are what we call roles.

933
00:41:41.186 --> 00:41:44.106
These roles let you
choose sets of users

934
00:41:44.106 --> 00:41:46.606
that have different
permissions for record types

935
00:41:46.606 --> 00:41:47.696
in the public database.

936
00:41:48.566 --> 00:41:52.156
So, one example of that might
be that I want to restrict it

937
00:41:52.156 --> 00:41:55.056
so that only I can create
parties in the public database.

938
00:41:55.716 --> 00:41:57.106
So, what I'm going
to do in order to do

939
00:41:57.106 --> 00:41:58.556
that is create a new role.

940
00:41:58.556 --> 00:42:04.336
I'm going to call this, you
know, PartyAdmin, and in that,

941
00:41:58.556 --> 00:42:04.336
I'm going to call this, you
know, PartyAdmin, and in that,

942
00:42:04.336 --> 00:42:07.206
I need to choose a record type
and give it special permissions.

943
00:42:07.286 --> 00:42:11.676
So I'm going to choose parties,
and I'm going to give it Create,

944
00:42:11.676 --> 00:42:13.586
Read, and Write permissions
for those parties.

945
00:42:16.466 --> 00:42:19.596
Now, what I need to do is go to
the record type and restrict it

946
00:42:19.596 --> 00:42:21.366
so that no one else
can create a party.

947
00:42:21.756 --> 00:42:25.586
So, I'm going to find my
party, my party record type,

948
00:42:26.106 --> 00:42:29.376
and you can see up there
that parties can be created

949
00:42:29.376 --> 00:42:30.666
by anyone who's authenticated.

950
00:42:31.226 --> 00:42:33.496
We don't want that, we
want only party admins

951
00:42:33.536 --> 00:42:34.416
to create this record.

952
00:42:34.506 --> 00:42:38.296
So, we're going to
uncheck that value.

953
00:42:38.386 --> 00:42:40.626
Now, we need to assign
people to that role

954
00:42:40.696 --> 00:42:42.976
so that there's actually users
out there that can do this.

955
00:42:43.796 --> 00:42:45.246
If we go to the user records,

956
00:42:45.246 --> 00:42:47.776
we can see everyone who's
used this app so far.

957
00:42:48.626 --> 00:42:51.636
If they have marked themselves
as discoverable, you're going

958
00:42:51.636 --> 00:42:53.306
to be able to see their
first and last name.

959
00:42:53.756 --> 00:42:55.296
If they haven't,
you're just going to see

960
00:42:55.296 --> 00:42:57.826
that recordID up there.

961
00:42:58.036 --> 00:43:01.396
So, I'm going to click on
my user, and then I'm going

962
00:42:58.036 --> 00:43:01.396
So, I'm going to click on
my user, and then I'm going

963
00:43:01.396 --> 00:43:05.976
to add myself as a party admin.

964
00:43:05.976 --> 00:43:08.326
And now, I'm the only user
in the public database

965
00:43:08.396 --> 00:43:11.676
that can create a party.

966
00:43:13.516 --> 00:43:18.486
[ Applause ]

967
00:43:18.986 --> 00:43:22.626
So, one of the last things the
iCloud Dashboard helps you do is

968
00:43:22.626 --> 00:43:25.066
move from development
into production.

969
00:43:25.376 --> 00:43:27.186
So, as I talked about earlier,

970
00:43:27.286 --> 00:43:29.986
we wanted the development
environment to be as quick

971
00:43:29.986 --> 00:43:31.556
and easy to use as possible.

972
00:43:32.056 --> 00:43:34.076
We wanted you to hit the
ground running, we wanted you

973
00:43:34.076 --> 00:43:37.046
to just open up Xcode,
start typing some code,

974
00:43:37.046 --> 00:43:39.806
save your record to the server,
and see immediate results.

975
00:43:40.496 --> 00:43:43.786
And that all works great because
the server does just-in-time

976
00:43:43.786 --> 00:43:47.256
schemas, but that's not very
efficient if we're working

977
00:43:47.256 --> 00:43:49.986
in a public database that
might have millions of users.

978
00:43:50.066 --> 00:43:52.916
We need to prepare some
things before we go

979
00:43:52.916 --> 00:43:55.946
into the environment that all of
our customers are going to hit.

980
00:43:56.656 --> 00:43:59.216
So, the way this works
is we've got our records,

981
00:43:59.326 --> 00:44:00.696
we're developing
our app right now,

982
00:43:59.326 --> 00:44:00.696
we're developing
our app right now,

983
00:44:01.586 --> 00:44:03.916
and we just created a record
for the very first time,

984
00:44:03.916 --> 00:44:05.896
and we uploaded it in the
development environment.

985
00:44:07.076 --> 00:44:08.206
The server is going to see that

986
00:44:08.256 --> 00:44:10.656
and since this is the first
time it's seen a party,

987
00:44:10.656 --> 00:44:13.316
it's going to automatically
create a new party record type.

988
00:44:13.316 --> 00:44:16.556
And then for each of
these keys and values,

989
00:44:17.056 --> 00:44:19.986
it's going to create an entry
in a schema, and it's going

990
00:44:19.986 --> 00:44:22.206
to create an index on
every one of those values.

991
00:44:23.316 --> 00:44:26.606
This index is what lets you
query for any value in a record.

992
00:44:27.096 --> 00:44:29.656
So, while you're in development,
you can just run a query

993
00:44:29.656 --> 00:44:32.506
and search on any value
for any key in a record.

994
00:44:33.966 --> 00:44:36.196
And let's say we're going ahead
and we're developing this app

995
00:44:36.196 --> 00:44:38.686
and we decide we want to
add an additional property,

996
00:44:38.686 --> 00:44:42.116
so we decide we want to
have a background property

997
00:44:42.116 --> 00:44:43.356
for the color of the party.

998
00:44:43.916 --> 00:44:45.556
So, this party's
background is blue.

999
00:44:46.046 --> 00:44:47.556
All we have to do is
upload that record.

1000
00:44:48.116 --> 00:44:50.566
It's going to send all those
other properties to the index,

1001
00:44:51.156 --> 00:44:52.936
and the server is
going to notice, "Oh,

1002
00:44:52.936 --> 00:44:54.056
there's a new property in here."

1003
00:44:54.546 --> 00:44:57.146
It's going to create a new
schema entry, build a new index,

1004
00:44:57.536 --> 00:44:58.606
and index that property.

1005
00:45:00.536 --> 00:45:03.006
When you're ready to release
your app, you're going to want

1006
00:45:03.006 --> 00:45:05.406
to make sure you've run
everything in development first

1007
00:45:05.506 --> 00:45:07.466
so that you've built up
this just-in-time schema.

1008
00:45:08.726 --> 00:45:11.476
You're then going to use
the iCloud Dashboard to move

1009
00:45:11.476 --> 00:45:13.896
that schema from
development into production,

1010
00:45:13.896 --> 00:45:15.826
and you're going to want to
check all of these fields

1011
00:45:15.826 --> 00:45:17.316
to make sure that
they're the right values,

1012
00:45:17.836 --> 00:45:19.066
make sure that every key

1013
00:45:19.066 --> 00:45:21.706
that your app will ever
use exists in the schema.

1014
00:45:22.646 --> 00:45:25.146
And when you do that, you're
going to move it into production

1015
00:45:25.146 --> 00:45:26.476
and lock that schema in.

1016
00:45:28.066 --> 00:45:31.406
Additionally, all of these
indexes take up a decent amount

1017
00:45:31.406 --> 00:45:33.306
of space because
it has to make it

1018
00:45:33.306 --> 00:45:35.926
so that you can query
those records.

1019
00:45:35.926 --> 00:45:38.216
If you know you're never
going to query a value

1020
00:45:38.216 --> 00:45:40.266
like we know we're never
going to query for records

1021
00:45:40.266 --> 00:45:43.636
with just a blue background,
you can drop that index,

1022
00:45:43.686 --> 00:45:47.036
and this will help free up some
space in your app's database

1023
00:45:47.036 --> 00:45:48.746
or in your user's database.

1024
00:45:51.716 --> 00:45:54.886
So, finally, a couple
CloudKit tips and tricks.

1025
00:45:56.286 --> 00:45:57.866
So, we already went over this

1026
00:45:57.866 --> 00:46:00.286
in the intro talk
about error handling.

1027
00:45:57.866 --> 00:46:00.286
in the intro talk
about error handling.

1028
00:46:00.716 --> 00:46:02.346
Please handle your
errors in CloudKit.

1029
00:46:02.416 --> 00:46:03.486
This is really important.

1030
00:46:03.536 --> 00:46:07.496
I know error handling is
hard and it's not fun to do,

1031
00:46:07.946 --> 00:46:11.886
but CloudKit is all based
on network communication.

1032
00:46:12.526 --> 00:46:15.716
And when you're talking over the
network, anything can go wrong.

1033
00:46:16.526 --> 00:46:18.256
You know, the network
can get dropped.

1034
00:46:18.256 --> 00:46:20.096
Because we have other
people talking

1035
00:46:20.096 --> 00:46:21.706
to the server, we
can get conflicts.

1036
00:46:21.706 --> 00:46:22.526
We can get errors.

1037
00:46:23.146 --> 00:46:26.646
All kinds of things can
happen, and as Paul said

1038
00:46:26.646 --> 00:46:29.876
in the first talk, this is the
difference between a working app

1039
00:46:29.876 --> 00:46:30.976
and a not working app.

1040
00:46:30.976 --> 00:46:34.606
It's not the difference between
a good app and a great app.

1041
00:46:34.606 --> 00:46:36.096
If you don't handle errors,

1042
00:46:36.176 --> 00:46:39.446
your app just isn't
going to work right.

1043
00:46:39.646 --> 00:46:42.786
In CloudKit also, we've tried
to avoid any sort of magic.

1044
00:46:42.906 --> 00:46:46.376
We don't want to try and handle
these errors for you and figure

1045
00:46:46.376 --> 00:46:47.406
out what might be best.

1046
00:46:47.896 --> 00:46:50.556
We want to just tell
you what happened.

1047
00:46:50.556 --> 00:46:53.306
We want you to be able to figure
out what you need to do next,

1048
00:46:53.306 --> 00:46:56.896
and we want to give you all
the information to do that.

1049
00:46:57.136 --> 00:46:59.236
So, keep in mind when you're
handling your errors here

1050
00:46:59.236 --> 00:47:01.566
that your operations
can have partial errors.

1051
00:46:59.236 --> 00:47:01.566
that your operations
can have partial errors.

1052
00:47:02.036 --> 00:47:05.316
These partial errors when you're
using the NSOperation API,

1053
00:47:05.316 --> 00:47:07.746
you might be sending
up a batch of records.

1054
00:47:08.406 --> 00:47:10.636
And if you're saving them
to the public database,

1055
00:47:10.736 --> 00:47:12.806
it could be the case
that just one

1056
00:47:12.806 --> 00:47:15.746
of those records had a conflict
but the rest saved just fine.

1057
00:47:16.526 --> 00:47:18.626
If that happens, you're
going to get a partial error,

1058
00:47:18.746 --> 00:47:20.876
and inside of that, you're
going to find one error

1059
00:47:20.876 --> 00:47:21.966
for the record that failed.

1060
00:47:22.816 --> 00:47:25.386
If this was in a custom
zone, you might see

1061
00:47:25.386 --> 00:47:27.276
that as an atomic update error.

1062
00:47:27.276 --> 00:47:30.006
So, you might see that one
of those records failed,

1063
00:47:30.006 --> 00:47:33.366
and the rest got the
batch error in there.

1064
00:47:34.356 --> 00:47:37.096
And finally, we want
you to make sure

1065
00:47:37.096 --> 00:47:39.436
that you retry any
server busy errors.

1066
00:47:40.176 --> 00:47:42.476
It could be the case
that the, you know,

1067
00:47:42.546 --> 00:47:45.046
a bunch of people are going at
the servers at the same time

1068
00:47:45.046 --> 00:47:46.236
and the servers can't handle it

1069
00:47:46.236 --> 00:47:47.906
and they need clients
to back off.

1070
00:47:48.096 --> 00:47:50.686
It could also be that
your client is misbehaving

1071
00:47:50.686 --> 00:47:52.286
and hitting the server
too frequently,

1072
00:47:52.286 --> 00:47:55.686
and the server is saying,
"Slow down, buddy."

1073
00:47:55.686 --> 00:47:57.556
This is our way of
saying, "You know,

1074
00:47:57.556 --> 00:47:58.656
we need a little more time.

1075
00:47:58.656 --> 00:48:00.796
This request was OK, but
please try it again".

1076
00:47:58.656 --> 00:48:00.796
This request was OK, but
please try it again".

1077
00:48:01.426 --> 00:48:03.556
And anytime we give you
a server busy error,

1078
00:48:03.556 --> 00:48:06.496
we're going to hand back
a CKErrorRetryAfterKey.

1079
00:48:07.026 --> 00:48:09.456
This is a number of seconds
that we'd like you to wait

1080
00:48:09.456 --> 00:48:11.426
and retry your request.

1081
00:48:14.116 --> 00:48:17.046
So, limits, in the
keynote, it was mentioned

1082
00:48:17.046 --> 00:48:18.936
that CloudKit is
free with limits.

1083
00:48:19.556 --> 00:48:21.326
How do those limits work?

1084
00:48:21.326 --> 00:48:25.116
Well, anything stored in the
public database is counted

1085
00:48:25.116 --> 00:48:26.336
against your app's quota.

1086
00:48:26.386 --> 00:48:29.766
We give every app a
quota, and that's just

1087
00:48:29.766 --> 00:48:30.626
for the public database.

1088
00:48:31.726 --> 00:48:34.086
Anything you put in the
private database is counted

1089
00:48:34.086 --> 00:48:35.516
against the user's account.

1090
00:48:35.706 --> 00:48:39.656
So, every iCloud account gets
5 gigabytes of free storage,

1091
00:48:40.146 --> 00:48:43.446
but users might have bought
more, or they might have filled

1092
00:48:43.446 --> 00:48:46.356
up all that space with
emails or backups or photos.

1093
00:48:46.866 --> 00:48:48.796
So, every user is going
to have a different amount

1094
00:48:48.796 --> 00:48:49.516
of storage in there.

1095
00:48:50.126 --> 00:48:52.216
And because this is
kind of the user space

1096
00:48:52.216 --> 00:48:54.116
and it's shared space,
we want you to, you know,

1097
00:48:54.346 --> 00:48:55.916
remember to be nice
to your users.

1098
00:48:55.916 --> 00:49:01.086
It's technically free space for
you because it's theirs but,

1099
00:48:55.916 --> 00:49:01.086
It's technically free space for
you because it's theirs but,

1100
00:49:01.086 --> 00:49:03.326
you know, don't fill it
up with unnecessary stuff.

1101
00:49:03.906 --> 00:49:08.226
So again, with the
limits, how much do you get

1102
00:49:08.226 --> 00:49:09.096
for your app container?

1103
00:49:09.096 --> 00:49:10.766
Well, what we're concerned

1104
00:49:10.766 --> 00:49:13.666
with here is customers
having a great experience,

1105
00:49:14.166 --> 00:49:17.536
and these limits that we've
specified here are really

1106
00:49:17.576 --> 00:49:19.056
to try and prevent abuse.

1107
00:49:19.056 --> 00:49:20.936
We don't want to
prevent legitimate use.

1108
00:49:20.936 --> 00:49:23.446
We just don't want
anyone abusing CloudKit.

1109
00:49:24.496 --> 00:49:26.736
And the numbers that we
give you here also scale

1110
00:49:26.736 --> 00:49:28.356
with the number of
users you have.

1111
00:49:28.356 --> 00:49:29.946
If you go on
developer.apple.com,

1112
00:49:29.946 --> 00:49:32.666
you can get the full breakdown
of the different values,

1113
00:49:32.666 --> 00:49:36.916
but as an example, if you had
10 million users of your app,

1114
00:49:36.916 --> 00:49:39.486
we're going to give you a
petabyte of asset storage,

1115
00:49:39.486 --> 00:49:41.186
10 terabytes of database
storage,

1116
00:49:41.186 --> 00:49:44.676
some pretty high transfer
limits, and this is all

1117
00:49:44.766 --> 00:49:46.986
for your public database
in your application.

1118
00:49:49.556 --> 00:49:51.666
So, finally, a note
on efficiency.

1119
00:49:52.336 --> 00:49:54.916
One thing about CloudKit
is, again,

1120
00:49:54.916 --> 00:49:56.876
it's a transport mechanism.

1121
00:49:56.876 --> 00:49:59.976
We are only there to talk to
the iCloud servers for you.

1122
00:50:00.676 --> 00:50:02.636
We're not storing any records.

1123
00:50:02.636 --> 00:50:03.796
We're not caching records.

1124
00:50:04.316 --> 00:50:06.456
Anytime we give you back
a record, it's something

1125
00:50:06.456 --> 00:50:07.536
that we got from the server.

1126
00:50:08.156 --> 00:50:10.206
We're trying to be as
transparent about that

1127
00:50:10.206 --> 00:50:13.876
as possible and not do any
caching shenanigans here.

1128
00:50:13.876 --> 00:50:16.326
We're always just giving
you what the server gave us.

1129
00:50:17.666 --> 00:50:21.116
In terms of efficiency
though, you might remember

1130
00:50:21.166 --> 00:50:23.226
from the save policies
that we're only going

1131
00:50:23.226 --> 00:50:25.366
to save the values that
have changed on the records.

1132
00:50:25.366 --> 00:50:27.856
So, we try and be smart about
what we send over the wire.

1133
00:50:29.106 --> 00:50:30.846
When we're sending up assets,

1134
00:50:30.956 --> 00:50:33.586
those can be potentially
really big blobs of data,

1135
00:50:34.246 --> 00:50:36.496
and that data is
transferred efficiently.

1136
00:50:36.496 --> 00:50:38.896
So, if the server already
has a copy of a file,

1137
00:50:39.306 --> 00:50:40.306
we won't re-upload it.

1138
00:50:40.486 --> 00:50:42.236
If we already have
that file locally,

1139
00:50:42.236 --> 00:50:46.506
we don't need to re-download it.

1140
00:50:46.696 --> 00:50:50.076
So, in summary, we're really
excited about CloudKit here.

1141
00:50:50.076 --> 00:50:52.446
We've built a lot of
really great features

1142
00:50:52.926 --> 00:50:55.306
and it's something that
we actually use at Apple.

1143
00:50:55.306 --> 00:50:58.466
We've built iCloud Drive, we've
built iCloud Photos on top

1144
00:50:58.466 --> 00:51:02.326
of this, and we want you guys to
start using the same technology

1145
00:50:58.466 --> 00:51:02.326
of this, and we want you guys to
start using the same technology

1146
00:51:02.326 --> 00:51:03.646
that we're using at Apple.

1147
00:51:04.536 --> 00:51:06.906
I'm really excited to see
what's going to happen.

1148
00:51:06.906 --> 00:51:09.036
I can't wait to see some
apps that use CloudKit,

1149
00:51:09.566 --> 00:51:12.376
and good luck with
using CloudKit.

1150
00:51:14.516 --> 00:51:21.176
[ Applause ]

1151
00:51:21.676 --> 00:51:24.816
So, if you need any, if
you need to contact anyone,

1152
00:51:24.816 --> 00:51:26.316
Dave DeLong is our Evangelist.

1153
00:51:26.316 --> 00:51:28.376
He's the guy with the bowtie.

1154
00:51:28.426 --> 00:51:31.976
If you need documentation,
it's on developer.apple.com.

1155
00:51:31.976 --> 00:51:35.086
We had a Introducing CloudKit
session earlier in the week.

1156
00:51:35.246 --> 00:51:37.836
There's a couple more
related sessions.

1157
00:51:38.876 --> 00:51:39.216
Thank you.

1158
00:51:40.016 --> 00:51:41.000
[ Applause ]
