
1
00:00:12.356 --> 00:00:13.336
>> Good morning!

2
00:00:13.616 --> 00:00:13.796
Welcome!

3
00:00:14.516 --> 00:00:17.136
[ Applause ]

4
00:00:17.636 --> 00:00:20.886
Glad to see a number of folks
out now, bright and early,

5
00:00:20.886 --> 00:00:23.906
to talk about all the
heart-pounding excitement

6
00:00:23.906 --> 00:00:25.276
in the world of compilers.

7
00:00:26.026 --> 00:00:31.396
And I'm Jim Grosbach, and I'm
really happy to be here today

8
00:00:31.396 --> 00:00:35.746
to share with you all of the
new things that we have in LLVM.

9
00:00:37.106 --> 00:00:42.226
When we normally talk about LLVM
and what first comes to mind

10
00:00:42.226 --> 00:00:46.296
when we think about it is the
Apple LLVM Compiler itself.

11
00:00:46.646 --> 00:00:51.146
This is what we all use to
build our apps and that's

12
00:00:51.146 --> 00:00:53.276
where we really first
encounter LLVM,

13
00:00:53.966 --> 00:00:57.136
but it's much more than that.

14
00:00:57.886 --> 00:01:03.266
LLVM is used in a wide
variety of products and tools

15
00:00:57.886 --> 00:01:03.266
LLVM is used in a wide
variety of products and tools

16
00:01:03.766 --> 00:01:09.436
that we all use every day, both
as developers and as end users.

17
00:01:10.866 --> 00:01:16.326
Over the years LLVM has grown to
be a really key technology here

18
00:01:16.326 --> 00:01:19.566
at Apple for building
tools, for performance,

19
00:01:20.146 --> 00:01:25.996
and for modernization, and that
has been no exception this year

20
00:01:26.496 --> 00:01:28.276
as we have moved swiftly along

21
00:01:29.226 --> 00:01:32.106
with a wide variety
of new improvements.

22
00:01:33.666 --> 00:01:38.806
To start with, back in September
we introduced the Apple A7

23
00:01:38.806 --> 00:01:43.086
processor which has been
just absolutely magnificent

24
00:01:43.206 --> 00:01:44.516
in what it's allowed us to do,

25
00:01:44.826 --> 00:01:47.366
bringing truly desktop-class
performance

26
00:01:48.076 --> 00:01:53.166
to your mobile devices and
LLVM plays a key role in this.

27
00:01:54.226 --> 00:01:59.546
And now we're encouraging more
of you to use this technology

28
00:01:59.546 --> 00:02:03.396
in your apps, so
building for 64-bit

29
00:01:59.546 --> 00:02:03.396
in your apps, so
building for 64-bit

30
00:02:03.676 --> 00:02:05.546
in iOS is now the default.

31
00:02:05.626 --> 00:02:09.515
As of Xcode 5.1 carrying
on into Xcode 6,

32
00:02:10.235 --> 00:02:11.546
when you rebuild your app,

33
00:02:12.486 --> 00:02:14.146
if you're using standard
architectures,

34
00:02:14.616 --> 00:02:16.676
ARM64 will be included.

35
00:02:17.406 --> 00:02:19.926
This does not impact
your deployment story.

36
00:02:19.926 --> 00:02:23.466
You can continue to
deploy back to iOS 4.3.

37
00:02:23.466 --> 00:02:26.786
We still build for
arm V7 for 32 bit.

38
00:02:27.626 --> 00:02:30.546
All of the development work
flows that you're familiar

39
00:02:30.546 --> 00:02:34.346
with for the simulator,
the debugger, profiling,

40
00:02:34.916 --> 00:02:38.066
all of these things continue
to work transparently,

41
00:02:38.526 --> 00:02:41.636
just as you're familiar with
in a 64-bit environment.

42
00:02:42.506 --> 00:02:44.926
Now, one thing to be aware of is

43
00:02:44.926 --> 00:02:49.166
that because ARM64 is an
entirely new architecture,

44
00:02:49.856 --> 00:02:52.786
your entire application
must be built 64 bit,

45
00:02:53.256 --> 00:02:54.826
not just a few libraries here,

46
00:02:54.826 --> 00:02:57.526
or a few files there,
but the whole app.

47
00:02:57.746 --> 00:03:00.586
So, if you're relying on
third-party libraries,

48
00:02:57.746 --> 00:03:00.586
So, if you're relying on
third-party libraries,

49
00:03:01.286 --> 00:03:05.416
and those libraries have
not yet adopted 64 bit,

50
00:03:06.036 --> 00:03:10.506
please work with your vendors
and encourage them to update

51
00:03:10.746 --> 00:03:12.796
and support 64 bit development

52
00:03:13.146 --> 00:03:16.276
so that your app
can then migrate

53
00:03:16.276 --> 00:03:18.116
as well and get the benefits.

54
00:03:18.666 --> 00:03:22.526
Now, during migration there
are a few things that we'd

55
00:03:22.526 --> 00:03:26.426
like to bring to your
attention that might come up,

56
00:03:26.426 --> 00:03:29.586
a few advancements we've
made, and a few things

57
00:03:29.586 --> 00:03:31.676
that we've tightened
up in the specification

58
00:03:31.806 --> 00:03:35.406
and what the possible impact
of that to your app is.

59
00:03:35.956 --> 00:03:42.556
To start with, in 64-bit iOS all
functions must have a prototype.

60
00:03:43.096 --> 00:03:47.116
This has been good style
since time immemorial

61
00:03:47.596 --> 00:03:51.496
and it's been required
for C++ since the start.

62
00:03:51.886 --> 00:03:55.156
It's been highly suggested in C,

63
00:03:55.276 --> 00:03:58.636
for any modern version not
using a prototype is deprecated

64
00:03:59.306 --> 00:04:01.976
and has been for a
very long time now.

65
00:03:59.306 --> 00:04:01.976
and has been for a
very long time now.

66
00:04:03.206 --> 00:04:06.546
So, we've taken advantage
of this in ARM64

67
00:04:06.986 --> 00:04:10.156
to generate more efficient
calling convention code,

68
00:04:10.396 --> 00:04:12.866
in particular for variatic
functions like printf,

69
00:04:12.866 --> 00:04:14.866
that the number of arguments

70
00:04:15.166 --> 00:04:17.476
to the function varies
by call site.

71
00:04:18.995 --> 00:04:21.805
So, when you have older
code that you're using

72
00:04:21.805 --> 00:04:23.356
that may not use prototypes,

73
00:04:24.176 --> 00:04:27.496
what is normally a warning has
now been promoted to an error,

74
00:04:27.496 --> 00:04:31.646
so the compiler will highlight
to you in your code exactly

75
00:04:31.736 --> 00:04:35.766
where this is happening so
that you know which prototypes

76
00:04:35.766 --> 00:04:38.156
to go add to your
header files to move on.

77
00:04:39.796 --> 00:04:42.786
One place that this
does sometimes come

78
00:04:42.786 --> 00:04:46.556
up in a little bit more
of a subtle way is when C

79
00:04:46.556 --> 00:04:50.116
and Objective-C interworking
code with direct indications

80
00:04:50.116 --> 00:04:51.816
of Objective-C message send.

81
00:04:52.466 --> 00:04:54.946
To help find this, we
have a new Xcode setting

82
00:04:55.536 --> 00:04:58.896
to enable strict
checking of objc-msgSend.

83
00:05:00.366 --> 00:05:01.706
This is a recommended setting

84
00:05:02.796 --> 00:05:05.236
and when you first
upgrade your project

85
00:05:05.236 --> 00:05:07.396
to [inaudible] code
6 we'll encourage you

86
00:05:07.506 --> 00:05:08.546
to adopt this setting.

87
00:05:08.546 --> 00:05:12.926
And what's tricky is
that every indication

88
00:05:12.926 --> 00:05:16.636
of objc-msgSend effectively
has a different type.

89
00:05:17.466 --> 00:05:22.196
It has the type of what the
final receiving method is going

90
00:05:22.196 --> 00:05:22.646
to be.

91
00:05:23.696 --> 00:05:26.566
For example here,
a trivial piece

92
00:05:26.566 --> 00:05:29.906
of code that's invoking
method foo,

93
00:05:31.046 --> 00:05:36.446
with strict checking enabled,
the compiler will now tell us

94
00:05:36.576 --> 00:05:40.236
that we need to tell it
what the final type is.

95
00:05:41.136 --> 00:05:42.466
This is straightforward to do.

96
00:05:42.466 --> 00:05:44.956
It's a little bit verbose,
but very straightforward.

97
00:05:44.956 --> 00:05:47.736
We simply add the type of
the final receiving method.

98
00:05:48.146 --> 00:05:49.406
Done it here with a typedef.

99
00:05:49.446 --> 00:05:52.856
This could be done with a direct
type test on all on one line,

100
00:05:52.856 --> 00:05:54.866
if you prefer, just to make sure

101
00:05:54.866 --> 00:05:57.646
that the compiler knows what
the final receiving type

102
00:05:57.646 --> 00:06:01.046
of the method is so that it
can generate the right code

103
00:05:57.646 --> 00:06:01.046
of the method is so that it
can generate the right code

104
00:06:01.296 --> 00:06:02.926
to get the final result correct.

105
00:06:05.016 --> 00:06:08.296
Another place that we've
tightened things up

106
00:06:08.296 --> 00:06:09.916
and taken advantage
of our new ABI

107
00:06:09.916 --> 00:06:13.856
and ARM64 is the
Objective-C Boolean type.

108
00:06:14.276 --> 00:06:17.776
If any of you were at Stump
the Experts last night,

109
00:06:17.776 --> 00:06:19.916
this topic actually
came up as a question.

110
00:06:20.396 --> 00:06:23.306
It was rather amusing like,
"I have a slide on that!

111
00:06:23.456 --> 00:06:25.116
That'll be great!"

112
00:06:25.116 --> 00:06:27.596
So, BOOL is basically
now a BOOL type.

113
00:06:28.716 --> 00:06:31.666
Previously, it's been
a signed character.

114
00:06:32.156 --> 00:06:36.726
And, sometimes our code -- our
code as well, not just in yours,

115
00:06:37.326 --> 00:06:39.756
would put values
into the Boolean type

116
00:06:39.786 --> 00:06:41.876
that weren't strictly Boolean.

117
00:06:42.946 --> 00:06:46.606
Now, the compiler is going to
be taking advantage of this type

118
00:06:46.606 --> 00:06:48.796
or definition, so
what can happen is

119
00:06:48.796 --> 00:06:52.346
that if your code does that,
the results between 32-bit iOS

120
00:06:52.696 --> 00:06:55.106
and 64-bit iOS may differ.

121
00:06:56.046 --> 00:06:59.066
So, if you start seeing some
odd behaviors with Booleans,

122
00:06:59.366 --> 00:07:03.326
this is something
to look out for.

123
00:06:59.366 --> 00:07:03.326
this is something
to look out for.

124
00:07:04.946 --> 00:07:06.296
We also have pointers.

125
00:07:07.516 --> 00:07:10.196
As we're now 64-bit
architecture, this is kind

126
00:07:10.196 --> 00:07:12.666
of the core of what this
is all about, that pointers

127
00:07:12.666 --> 00:07:14.266
and longs are now 64 bits.

128
00:07:15.226 --> 00:07:19.146
So, old code would
often do horrible things

129
00:07:19.146 --> 00:07:21.916
like casting integers to
pointers, and back-and-forth.

130
00:07:22.866 --> 00:07:25.286
And hopefully, we don't write
code that does that anymore,

131
00:07:25.286 --> 00:07:28.026
but we all have this legacy
code that we have to live with,

132
00:07:29.076 --> 00:07:32.176
and now this can bite
us if we're not careful.

133
00:07:32.486 --> 00:07:34.736
This is very similar
to what we've all dealt

134
00:07:34.736 --> 00:07:38.876
with on the 32-bit to
64-bit Intel transition,

135
00:07:38.876 --> 00:07:39.816
if we went through that.

136
00:07:40.616 --> 00:07:41.496
That's still a problem;

137
00:07:41.496 --> 00:07:43.826
we haven't magically just
solved that in the compiler.

138
00:07:44.886 --> 00:07:48.946
So for example here, we're
casting an integer which came

139
00:07:48.946 --> 00:07:50.106
from a pointer somewhere else.

140
00:07:50.106 --> 00:07:52.156
We're casting that
to a void (star).

141
00:07:52.156 --> 00:07:55.186
But now the compiler
can help a little bit.

142
00:07:55.186 --> 00:08:00.196
It can at least inform us
that the problem is coming up

143
00:07:55.186 --> 00:08:00.196
It can at least inform us
that the problem is coming up

144
00:08:00.196 --> 00:08:03.636
and tell us that, "Oh, we have a
problem here that we need to go

145
00:08:03.636 --> 00:08:04.606
and look at and make sure

146
00:08:04.606 --> 00:08:06.796
that this is really
what's happening."

147
00:08:07.596 --> 00:08:09.176
Now, if we ignore this warning,

148
00:08:09.796 --> 00:08:12.656
the runtime in the
kernel is going

149
00:08:12.656 --> 00:08:15.036
to be a little bit more
forceful about this.

150
00:08:15.606 --> 00:08:19.116
If we dereference that pointer,
we're going to get a hard fault

151
00:08:19.916 --> 00:08:22.936
because the page zero is
mapped to always give a fault,

152
00:08:22.936 --> 00:08:26.236
so if we miss any of these
through other warnings,

153
00:08:26.806 --> 00:08:27.916
we'll still get an error.

154
00:08:28.406 --> 00:08:29.696
Paying attention
to the compiler,

155
00:08:29.696 --> 00:08:32.106
it's going to be a lot
friendlier because it'll be nice

156
00:08:32.106 --> 00:08:34.515
and friendly and tell you the
line number and the source file

157
00:08:34.576 --> 00:08:35.496
for where the problem is.

158
00:08:35.716 --> 00:08:37.756
The kernel's just going to
tell you you did something bad.

159
00:08:39.246 --> 00:08:43.666
To address this, we use
the C language typedefs

160
00:08:44.456 --> 00:08:46.776
that are 64 and 32-bit cleaned.

161
00:08:46.776 --> 00:08:49.596
We say we want a signed
integer, an unsigned integer,

162
00:08:49.816 --> 00:08:53.086
that is an appropriate type
for saving a pointer value

163
00:08:53.386 --> 00:08:55.306
or for indexing into an array

164
00:08:55.746 --> 00:08:58.466
for comparing the differences
between two pointers.

165
00:08:59.446 --> 00:09:02.026
For example, if we would
modify our previous code

166
00:08:59.446 --> 00:09:02.026
For example, if we would
modify our previous code

167
00:09:02.026 --> 00:09:05.566
to simply use the intptr type,
which when we're compiling

168
00:09:05.566 --> 00:09:08.726
for 32-bit iOS, will we
get 32-bit signed integer,

169
00:09:09.126 --> 00:09:13.726
and for 64-bit iOS will be
a 64-bit signed integer.

170
00:09:14.456 --> 00:09:18.686
Slightly more subtly, this can
come up in structure layouts.

171
00:09:19.496 --> 00:09:23.266
When we use a long or pointer
these now grow, which change

172
00:09:23.636 --> 00:09:26.236
but the size and
sometimes the alignment,

173
00:09:26.236 --> 00:09:28.836
the offsets of other
fields in our structures.

174
00:09:29.486 --> 00:09:30.576
And, we have to be careful

175
00:09:30.576 --> 00:09:32.646
that this is done in
a way that's safe.

176
00:09:33.876 --> 00:09:36.586
Now, most of time this is
going to work transparently,

177
00:09:36.586 --> 00:09:38.856
because these structures
are used entirely

178
00:09:38.856 --> 00:09:40.236
within our application

179
00:09:40.236 --> 00:09:42.926
and everything gets the new
definition and works fine.

180
00:09:44.146 --> 00:09:46.806
But, if we're doing something
like a representation

181
00:09:46.806 --> 00:09:50.556
of an on-disk file format
communicating across a network

182
00:09:50.556 --> 00:09:54.436
to another process that is going
to rely on the exact layout

183
00:09:54.436 --> 00:09:58.056
of a structure, that
can go badly.

184
00:09:58.056 --> 00:10:01.086
So again, on any of those
data structures we want

185
00:09:58.056 --> 00:10:01.086
So again, on any of those
data structures we want

186
00:10:01.086 --> 00:10:07.496
to use the C fixed type,
fixed size types to make sure

187
00:10:07.496 --> 00:10:09.316
that we get what we want,
whether we're building

188
00:10:09.316 --> 00:10:12.876
for 64-bit iOS or
for 32-bit iOS.

189
00:10:14.756 --> 00:10:18.166
So in summary, building
for 64-bit iOS is easy,

190
00:10:18.636 --> 00:10:23.596
it's a default, and the
compiler will help find

191
00:10:23.596 --> 00:10:25.136
and resolve any issues.

192
00:10:26.116 --> 00:10:29.736
But, this isn't the only
thing that we've been up to.

193
00:10:29.816 --> 00:10:33.056
We've also been making
advances in Objective-C

194
00:10:34.086 --> 00:10:36.596
and the compiler
can help here, too.

195
00:10:37.996 --> 00:10:39.906
The language has
continued to move forward.

196
00:10:40.386 --> 00:10:43.166
Some of this really helps with
the interoperability with SWF

197
00:10:43.286 --> 00:10:46.006
as well, as you may be
seeing in that talk.

198
00:10:46.006 --> 00:10:47.656
I highly encourage
you to check it out.

199
00:10:47.656 --> 00:10:50.116
It's happening at the same time
as this one, so go and look

200
00:10:50.116 --> 00:10:53.516
on the video when that
comes on the WWDC app.

201
00:10:53.566 --> 00:10:59.776
And, whenever we write new
code, we've been using all

202
00:10:59.776 --> 00:11:02.046
of these advancements
in the language

203
00:10:59.776 --> 00:11:02.046
of these advancements
in the language

204
00:11:02.626 --> 00:11:05.436
to get the modern best
practices, more expressive code,

205
00:11:05.436 --> 00:11:10.386
but then we have all of this
older legacy code that we'd

206
00:11:10.386 --> 00:11:12.776
like to adopt all of these
features in, as well.

207
00:11:13.026 --> 00:11:15.436
But, that's a lot of
code to go read through

208
00:11:15.436 --> 00:11:19.216
and manually find all of these
things, so we have a tool

209
00:11:19.216 --> 00:11:22.196
that will help us
identify the opportunities

210
00:11:22.746 --> 00:11:24.686
where we can use
these new features.

211
00:11:24.926 --> 00:11:28.496
And, I think the best
way to talk about that is

212
00:11:28.496 --> 00:11:32.066
to show you with the demo.

213
00:11:32.686 --> 00:11:37.576
Now, rather than use some
contrived example code here,

214
00:11:37.576 --> 00:11:39.376
I thought we'd maybe
look at something

215
00:11:39.376 --> 00:11:40.966
that we all are familiar with,

216
00:11:40.966 --> 00:11:44.326
at least as users,
and our WWDC app.

217
00:11:45.236 --> 00:11:47.246
That code has been
with us for a while.

218
00:11:47.246 --> 00:11:48.696
We update it every year.

219
00:11:49.126 --> 00:11:53.326
And, with the modernizer we
wanted to use that to look at it

220
00:11:53.326 --> 00:11:55.986
and find out if there
are perhaps some places

221
00:11:55.986 --> 00:11:58.486
in the codebase that we
missed for opportunities

222
00:11:59.496 --> 00:12:01.516
to use new Objective-C features.

223
00:11:59.496 --> 00:12:01.516
to use new Objective-C features.

224
00:12:02.396 --> 00:12:04.786
So, let's look and
see what a few

225
00:12:04.786 --> 00:12:06.396
of those things that
we found are.

226
00:12:06.876 --> 00:12:11.246
If we go under Edit to refactor,
we can convert our project

227
00:12:11.356 --> 00:12:13.246
to modern Objective-C syntax.

228
00:12:14.136 --> 00:12:16.796
We get a dialog box telling
us what we've just selected,

229
00:12:16.896 --> 00:12:18.676
so make sure that we've
got the right thing.

230
00:12:20.476 --> 00:12:21.486
We can select whether --

231
00:12:21.566 --> 00:12:23.886
which targets in our
project to modernize.

232
00:12:23.886 --> 00:12:26.876
In this case, we're looking
at the WWDC app, itself.

233
00:12:27.476 --> 00:12:32.406
In the previous versions of
Xcode, the modernizer would go

234
00:12:32.466 --> 00:12:33.716
through and just look

235
00:12:33.806 --> 00:12:36.246
for Objective-C literals
and subscripting.

236
00:12:36.246 --> 00:12:38.596
But now, we have more options.

237
00:12:39.606 --> 00:12:42.476
Now personally, I prefer not
to do all of these at once.

238
00:12:42.476 --> 00:12:45.566
That tends to be a little too
much to swap back-and-forth,

239
00:12:45.596 --> 00:12:48.156
so I tend to want to
select a few things.

240
00:12:48.446 --> 00:12:51.616
I'm going to look for
instance type here

241
00:12:51.616 --> 00:12:53.866
that we can get our
initialization methods more

242
00:12:53.866 --> 00:12:54.616
strongly typed.

243
00:12:54.616 --> 00:12:58.596
I'm going to try and find if we
missed any read/write properties

244
00:12:58.596 --> 00:13:01.726
where we convert explicit
getter/setter methods.

245
00:12:58.596 --> 00:13:01.726
where we convert explicit
getter/setter methods.

246
00:13:02.316 --> 00:13:05.116
And, we're going to
look to use NS ENUM

247
00:13:05.496 --> 00:13:08.766
for our enumeration values
so the compiler can cooperate

248
00:13:08.766 --> 00:13:11.156
with the runtime to
give better results.

249
00:13:12.246 --> 00:13:16.736
Click Next, and the compiler
will run over our code

250
00:13:16.986 --> 00:13:20.216
and it turns out we do, indeed,
have a few more suggestions

251
00:13:20.216 --> 00:13:21.506
for what we can look at.

252
00:13:22.176 --> 00:13:25.016
Now, do keep in mind that
these are just suggestions,

253
00:13:25.866 --> 00:13:27.406
that we need to go
through and look

254
00:13:27.406 --> 00:13:30.656
at the side-by-side diff here,
where we have the new code

255
00:13:30.656 --> 00:13:35.026
on the left, the old code on the
right, and we look through here.

256
00:13:35.026 --> 00:13:36.226
This looks fine.

257
00:13:36.926 --> 00:13:38.196
Everything looks good here.

258
00:13:38.196 --> 00:13:39.556
We're converting to ENUMS.

259
00:13:40.066 --> 00:13:42.096
Let's look at our next one.

260
00:13:42.936 --> 00:13:46.036
This looks a little
bit different,

261
00:13:46.036 --> 00:13:50.686
because we still have this NS
integer over here that looks

262
00:13:50.686 --> 00:13:52.196
like it'd be straightforward
to clean up,

263
00:13:52.196 --> 00:13:54.116
but I'd rather come
back to this later.

264
00:13:54.116 --> 00:13:55.076
I just want to deal
with the things

265
00:13:55.076 --> 00:13:56.756
that we can do automatically
right now.

266
00:13:57.416 --> 00:14:00.546
So, I tell the modernizer
to discard that change.

267
00:13:57.416 --> 00:14:00.546
So, I tell the modernizer
to discard that change.

268
00:14:00.996 --> 00:14:03.396
It wants to make sure
that I'm doing that.

269
00:14:03.396 --> 00:14:04.966
Yes, I am absolutely sure.

270
00:14:04.966 --> 00:14:07.396
I can do the same here.

271
00:14:08.876 --> 00:14:11.646
We could also tell it to ignore
all of the changes in this file

272
00:14:11.646 --> 00:14:12.846
with this Check button here.

273
00:14:13.406 --> 00:14:16.366
And now, it's also found a place

274
00:14:17.026 --> 00:14:18.396
where we can use
an instance type.

275
00:14:18.696 --> 00:14:23.296
And, that all looks good
so we tell it to save.

276
00:14:24.236 --> 00:14:26.086
And, Xcode will now
tell us that, "Oh!

277
00:14:26.086 --> 00:14:29.926
We can update our project as
well, and take snapshots."

278
00:14:30.376 --> 00:14:31.416
That sounds great.

279
00:14:31.416 --> 00:14:33.216
Let's let it do that
because backups are good.

280
00:14:33.216 --> 00:14:36.476
And now, our project is
saved, it's been rebuilt,

281
00:14:37.286 --> 00:14:42.416
and the Objective-C modernizer
works to update our code

282
00:14:42.416 --> 00:14:45.026
and help us find places
where we can take advantage

283
00:14:45.326 --> 00:14:46.216
of new features.

284
00:14:46.846 --> 00:14:51.046
But, this isn't the only
place that we've made advances

285
00:14:51.616 --> 00:14:55.086
for Objective-C and
for interoperability.

286
00:14:55.136 --> 00:14:58.886
And, to tell you more about that
I'd like to invite my friend

287
00:14:58.886 --> 00:15:00.036
and coworker, Bob Wilson.

288
00:14:58.886 --> 00:15:00.036
and coworker, Bob Wilson.

289
00:15:00.246 --> 00:15:01.066
Thank you, Bob.

290
00:15:02.516 --> 00:15:07.576
[ Applause ]

291
00:15:08.076 --> 00:15:08.516
>> Thank you, Jim.

292
00:15:10.186 --> 00:15:12.006
So, modules are another way

293
00:15:12.096 --> 00:15:14.476
that LLVM can help
modernize your code.

294
00:15:14.726 --> 00:15:18.066
We introduced modules just last
year, but in cases you missed

295
00:15:18.066 --> 00:15:19.786
that let's start
with some background.

296
00:15:22.056 --> 00:15:24.896
So, before modules we
had precompiled headers,

297
00:15:25.136 --> 00:15:28.556
which are often an effective
way to speed up the compilation

298
00:15:28.556 --> 00:15:31.286
of your code, but they
do have some limitations.

299
00:15:32.196 --> 00:15:35.606
You can only have one
precompiled header at a time,

300
00:15:36.516 --> 00:15:39.536
and more importantly,
the whole approach

301
00:15:39.536 --> 00:15:43.156
of using a textual inclusion
of a header file as a way

302
00:15:43.156 --> 00:15:45.846
of importing a framework
is just fragile.

303
00:15:46.916 --> 00:15:48.396
We have a deal with the issue

304
00:15:48.396 --> 00:15:51.266
where a header file gets
included more than once

305
00:15:51.266 --> 00:15:52.406
in a single compilation.

306
00:15:53.606 --> 00:15:55.986
We have also a problem
of headers being fragile.

307
00:15:56.526 --> 00:15:59.346
And, what I mean by
that is that the meaning

308
00:15:59.346 --> 00:16:01.956
of the header can change
depending on the environment

309
00:15:59.346 --> 00:16:01.956
of the header can change
depending on the environment

310
00:16:02.236 --> 00:16:05.246
where it's imported, and let me
show you that with an example.

311
00:16:06.706 --> 00:16:09.936
So here, I've defined a macro
count to the value of 100,

312
00:16:10.266 --> 00:16:12.266
and then I import the
foundation framework.

313
00:16:13.256 --> 00:16:17.056
Now, inside the foundation
header there's an include

314
00:16:17.096 --> 00:16:18.586
for the NSArray definition.

315
00:16:19.346 --> 00:16:21.786
An NSArray has an
ivar, the count.

316
00:16:22.726 --> 00:16:26.896
So, the macro of count gets
substituted as literal text

317
00:16:27.356 --> 00:16:30.296
in that place and we end up
with completely broken code

318
00:16:30.296 --> 00:16:32.936
where instead of the ivar
name, we have a value of 100.

319
00:16:33.856 --> 00:16:35.876
This is what I mean by
headers being fragile.

320
00:16:37.296 --> 00:16:40.696
Modules solve this problem
by replacing the model

321
00:16:40.696 --> 00:16:43.996
of textual inclusion
with a semantic import.

322
00:16:44.326 --> 00:16:48.426
And, there's a lot more detail
about modules in the Advances

323
00:16:48.426 --> 00:16:50.956
in Objective-C presentation
from last year's WWDC

324
00:16:50.956 --> 00:16:52.556
and I encourage you to watch

325
00:16:52.556 --> 00:16:54.146
that if you're not
familiar with modules.

326
00:16:55.816 --> 00:16:58.466
Until now, modules have
only been available

327
00:16:58.516 --> 00:16:59.776
for the system frameworks.

328
00:17:01.106 --> 00:17:04.286
New in Xcode 6, you
can now define modules

329
00:17:04.476 --> 00:17:07.906
for your own frameworks as
well for C and Objective-C.

330
00:17:09.156 --> 00:17:11.866
Besides fixing the
problems we just looked at,

331
00:17:11.986 --> 00:17:13.356
this also gives you a way

332
00:17:13.356 --> 00:17:16.886
of importing your own
framework into your SWF code.

333
00:17:17.586 --> 00:17:19.286
And as Jim mentioned,
there's another session

334
00:17:19.286 --> 00:17:22.336
on integrating SWF with
Objective-C that I encourage you

335
00:17:22.336 --> 00:17:24.425
to watch the video to
learn more about that.

336
00:17:25.675 --> 00:17:27.556
So if you want to do this, how?

337
00:17:28.806 --> 00:17:29.986
It's really very easy.

338
00:17:30.946 --> 00:17:32.926
For most frameworks
it's possible

339
00:17:32.926 --> 00:17:35.656
to define a single
umbrella header

340
00:17:35.916 --> 00:17:38.126
that imports all of
the framework API.

341
00:17:38.606 --> 00:17:40.866
And, this is what we
recommend that you do

342
00:17:41.276 --> 00:17:43.976
as it is the easiest
way to adopt a module.

343
00:17:45.046 --> 00:17:48.046
Once you've done that, simply
go to the Xcode BUILD settings

344
00:17:48.256 --> 00:17:52.756
for your framework and in the
packaging section set Defines

345
00:17:52.756 --> 00:17:55.616
Module to Yes, and that's it.

346
00:17:55.616 --> 00:17:57.176
It really is very easy.

347
00:17:57.796 --> 00:17:59.896
Now, if you have a more
complicated framework

348
00:18:00.116 --> 00:18:03.516
where that single umbrella
header is not sufficient,

349
00:18:03.516 --> 00:18:05.146
you can use a custom module map.

350
00:18:05.946 --> 00:18:08.236
And, there's more
information to describe how

351
00:18:08.236 --> 00:18:09.846
that works on the LLVM website.

352
00:18:12.036 --> 00:18:14.506
After you've created a
module you'll want to use it.

353
00:18:15.396 --> 00:18:16.036
How do you do that?

354
00:18:17.226 --> 00:18:21.516
There's an @import keyword
followed by the module name

355
00:18:21.856 --> 00:18:24.076
that tells the compiler, "I
want to import this module."

356
00:18:24.726 --> 00:18:27.636
If you haven't had a
chance to update your code

357
00:18:27.636 --> 00:18:28.716
and you're still --

358
00:18:28.716 --> 00:18:31.726
have a #import to include
the umbrella header,

359
00:18:31.726 --> 00:18:33.986
the compiler's smart
enough to know

360
00:18:34.206 --> 00:18:37.416
that this is now a modular
framework and it will go ahead

361
00:18:37.416 --> 00:18:40.426
and treat that as an implicit
modular import anyway.

362
00:18:41.966 --> 00:18:45.516
So just as a guideline though,
we do recommend you use @import

363
00:18:46.396 --> 00:18:49.536
when you're importing your
framework into a separate target

364
00:18:49.536 --> 00:18:53.036
within your project just because
it makes it clear in the source

365
00:18:53.116 --> 00:18:56.326
that you really intend for
this to be a modular import.

366
00:18:57.646 --> 00:19:00.466
One exception to that is
within the implementation

367
00:18:57.646 --> 00:19:00.466
One exception to that is
within the implementation

368
00:19:00.466 --> 00:19:01.776
of your framework, itself.

369
00:19:02.476 --> 00:19:05.746
It doesn't make any sense to
import a framework into itself

370
00:19:05.746 --> 00:19:09.006
and so, in that case, you
really need to use #import

371
00:19:09.006 --> 00:19:11.096
to textually include
the framework headers,

372
00:19:11.276 --> 00:19:13.286
just within the implementation
of the framework.

373
00:19:14.846 --> 00:19:17.616
And, besides those guidelines,
we have a few other rules

374
00:19:17.616 --> 00:19:19.876
about modules that you
should be aware of.

375
00:19:20.286 --> 00:19:23.916
First, don't expose
any non-modular headers

376
00:19:23.916 --> 00:19:24.966
in your framework API.

377
00:19:26.186 --> 00:19:28.786
It's fine to import
another module, like Cocoa,

378
00:19:29.296 --> 00:19:32.266
but if I have an import of
something like Postgres.h,

379
00:19:32.266 --> 00:19:34.226
which presumably
is not a module,

380
00:19:34.986 --> 00:19:37.156
you can put that down
inside the implementation

381
00:19:37.156 --> 00:19:40.366
of your framework, but
don't expose it in the API.

382
00:19:42.596 --> 00:19:46.436
One other issue is that
modules can change the semantics

383
00:19:46.526 --> 00:19:47.146
of your code.

384
00:19:47.636 --> 00:19:50.386
We saw earlier the
problem of a fragile header

385
00:19:50.496 --> 00:19:53.676
where a macro definition
inadvertently broke the code.

386
00:19:54.206 --> 00:19:56.256
Sometimes you might want
to do this on purpose,

387
00:19:56.286 --> 00:19:59.236
and I'm showing here an example
where I've defined a macro,

388
00:19:59.336 --> 00:20:03.226
DEBUG, as a flag to enable
additional debugging APIs

389
00:19:59.336 --> 00:20:03.226
DEBUG, as a flag to enable
additional debugging APIs

390
00:20:03.896 --> 00:20:04.726
in my framework.

391
00:20:06.386 --> 00:20:08.806
By switching that
framework to be a module,

392
00:20:08.806 --> 00:20:10.846
the DEBUG macro defined

393
00:20:10.846 --> 00:20:13.066
in my source code no
longer has any effect,

394
00:20:13.196 --> 00:20:14.426
which is not what I wanted.

395
00:20:15.296 --> 00:20:17.726
Now, that limitation
only applies to macros

396
00:20:17.726 --> 00:20:19.716
that are defined
in the source code.

397
00:20:19.966 --> 00:20:22.066
So, if you really want to
do something like this,

398
00:20:22.546 --> 00:20:26.146
one alternative is to define
the macro on the command line

399
00:20:26.276 --> 00:20:27.726
or in the Xcode build settings.

400
00:20:30.086 --> 00:20:31.716
So, that is user-defined
modules.

401
00:20:31.906 --> 00:20:33.466
It's really pretty
straightforward

402
00:20:33.466 --> 00:20:36.096
in the common case, and it
gives you fast compilation,

403
00:20:36.436 --> 00:20:40.076
clear semantics, and a way of
interoperating with SWF code.

404
00:20:42.396 --> 00:20:44.826
So far, we've been
talking a lot about ways

405
00:20:44.826 --> 00:20:47.016
that LLVM helps you
modernize your code

406
00:20:47.016 --> 00:20:52.106
and adopt modern Objective-C
modules, but let's turn now

407
00:20:52.106 --> 00:20:53.346
and look at performance,

408
00:20:53.446 --> 00:20:55.566
which is the other theme
of this presentation.

409
00:20:56.846 --> 00:21:02.766
Profile Guided Optimization, or
PGO, is a new feature in Xcode 6

410
00:20:56.846 --> 00:21:02.766
Profile Guided Optimization, or
PGO, is a new feature in Xcode 6

411
00:21:03.316 --> 00:21:04.606
and it gives you a way

412
00:21:04.606 --> 00:21:07.206
of getting even more
performance out of your code.

413
00:21:08.436 --> 00:21:11.836
Let me give you an overall
high-level understanding

414
00:21:11.836 --> 00:21:13.396
of what this is about.

415
00:21:14.506 --> 00:21:17.426
One of the inherent
challenges for the compiler is

416
00:21:17.426 --> 00:21:19.656
that it has no way of
knowing what the input

417
00:21:19.656 --> 00:21:20.946
to your program is going to be.

418
00:21:21.356 --> 00:21:24.006
The only input to the
compiler is your source code.

419
00:21:25.176 --> 00:21:27.106
So, the compiler has to assume

420
00:21:27.366 --> 00:21:29.346
that all inputs are
equally likely.

421
00:21:30.506 --> 00:21:32.096
There are some cases
where it can guess

422
00:21:32.536 --> 00:21:35.116
that certain code paths will
be more common than others.

423
00:21:35.856 --> 00:21:39.346
For example, it can assume that
going through a loop is going

424
00:21:39.346 --> 00:21:41.516
to happen more often than
code outside of that loop.

425
00:21:42.246 --> 00:21:44.246
But, those are just guesses
and there are a lot of things

426
00:21:44.246 --> 00:21:45.496
that it simply can't know.

427
00:21:47.286 --> 00:21:50.616
If we provide a profile
as an additional input

428
00:21:50.616 --> 00:21:55.486
to the compiler it can now try
to optimize for the common case

429
00:21:55.816 --> 00:21:58.736
and do a better job
of optimization.

430
00:21:59.216 --> 00:22:01.036
And, what I mean
by a profile, here,

431
00:21:59.216 --> 00:22:01.036
And, what I mean
by a profile, here,

432
00:22:01.226 --> 00:22:03.876
is simply a count how
many times each statement

433
00:22:03.876 --> 00:22:08.366
in your app executes in a
typical run of your app.

434
00:22:09.086 --> 00:22:12.086
You may be wondering, "How do
I get a profile like that?"

435
00:22:12.466 --> 00:22:14.166
Again, we could use
the compiler here

436
00:22:14.826 --> 00:22:17.616
to generate a special
instrumented app

437
00:22:17.676 --> 00:22:19.316
that as it runs is going

438
00:22:19.316 --> 00:22:22.276
to count how many times
each statement executes.

439
00:22:22.606 --> 00:22:24.146
And then, when your app finishes

440
00:22:24.146 --> 00:22:26.676
with this special instrumented
version, it will write

441
00:22:26.676 --> 00:22:29.706
out that profile which
we can then use for PGO.

442
00:22:31.896 --> 00:22:34.936
So, how does the compiler
use that profile information?

443
00:22:35.736 --> 00:22:37.106
There are an awful lot of ways.

444
00:22:37.236 --> 00:22:39.636
So many optimizations
can benefit from this,

445
00:22:40.326 --> 00:22:41.916
but I'm highlighting
just three here

446
00:22:41.916 --> 00:22:43.316
that are particularly valuable.

447
00:22:43.946 --> 00:22:45.046
One is to the inliner.

448
00:22:46.066 --> 00:22:48.166
If we know that a
function is really hot,

449
00:22:48.166 --> 00:22:50.706
and by that I mean it's
run a lot, over and over.

450
00:22:51.256 --> 00:22:54.936
The inliner can be much more
aggressive about inlining that.

451
00:22:55.226 --> 00:22:57.016
When we're generating
the code we can try

452
00:22:57.016 --> 00:22:59.696
to layout the common
paths through your code

453
00:23:00.126 --> 00:23:02.246
so that they're contiguous,
which makes it easy

454
00:23:02.246 --> 00:23:04.156
for the processor
to run them fast.

455
00:23:04.986 --> 00:23:08.006
And the register allocator
can also try to keep values

456
00:23:08.066 --> 00:23:12.466
in registers throughout
those most common paths.

457
00:23:12.766 --> 00:23:14.006
Let's look at an example just

458
00:23:14.006 --> 00:23:16.306
to give you a better
understanding of this.

459
00:23:16.836 --> 00:23:20.286
This is some C++ code that's
going to iterate over a set

460
00:23:20.286 --> 00:23:22.306
of colored objects and
for each one it's going

461
00:23:22.306 --> 00:23:24.146
to update the position
of the object.

462
00:23:24.596 --> 00:23:27.646
So, at the top I've got
a loop over the objects,

463
00:23:28.206 --> 00:23:29.016
and for each one I'm going

464
00:23:29.016 --> 00:23:30.956
to call my Update
Position function.

465
00:23:32.066 --> 00:23:33.906
And, Update Position is
going to look and see

466
00:23:34.166 --> 00:23:38.206
if the object is red it moves in
a very simple horizontal line,

467
00:23:38.206 --> 00:23:39.456
so the code is really simple.

468
00:23:40.146 --> 00:23:42.266
But, if the object
is blue, let's assume

469
00:23:42.516 --> 00:23:44.696
that the movement is
much more complicated,

470
00:23:44.696 --> 00:23:46.796
I've got a very large
block of code here.

471
00:23:48.126 --> 00:23:51.416
Now, the compiler has no way
of knowing whether red objects

472
00:23:51.416 --> 00:23:53.216
or blue objects are more likely,

473
00:23:53.256 --> 00:23:56.196
so it just assumes they're
both equally likely.

474
00:23:56.196 --> 00:23:59.856
But, with PGO I might
be able to know

475
00:23:59.856 --> 00:24:02.796
that red objects
are far more common.

476
00:23:59.856 --> 00:24:02.796
that red objects
are far more common.

477
00:24:03.326 --> 00:24:05.906
And so, I'm highlighting
in red here the hot code,

478
00:24:06.346 --> 00:24:09.116
which is the code to iterate
over the set of objects and then

479
00:24:09.116 --> 00:24:10.546
to handle the red objects.

480
00:24:11.536 --> 00:24:14.986
I'm going to color-code
the cold code in blue,

481
00:24:15.016 --> 00:24:16.736
which is blue objects
which are rare

482
00:24:16.736 --> 00:24:18.346
for some reason in
this application.

483
00:24:19.216 --> 00:24:22.056
And then, let's look at how the
compiler would handle this code.

484
00:24:24.016 --> 00:24:27.786
Here's kind of the default code
layout that matches, roughly,

485
00:24:27.786 --> 00:24:29.286
the original source order.

486
00:24:29.606 --> 00:24:31.416
We've got the hot loop outside,

487
00:24:31.416 --> 00:24:34.346
and then the Update
Position function down below,

488
00:24:34.556 --> 00:24:37.536
with a little bit
of hot code in it.

489
00:24:38.486 --> 00:24:41.606
Inlining is one of the most
important optimizations

490
00:24:42.346 --> 00:24:45.826
and we'd really like to inline
that Update Position function.

491
00:24:46.226 --> 00:24:48.686
But, the compiler
can't inline everything

492
00:24:49.266 --> 00:24:52.586
or the code would bloat beyond a
point where it would be useful.

493
00:24:53.796 --> 00:24:57.006
But in this case, the Update
Position function is big

494
00:24:57.046 --> 00:24:59.916
because of all that cold code
for handling the blue objects

495
00:25:00.876 --> 00:25:02.646
and so it wouldn't
normally be inlined.

496
00:25:02.956 --> 00:25:05.866
But, because PGO tells us
there's some really hot code

497
00:25:05.866 --> 00:25:09.896
here, the inliner can be much
more aggressive about that

498
00:25:09.896 --> 00:25:11.216
in this particular case.

499
00:25:11.936 --> 00:25:16.046
So, we take the loop iterating
over the objects and split

500
00:25:16.046 --> 00:25:20.546
that in half and move the Update
Position code right inline.

501
00:25:21.416 --> 00:25:22.706
So, this is much better now.

502
00:25:22.706 --> 00:25:25.406
We've got a lot of the
hot code right together,

503
00:25:25.406 --> 00:25:29.966
but we've still got a big chunk
of this code for blue objects,

504
00:25:29.966 --> 00:25:31.816
the cold code, right in
the middle of our loop.

505
00:25:32.696 --> 00:25:36.596
And, PGO can help this, as well,
by changing the code layout.

506
00:25:36.926 --> 00:25:40.456
It knows that that code is cold
and can move it down below,

507
00:25:40.456 --> 00:25:43.436
out of the way, and we end
up with a nice tight loop

508
00:25:43.746 --> 00:25:45.016
that can run really fast.

509
00:25:45.536 --> 00:25:48.906
And, it also typically
enables other optimizations

510
00:25:48.906 --> 00:25:49.906
on that hot code.

511
00:25:51.146 --> 00:25:53.416
So obviously, this is
a simplified example,

512
00:25:53.416 --> 00:25:56.216
but hopefully gives you a
feel of the power of PGO

513
00:25:56.216 --> 00:25:58.486
and just how much it
can help the optimizer.

514
00:26:00.056 --> 00:26:01.606
So, you may want to use it.

515
00:26:02.406 --> 00:26:03.496
When does it make sense?

516
00:26:04.406 --> 00:26:07.746
The compiler does a really
good job optimizing by default.

517
00:26:08.916 --> 00:26:11.636
With PGO, if you do just
a little bit of extra work

518
00:26:11.856 --> 00:26:15.146
to gather the profile,
you can do even better.

519
00:26:15.826 --> 00:26:17.666
So obviously, if you're happy

520
00:26:17.666 --> 00:26:19.616
with the performance
you're already getting,

521
00:26:20.126 --> 00:26:21.806
you're probably not
motivated to do that --

522
00:26:22.036 --> 00:26:23.506
even that little
bit of extra work.

523
00:26:23.936 --> 00:26:25.966
But, if you need
more performance,

524
00:26:26.486 --> 00:26:28.486
by all means, give it a try.

525
00:26:29.136 --> 00:26:31.066
And, let me show
you some examples

526
00:26:31.066 --> 00:26:32.436
of just how much it can help.

527
00:26:33.676 --> 00:26:36.886
This is a graph showing
the speedup.

528
00:26:36.886 --> 00:26:38.876
Compare it with PGO
compared to a case

529
00:26:38.876 --> 00:26:40.636
of just a normal optimize build.

530
00:26:41.446 --> 00:26:44.206
And, I'm looking at four
different applications here;

531
00:26:44.206 --> 00:26:47.516
the Apple LLVM compiler
itself, applying PGO

532
00:26:47.606 --> 00:26:50.766
to the compiler itself,
the SQLite database,

533
00:26:51.246 --> 00:26:53.596
the PERL interpreter, and
gzip file compression.

534
00:26:54.676 --> 00:26:56.736
And, PGO gives us
speedups ranging

535
00:26:56.736 --> 00:26:59.456
from about 4% all
the way up to 18%.

536
00:27:00.786 --> 00:27:02.806
So, not all apps will
benefit this much.

537
00:27:03.026 --> 00:27:04.646
It really varies,
depending on the app,

538
00:27:05.116 --> 00:27:07.426
but clearly there's a
lot of potential here.

539
00:27:09.676 --> 00:27:12.606
So, if you want to try it,
how do you go about that?

540
00:27:13.166 --> 00:27:15.016
PGO is really easy to use.

541
00:27:15.616 --> 00:27:17.476
The first step is to
collect a profile.

542
00:27:17.476 --> 00:27:20.186
I'm going to come back and talk
about that in just a minute.

543
00:27:21.286 --> 00:27:24.146
Once you've done that, simply
go in the Xcode Build settings

544
00:27:24.146 --> 00:27:27.676
for your project and find
the Use Optimization Profile

545
00:27:27.676 --> 00:27:30.096
setting, and set it
to Yes, typically just

546
00:27:30.096 --> 00:27:31.446
for the release configuration.

547
00:27:32.216 --> 00:27:32.886
And that's it!

548
00:27:32.886 --> 00:27:34.576
You've enabled PGO.

549
00:27:35.696 --> 00:27:36.576
Once you've done that,

550
00:27:36.576 --> 00:27:39.326
as you continue developing
your app you may change it

551
00:27:39.326 --> 00:27:41.176
as you fix bugs, you
add new features,

552
00:27:41.876 --> 00:27:44.336
the code becomes
gradually out of sync

553
00:27:44.336 --> 00:27:46.136
with the profile you've
collected earlier.

554
00:27:47.096 --> 00:27:50.996
And, when that happens, the
compiler will simply fail to use

555
00:27:50.996 --> 00:27:52.486
that profile information.

556
00:27:52.486 --> 00:27:53.636
It won't break anything,

557
00:27:53.636 --> 00:27:56.666
you just gradually lose
the optimization benefit.

558
00:27:56.666 --> 00:27:58.986
And when that happens, it
will give you a warning.

559
00:27:59.966 --> 00:28:01.636
So, if you see warnings
like this,

560
00:27:59.966 --> 00:28:01.636
So, if you see warnings
like this,

561
00:28:01.636 --> 00:28:04.866
saying that your profile may
be out of date, as you see more

562
00:28:04.866 --> 00:28:06.866
and more of them, it's a good
indication to you that's time

563
00:28:06.866 --> 00:28:09.376
to go back and update
your profile.

564
00:28:10.726 --> 00:28:13.876
So, let's turn now and look at,
how do you generate the profile?

565
00:28:15.166 --> 00:28:19.406
Xcode 6 has a new command,
Generate Optimization Profile.

566
00:28:20.096 --> 00:28:21.176
When you run this command,

567
00:28:21.376 --> 00:28:24.316
Xcode will build the special
instrumented version of your app

568
00:28:24.316 --> 00:28:27.096
and then run it, and
you can then interact

569
00:28:27.096 --> 00:28:29.506
with the running app to
generate the profile.

570
00:28:29.506 --> 00:28:31.616
When it finishes running, it
will write out the profile

571
00:28:31.616 --> 00:28:32.956
and add it to your project.

572
00:28:34.316 --> 00:28:37.156
As you're running your app,
keep in mind it's important

573
00:28:37.156 --> 00:28:40.056
to exercise all of the
code that's important

574
00:28:40.056 --> 00:28:41.076
for your performance.

575
00:28:41.626 --> 00:28:43.906
If I have a game with
three different levels

576
00:28:44.416 --> 00:28:47.966
and I only play the first level
of my game, the compiler's going

577
00:28:47.966 --> 00:28:49.856
to assume that that's the
only thing that really matters

578
00:28:49.856 --> 00:28:52.096
and not work as hard
on the other levels.

579
00:28:54.356 --> 00:28:57.166
Now, you may be wondering, "If
I've written a really hard game,

580
00:28:57.936 --> 00:29:00.746
it may take a while to play
the whole thing to completion."

581
00:28:57.936 --> 00:29:00.746
it may take a while to play
the whole thing to completion."

582
00:29:01.396 --> 00:29:03.476
That could be a problem, right?

583
00:29:03.546 --> 00:29:05.966
So, Xcode has another option,

584
00:29:07.116 --> 00:29:10.076
which is to use your
performance tests as inputs

585
00:29:10.076 --> 00:29:11.286
to drive the profiling.

586
00:29:12.496 --> 00:29:15.296
Performance tests are a
new feature in Xcode 6.

587
00:29:15.796 --> 00:29:17.246
If you'd like to
learn more about them,

588
00:29:17.376 --> 00:29:19.096
there's a session right
here tomorrow morning

589
00:29:19.096 --> 00:29:20.756
on testing in Xcode 6.

590
00:29:21.586 --> 00:29:25.436
And, if you care about
performance you want to set

591
00:29:25.436 --> 00:29:28.406
up these performance tests
anyway, to catch regressions

592
00:29:28.406 --> 00:29:30.406
in your code, just to keep
track of how you're doing.

593
00:29:31.296 --> 00:29:34.276
And once you've gone to
that trouble to set them up,

594
00:29:34.776 --> 00:29:36.906
in most cases they're
pretty good inputs

595
00:29:36.906 --> 00:29:38.176
for driving this profile.

596
00:29:40.106 --> 00:29:42.396
Again though, keep in
mind it's important

597
00:29:42.596 --> 00:29:45.116
that your tests cover
the code in a way

598
00:29:45.116 --> 00:29:47.566
that reflects the
typical usage of your app.

599
00:29:47.946 --> 00:29:51.066
Going back to my three-level
game, if I write lots of tests

600
00:29:51.066 --> 00:29:53.356
for the first level and
only a few for the second

601
00:29:53.356 --> 00:29:56.006
and third level, again,
the compiler's going to end

602
00:29:56.006 --> 00:29:59.216
up optimizing more heavily
for that first level.

603
00:30:00.656 --> 00:30:03.416
Another benefit of using tests
is it gives you a great way

604
00:30:03.746 --> 00:30:06.306
of evaluating, how
much does PGO help me?

605
00:30:06.306 --> 00:30:07.726
You can just run your tests.

606
00:30:08.086 --> 00:30:10.286
Now, let me show you
that with a demo now.

607
00:30:12.376 --> 00:30:14.556
So, with the release
of the SWF language,

608
00:30:15.286 --> 00:30:18.026
we thought it would be
fun to make a demo app

609
00:30:18.026 --> 00:30:19.016
that would celebrate that.

610
00:30:19.986 --> 00:30:21.566
And so, rather than
the SWF language,

611
00:30:21.566 --> 00:30:25.056
we thought of the SWF birds
and we made an application

612
00:30:25.196 --> 00:30:28.326
that uses the Boids
Artificial Life Simulation

613
00:30:29.326 --> 00:30:30.816
to simulate a flock of SWFs.

614
00:30:33.146 --> 00:30:35.206
And, I can create a
whole bunch of them here

615
00:30:35.206 --> 00:30:36.436
and let them fly around.

616
00:30:36.516 --> 00:30:40.686
And, the way this Boids
application works is

617
00:30:40.686 --> 00:30:44.986
that each bird, or Boid,
compares its position to all

618
00:30:44.986 --> 00:30:48.346
of the other ones on the screen
and it calculates the distance

619
00:30:48.346 --> 00:30:52.066
between them to find the flock
of the birds nearest to it.

620
00:30:53.016 --> 00:30:57.136
And then, each Boid
has competing urges.

621
00:30:57.136 --> 00:30:59.446
On the one hand, it
wants to move closer

622
00:30:59.446 --> 00:31:00.696
to the center of the flock.

623
00:30:59.446 --> 00:31:00.696
to the center of the flock.

624
00:31:00.696 --> 00:31:03.886
At the same time, it doesn't
want to get too close.

625
00:31:04.676 --> 00:31:08.986
And so, if it gets too close to
another one it will move apart.

626
00:31:10.066 --> 00:31:12.946
And the performance of that,
as we add more and more

627
00:31:12.946 --> 00:31:15.666
of these Boids, could
become a problem.

628
00:31:16.466 --> 00:31:20.086
So, we set up a performance
test to track that,

629
00:31:20.936 --> 00:31:24.216
and this is a really
simple performance test.

630
00:31:25.576 --> 00:31:29.296
We set up a scene with 200 Boids
and measured the time it takes

631
00:31:29.296 --> 00:31:31.686
to update their positions
100 times,

632
00:31:31.686 --> 00:31:32.816
and that's our performance test.

633
00:31:32.816 --> 00:31:33.716
So, let's run that.

634
00:31:34.476 --> 00:31:36.376
Because I care about
performance,

635
00:31:36.816 --> 00:31:39.806
I'm going to edit my
current scheme to make sure

636
00:31:39.806 --> 00:31:41.656
that my test step is going

637
00:31:41.656 --> 00:31:44.186
to use the release-built
configuration

638
00:31:44.586 --> 00:31:46.436
so that we get optimized
results.

639
00:31:47.616 --> 00:31:49.726
And, I'll go to the
Product Test menu

640
00:31:51.376 --> 00:31:53.096
and run my performance
test here.

641
00:31:57.526 --> 00:31:57.936
All right.

642
00:31:58.086 --> 00:32:00.486
And now, because I haven't run
the test before I don't have a

643
00:31:58.086 --> 00:32:00.486
And now, because I haven't run
the test before I don't have a

644
00:32:00.536 --> 00:32:02.086
baseline, so let's go ahead

645
00:32:02.086 --> 00:32:06.536
and set the baseline
based on that first run.

646
00:32:07.666 --> 00:32:10.366
And now, let's try adding PGO.

647
00:32:11.256 --> 00:32:13.636
Under the Product
menu, Perform Action,

648
00:32:14.246 --> 00:32:16.636
down at the bottom here is this
new command I told you about,

649
00:32:16.636 --> 00:32:18.496
Generate Optimization Profile.

650
00:32:19.136 --> 00:32:22.516
I get two choices; I can
either run the application

651
00:32:23.616 --> 00:32:25.446
or I can use my performance
test.

652
00:32:25.446 --> 00:32:28.016
And, I'd like to show you how it
works with the performance test.

653
00:32:29.026 --> 00:32:33.256
I just click Build and Run,
and Xcode, very helpfully,

654
00:32:33.396 --> 00:32:35.906
warns me that I haven't
yet enabled PGO

655
00:32:35.906 --> 00:32:38.616
in the Build settings
and it offers to do that.

656
00:32:38.616 --> 00:32:41.196
So, let's go ahead and
let it enable that.

657
00:32:41.486 --> 00:32:44.236
It's now building a special
instrumented version of our app

658
00:32:44.236 --> 00:32:48.736
and running it using
the performance test.

659
00:32:49.136 --> 00:32:50.406
And when those tests finish --

660
00:32:52.516 --> 00:32:55.436
ah, I got a warning
here, an error.

661
00:32:55.436 --> 00:32:57.586
Let me just explain
what's happened here is

662
00:32:57.616 --> 00:33:00.016
that because we've
run the app with a lot

663
00:32:57.616 --> 00:33:00.016
that because we've
run the app with a lot

664
00:33:00.016 --> 00:33:02.966
of the instrumentation
code, it runs more slowly.

665
00:33:03.246 --> 00:33:05.616
But, this is just being
used to generate the profile

666
00:33:05.616 --> 00:33:06.656
so that's not a problem.

667
00:33:07.026 --> 00:33:10.016
I'm going to go back to the
Project Navigator a minute

668
00:33:10.616 --> 00:33:13.666
and show you that Xcode has
added this new Optimization

669
00:33:13.666 --> 00:33:14.836
Profiles folder.

670
00:33:15.446 --> 00:33:18.806
And inside of that, if you can
see it, there's my profile data.

671
00:33:20.066 --> 00:33:20.826
So, that's great!

672
00:33:21.416 --> 00:33:23.776
PGO is enabled, we
have a profile.

673
00:33:23.776 --> 00:33:25.676
Let's rerun those
performance tests.

674
00:33:26.276 --> 00:33:27.786
We'll go back to
run Product Test,

675
00:33:28.946 --> 00:33:30.156
and see how much does it help?

676
00:33:30.156 --> 00:33:34.956
And the tests are running now.

677
00:33:36.376 --> 00:33:39.036
And, wow, we got a 21%
improvement just like that.

678
00:33:39.386 --> 00:33:41.696
We didn't have to change the
code or do anything else.

679
00:33:42.516 --> 00:33:49.286
[ Applause ]

680
00:33:49.786 --> 00:33:51.276
So, that is PGO.

681
00:33:51.626 --> 00:33:54.836
It's a great new feature to help
you get even more performance,

682
00:33:54.946 --> 00:33:57.346
when you care about
getting every last drop

683
00:33:57.346 --> 00:33:58.006
out of your code.

684
00:33:59.136 --> 00:34:01.186
Continuing on this
theme of performance,

685
00:33:59.136 --> 00:34:01.186
Continuing on this
theme of performance,

686
00:34:01.266 --> 00:34:04.736
I'd like to turn the stage over
to Nadav Rotem, my colleague,

687
00:34:04.736 --> 00:34:08.936
to talk about advances
in vectorization.

688
00:34:09.536 --> 00:34:09.966
>> Thank you, Bob.

689
00:34:10.565 --> 00:34:10.735
Hi.

690
00:34:11.516 --> 00:34:16.476
[ Applause ]

691
00:34:16.976 --> 00:34:21.896
So, Last year with Xcode 5 we've
introduced a new optimization

692
00:34:22.186 --> 00:34:23.856
called loop vectorization.

693
00:34:24.156 --> 00:34:28.485
And, I would like to remind
you what loop vectorization is.

694
00:34:29.085 --> 00:34:33.186
So, modern processors
have vector instructions.

695
00:34:33.616 --> 00:34:37.025
These instructions can process
multiple scalars at once.

696
00:34:37.505 --> 00:34:40.406
And loop vectorization is
the compiler optimization

697
00:34:40.766 --> 00:34:43.866
that accelerates loops using
these vector instructions.

698
00:34:44.866 --> 00:34:45.735
And let's see how it's done.

699
00:34:46.295 --> 00:34:48.266
If you can see the code
on the screen here,

700
00:34:48.266 --> 00:34:49.656
you'll see that it's
a simple program

701
00:34:50.266 --> 00:34:52.716
that accumulates all
the numbers in the array

702
00:34:53.025 --> 00:34:54.436
into one variable, into sum.

703
00:34:54.496 --> 00:34:59.016
And, the natural way of
executing this code is

704
00:34:59.016 --> 00:35:02.366
to load one number at a time and
save it into the variable sum.

705
00:34:59.016 --> 00:35:02.366
to load one number at a time and
save it into the variable sum.

706
00:35:02.426 --> 00:35:04.586
And then, load another
number and save it into sum.

707
00:35:05.236 --> 00:35:07.736
But, there's the better
way of executing this code.

708
00:35:09.076 --> 00:35:11.856
What the loop vector does
for you automatically,

709
00:35:12.186 --> 00:35:15.596
is that it introduces a new
temporary variable, temp4.

710
00:35:15.596 --> 00:35:19.436
Now, this is a vector register,
a vector temporary variable.

711
00:35:20.576 --> 00:35:23.586
And, this allows us to
load four numbers at a time

712
00:35:23.856 --> 00:35:25.246
and add four numbers at a time,

713
00:35:25.556 --> 00:35:26.766
and we do it for
the entire array.

714
00:35:27.206 --> 00:35:29.136
So, this is obviously
much faster

715
00:35:29.136 --> 00:35:32.236
because we're processing
four numbers at once instead

716
00:35:32.236 --> 00:35:34.896
of processing one
number at a time.

717
00:35:35.036 --> 00:35:37.416
And, when you finish
scanning the array we need

718
00:35:37.416 --> 00:35:40.186
to take the four numbers
from that temporary register

719
00:35:40.186 --> 00:35:42.076
and add them together,
but it doesn't matter

720
00:35:42.076 --> 00:35:43.826
because usually an
array is pretty big.

721
00:35:44.836 --> 00:35:48.716
So, this is how loop
vectorization accelerates loops

722
00:35:48.716 --> 00:35:49.846
and makes your code run faster

723
00:35:49.956 --> 00:35:51.466
so that you don't have
to change your code.

724
00:35:52.696 --> 00:35:56.956
So, in Xcode 6 we've improved
loop vectorization in a number

725
00:35:56.956 --> 00:35:58.726
of ways, where first of all,

726
00:35:59.006 --> 00:36:01.126
we've improved the analysis
of complicated loops.

727
00:35:59.006 --> 00:36:01.126
we've improved the analysis
of complicated loops.

728
00:36:01.716 --> 00:36:03.976
This means that the
LLVM will be able

729
00:36:03.976 --> 00:36:07.906
to analyze more complicated
loops and vectorize more loops

730
00:36:07.906 --> 00:36:09.326
in your code, which is great.

731
00:36:09.696 --> 00:36:12.696
We've also integrated the
Loop Vectorizer with PGO,

732
00:36:12.696 --> 00:36:14.146
that Bob just mentioned.

733
00:36:14.596 --> 00:36:18.166
So, this means that when PGO is
available the Loop Vectorizer

734
00:36:18.236 --> 00:36:19.896
will be able to make
better decisions

735
00:36:20.406 --> 00:36:21.436
when vectorizing your code.

736
00:36:22.436 --> 00:36:27.016
We've also improved the X86
and ARM64 in coding support.

737
00:36:27.096 --> 00:36:28.066
Now this means two things.

738
00:36:28.766 --> 00:36:31.616
First of all, the Loop
Vectorizer has a better

739
00:36:31.616 --> 00:36:35.096
understanding of the processor
so it can predict better

740
00:36:35.376 --> 00:36:37.806
when it is profitable
to vectorize your codes.

741
00:36:38.226 --> 00:36:40.266
And the second thing
that it means is

742
00:36:40.266 --> 00:36:44.096
that when it vectorize your
code it'll generate better,

743
00:36:44.096 --> 00:36:46.216
more optimized code sequences,

744
00:36:46.286 --> 00:36:47.756
so that your code
would run faster.

745
00:36:49.926 --> 00:36:51.576
And, the last feature
that I want to talk to you

746
00:36:51.576 --> 00:36:54.156
about is specialization
of loop variables.

747
00:36:56.896 --> 00:37:02.946
So, most variables in your
code are only known at runtime.

748
00:36:56.896 --> 00:37:02.946
So, most variables in your
code are only known at runtime.

749
00:37:03.796 --> 00:37:09.396
These variables can be arguments
or computed expressions,

750
00:37:09.396 --> 00:37:12.356
and compiler doesn't know
the values of these variables

751
00:37:12.656 --> 00:37:15.076
at compile time,
only at runtime.

752
00:37:16.186 --> 00:37:17.776
And in many times,

753
00:37:18.176 --> 00:37:21.556
the Vectorizer cannot vectorize
your code unless the value

754
00:37:21.556 --> 00:37:23.536
of these variables is
known to be constant.

755
00:37:24.146 --> 00:37:25.416
So, let's take a
look at the example

756
00:37:25.416 --> 00:37:26.266
that I showed you earlier.

757
00:37:26.496 --> 00:37:30.026
So, this is a simple loop and
I modified it a little bit

758
00:37:30.026 --> 00:37:32.066
and I introduced
the Step variable.

759
00:37:32.356 --> 00:37:36.196
So now, instead of consecutively
scanning all of the elements

760
00:37:36.196 --> 00:37:38.796
in the array, we jump
and skip some elements,

761
00:37:38.796 --> 00:37:41.216
and we go in step
of variable Step.

762
00:37:42.826 --> 00:37:44.366
Now, we can't vectorize
this code

763
00:37:44.366 --> 00:37:48.056
because these elements are
not consecutive in memory.

764
00:37:48.056 --> 00:37:51.466
We can't use these vector
registers to load a few elements

765
00:37:51.466 --> 00:37:52.766
and then add them together.

766
00:37:52.766 --> 00:37:56.266
It's won't work unless
Step is equal to one.

767
00:37:56.586 --> 00:37:59.236
Well, in many cases
Step is equal to one.

768
00:38:00.236 --> 00:38:01.046
So, what do we do?

769
00:38:01.726 --> 00:38:04.776
Well, we've introduced a
new optimization that's

770
00:38:04.776 --> 00:38:05.976
called Specialization.

771
00:38:06.706 --> 00:38:09.546
What we do is we create
multiple versions of the loop.

772
00:38:10.206 --> 00:38:13.036
In one version of the loop
we assume that step is equal

773
00:38:13.036 --> 00:38:15.176
to one, and then we
vectorize the code

774
00:38:15.896 --> 00:38:17.046
and make the code run faster.

775
00:38:17.946 --> 00:38:20.706
But, in another version of the
loop we don't assume anything

776
00:38:20.756 --> 00:38:24.316
and the code runs
as-is -- scalar.

777
00:38:25.396 --> 00:38:29.106
And then, we add code
for selecting at runtime

778
00:38:29.636 --> 00:38:31.586
which version of
the loop to run.

779
00:38:31.926 --> 00:38:35.056
If Step happened to
be one, then we go

780
00:38:35.056 --> 00:38:36.956
and execute the vectorized
version.

781
00:38:37.136 --> 00:38:38.286
But, if Step is not equal

782
00:38:38.286 --> 00:38:40.956
to one then we execute
the regular version.

783
00:38:41.236 --> 00:38:43.206
And this compiler,
this new feature,

784
00:38:43.206 --> 00:38:45.666
allows the Loop Vectorizer

785
00:38:45.736 --> 00:38:50.146
to vectorize a lot more
loops, and it's great.

786
00:38:50.146 --> 00:38:52.106
Okay. So, this was
loop vectorization.

787
00:38:52.626 --> 00:38:56.606
But, in Xcode 6 we've also added
a new kind of vectorization.

788
00:38:56.816 --> 00:38:59.916
This is -- this new vectorizer
is not a loop vectorizer.

789
00:39:00.206 --> 00:39:03.156
It's called SLP Vectorizer,
which stands

790
00:39:03.156 --> 00:39:05.386
for Superword Level Parallelism,

791
00:39:05.686 --> 00:39:08.646
and it extracts parallelism
beyond loops.

792
00:39:09.116 --> 00:39:11.726
What this SLP Vectorizer
does is that it looks

793
00:39:11.726 --> 00:39:15.426
for multiple scalars in your
code and it glues them together

794
00:39:15.426 --> 00:39:16.686
into vector instructions.

795
00:39:18.136 --> 00:39:20.496
Let's see how it's done.

796
00:39:21.696 --> 00:39:23.596
So, on the screen you
see a very simple struct.

797
00:39:24.476 --> 00:39:26.936
This struct has two
members, x and y.

798
00:39:27.596 --> 00:39:28.816
They're consecutive in memory.

799
00:39:29.766 --> 00:39:32.246
And, we have a simple
function that converts units

800
00:39:32.946 --> 00:39:34.326
from feet to centimeters.

801
00:39:34.496 --> 00:39:36.086
Now, this is a very
simple conversion.

802
00:39:36.136 --> 00:39:39.486
All we have to do is
load the x member,

803
00:39:39.486 --> 00:39:41.206
multiply it by a
constant, and do it again.

804
00:39:41.206 --> 00:39:42.246
And, we do the same thing for y.

805
00:39:42.576 --> 00:39:46.606
And of course, the natural
way of executing this code is

806
00:39:46.636 --> 00:39:49.746
to do it consecutively;
load variable x,

807
00:39:49.836 --> 00:39:51.646
multiply it, save it back.

808
00:39:52.736 --> 00:39:56.396
Load variable y, multiply
it, and save it back.

809
00:39:57.076 --> 00:39:59.556
But again, there's a
better way of doing it,

810
00:39:59.866 --> 00:40:01.956
and this is what the
SLP Vectorizer does.

811
00:39:59.866 --> 00:40:01.956
and this is what the
SLP Vectorizer does.

812
00:40:02.486 --> 00:40:05.316
We can load x and y together
because they're consecutive

813
00:40:05.316 --> 00:40:09.026
in memory, multiply
them together again,

814
00:40:09.026 --> 00:40:10.316
and save them back to memory.

815
00:40:10.316 --> 00:40:13.366
And, this is SLP vectorization.

816
00:40:15.996 --> 00:40:20.766
SLP vectorization is very
beneficial for some kinds

817
00:40:20.766 --> 00:40:23.296
of applications, mainly
numeric applications,

818
00:40:23.296 --> 00:40:24.906
and we see great speedups.

819
00:40:25.186 --> 00:40:27.386
It may not speed
up all programs,

820
00:40:27.996 --> 00:40:30.096
but it definitely
speeds up a lot

821
00:40:30.166 --> 00:40:32.546
of numerically complex
applications.

822
00:40:33.816 --> 00:40:40.236
So to summarize, we've improved
loop vectorization in Xcode 6

823
00:40:40.526 --> 00:40:42.056
and we've introduced a new kind

824
00:40:42.056 --> 00:40:44.896
of vectorization called
SLP vectorization.

825
00:40:46.866 --> 00:40:49.676
Now in Xcode 5, when we
introduced the Loop Vectorizer,

826
00:40:49.916 --> 00:40:52.646
we did not enable it by default
and you had to go into one

827
00:40:52.646 --> 00:40:54.816
of the settings and
select Loop Vectorization

828
00:40:54.816 --> 00:40:56.186
and then Loop Vectorization
worked.

829
00:40:56.596 --> 00:40:59.426
Well, in Xcode 6 you
don't have to do anything

830
00:40:59.426 --> 00:41:02.136
because both the
new SLP Vectorizer

831
00:40:59.426 --> 00:41:02.136
because both the
new SLP Vectorizer

832
00:41:02.536 --> 00:41:05.776
and the improved Loop Vectorizer
are enabled by default

833
00:41:05.916 --> 00:41:08.036
when you build your
application in a release mode.

834
00:41:08.306 --> 00:41:09.746
This means that you don't
need to do anything.

835
00:41:09.746 --> 00:41:11.846
Just compile your
application in release mode

836
00:41:12.346 --> 00:41:15.016
and the improved LLVM will
make your code run faster.

837
00:41:18.916 --> 00:41:20.856
Okay. So, we talked
about a number

838
00:41:20.856 --> 00:41:23.036
of performance features in LLVM.

839
00:41:23.276 --> 00:41:25.486
We talked about PGO, we
talked about vectorization,

840
00:41:26.656 --> 00:41:29.696
but both of these
features are features

841
00:41:29.696 --> 00:41:32.806
of a static C and C++ compiler.

842
00:41:33.316 --> 00:41:36.346
But, LLVM is essential
technology here at Apple,

843
00:41:36.346 --> 00:41:38.156
that's used by many projects.

844
00:41:38.506 --> 00:41:40.126
And, one of the projects
that I want to talk to you

845
00:41:40.126 --> 00:41:43.266
about today is accelerating
JavaScript code.

846
00:41:47.356 --> 00:41:52.126
Well, WebKit is another
important technology.

847
00:41:52.126 --> 00:41:54.406
It's the heart of the
Safari Web Browser.

848
00:41:55.166 --> 00:41:57.646
And, WebKit needs to
execute JavaScript code

849
00:41:58.046 --> 00:42:00.326
because JavaScript is
everywhere in every web page.

850
00:41:58.046 --> 00:42:00.326
because JavaScript is
everywhere in every web page.

851
00:42:01.806 --> 00:42:03.236
And, WebKit has an interpreter,

852
00:42:03.536 --> 00:42:05.826
so when you load your Facebook
page, or any other page,

853
00:42:06.156 --> 00:42:09.966
WebKit starts executing your
code with the interpreter.

854
00:42:11.356 --> 00:42:13.906
But, WebKit also has
two JIT compilers

855
00:42:14.276 --> 00:42:15.926
to accelerate your code.

856
00:42:17.156 --> 00:42:19.466
When WebKit sees that you
execute the same function,

857
00:42:19.466 --> 00:42:21.816
the same JavaScript
functions over

858
00:42:21.816 --> 00:42:23.396
and over again, it says, "Huh.

859
00:42:23.716 --> 00:42:27.106
Let's take a little bit of time
to compile it really quickly

860
00:42:27.106 --> 00:42:29.396
so that it will run a little bit
faster than the interpreter."

861
00:42:29.876 --> 00:42:30.956
So, this is the fast JIT.

862
00:42:32.366 --> 00:42:36.236
And, when WebKit sees that you
execute a function many times,

863
00:42:36.806 --> 00:42:39.726
then it says, "All right,
let's also take the time

864
00:42:39.936 --> 00:42:41.596
and optimize this
function real quick,

865
00:42:41.836 --> 00:42:44.256
so that it will run a
little bit more faster,

866
00:42:44.256 --> 00:42:45.286
a little bit faster."

867
00:42:45.676 --> 00:42:49.736
So, we have the interpreter,
we have the fast JIT,

868
00:42:50.126 --> 00:42:54.176
and we have the optimizing
JIT, and there are tradeoffs

869
00:42:54.176 --> 00:42:56.836
between compile time and
the quality of the code.

870
00:42:57.186 --> 00:43:00.256
And this works really great,

871
00:42:57.186 --> 00:43:00.256
And this works really great,

872
00:43:01.136 --> 00:43:03.096
except that JavaScript
is evolving.

873
00:43:04.146 --> 00:43:05.986
People start writing large,

874
00:43:06.106 --> 00:43:08.696
compute intensive
applications in JavaScript.

875
00:43:09.346 --> 00:43:13.356
People then compile C++
programs into JavaScript

876
00:43:13.776 --> 00:43:15.326
and run them in the browser.

877
00:43:15.586 --> 00:43:18.256
You can even compile
a Quake3 and run it

878
00:43:18.256 --> 00:43:20.446
in your browser today,
which is --

879
00:43:20.486 --> 00:43:22.266
some people like it [laughter].

880
00:43:23.586 --> 00:43:25.716
Yeah, it's great.

881
00:43:26.436 --> 00:43:30.956
But, it's a new-use case
and we need a new compiler

882
00:43:31.306 --> 00:43:32.356
to support this use-case,

883
00:43:32.926 --> 00:43:35.476
and this is where LLVM
comes into the picture.

884
00:43:36.986 --> 00:43:41.446
So, we're adding LLVM as a
fourth tier compiler to WebKit.

885
00:43:43.896 --> 00:43:45.796
Functions that run many, many,

886
00:43:45.796 --> 00:43:48.906
many times are now
compiled with LLVM.

887
00:43:49.096 --> 00:43:52.716
And, LLVM is tuned for making
the most out of your code,

888
00:43:52.716 --> 00:43:55.736
for really trying hard
to optimize your code

889
00:43:55.966 --> 00:43:59.366
and to generate excellent
code quality.

890
00:43:59.746 --> 00:44:03.106
And again, there's a
tradeoff between compiled time

891
00:43:59.746 --> 00:44:03.106
And again, there's a
tradeoff between compiled time

892
00:44:03.386 --> 00:44:06.286
and the quality of the code,
so WebKit really waits for you

893
00:44:06.286 --> 00:44:09.426
to execute that function
many, many times as you do

894
00:44:09.426 --> 00:44:10.976
in computing intensive
applications

895
00:44:11.016 --> 00:44:11.856
that you run in the browser.

896
00:44:11.856 --> 00:44:17.746
But, compiling JavaScript
with LLVM is very different

897
00:44:17.746 --> 00:44:21.126
from compiling C or Objective-C
because JavaScript --

898
00:44:21.786 --> 00:44:24.446
it's a great language,
it's a dynamic language,

899
00:44:24.446 --> 00:44:26.226
and if you look at the code
on the screen you'll see

900
00:44:26.226 --> 00:44:27.726
that there are no types.

901
00:44:28.356 --> 00:44:33.086
There's this n argument
here, but what is n?

902
00:44:33.086 --> 00:44:34.246
Is it an integer?

903
00:44:34.326 --> 00:44:35.346
Is it double?

904
00:44:35.626 --> 00:44:36.436
Is it a class?

905
00:44:37.306 --> 00:44:38.506
It can be a lot of
different things.

906
00:44:39.706 --> 00:44:41.316
So, how do we compile it?

907
00:44:41.906 --> 00:44:48.616
Well luckily, WebKit executed
this function many, many, many,

908
00:44:48.616 --> 00:44:50.376
many times before
with the interpreter,

909
00:44:50.526 --> 00:44:56.636
so it knows that in the last
1000 times n was an integer.

910
00:44:57.006 --> 00:45:00.016
So now, we can compile this code
assuming that n is an integer,

911
00:44:57.006 --> 00:45:00.016
So now, we can compile this code
assuming that n is an integer,

912
00:45:00.996 --> 00:45:03.406
except that someone made decide

913
00:45:03.406 --> 00:45:06.466
to pass an n that's
not an integer.

914
00:45:06.466 --> 00:45:09.206
Someone may decide to
pass a double or a class

915
00:45:09.736 --> 00:45:12.266
and then everything will
break and we can't allow that.

916
00:45:12.786 --> 00:45:13.866
So, what do we do?

917
00:45:14.216 --> 00:45:15.606
We use a technique
that's very similar

918
00:45:15.606 --> 00:45:16.936
to what we did with
the vectorizer.

919
00:45:17.596 --> 00:45:18.336
We add checks.

920
00:45:18.336 --> 00:45:19.896
We make assumptions
and we add checks.

921
00:45:20.306 --> 00:45:21.946
We assume that n is an integer.

922
00:45:22.806 --> 00:45:24.976
We assume that n
does not overflow.

923
00:45:24.976 --> 00:45:28.476
And then, we verify our
assumptions at runtime.

924
00:45:29.526 --> 00:45:30.486
Okay, that's great.

925
00:45:30.966 --> 00:45:32.016
But, what is the fallback?

926
00:45:32.016 --> 00:45:32.506
What do we do?

927
00:45:33.276 --> 00:45:35.656
When our assumptions
fail we have to go back

928
00:45:35.656 --> 00:45:38.676
to the interpreter because only
the interpreter can handle all

929
00:45:38.676 --> 00:45:40.736
these cases, all
these extreme cases.

930
00:45:42.426 --> 00:45:45.616
But, moving back to the
interpreter is not simple

931
00:45:46.106 --> 00:45:47.826
because we started
executing it in a code

932
00:45:47.826 --> 00:45:48.976
and the function made changes.

933
00:45:48.976 --> 00:45:50.976
We can't just start executing
it from the beginning.

934
00:45:51.736 --> 00:45:54.536
So, we developed a technology
that's called On-Stack

935
00:45:54.536 --> 00:45:57.406
Replacement, which is
techniques that is used

936
00:45:57.856 --> 00:46:01.856
to migrate the state of the
program from the JITed code

937
00:45:57.856 --> 00:46:01.856
to migrate the state of the
program from the JITed code

938
00:46:01.856 --> 00:46:03.886
in LLVM back to WebKit.

939
00:46:04.156 --> 00:46:07.486
And, LLVM needs to track all of
the variables in your program

940
00:46:07.486 --> 00:46:09.966
and some of them may be in the
register, some of them may be

941
00:46:09.966 --> 00:46:13.406
in the stack, and now we're
able to migrate them from LLVM

942
00:46:13.406 --> 00:46:17.666
to WebKit and continue
the execution in WebKit.

943
00:46:17.906 --> 00:46:22.726
Now, this doesn't happen all the
time, it's a very extreme case.

944
00:46:22.726 --> 00:46:24.806
But when it happens, we
have to handle these cases.

945
00:46:26.996 --> 00:46:32.086
Okay, now compiling code
with LLVM is very beneficial,

946
00:46:32.086 --> 00:46:35.956
especially for compute intensive
applications and especially

947
00:46:36.226 --> 00:46:39.106
for these C++ applications
compiled

948
00:46:39.106 --> 00:46:40.976
into JavaScript,
run in the browser.

949
00:46:43.986 --> 00:46:45.596
And, we're really excited
about this technology.

950
00:46:45.886 --> 00:46:46.216
It's great.

951
00:46:47.176 --> 00:46:49.966
So now, we use LLVM.

952
00:46:50.386 --> 00:46:53.566
So to summarize, we use LLVM
as a fourth tier compiler

953
00:46:53.966 --> 00:47:00.006
in Safari, both for X86
and ARM64 on iOS and OS X,

954
00:46:53.966 --> 00:47:00.006
in Safari, both for X86
and ARM64 on iOS and OS X,

955
00:47:00.006 --> 00:47:02.306
and we get excellent
performance speedups.

956
00:47:03.336 --> 00:47:05.276
To summarize this
talk, today we talked

957
00:47:05.276 --> 00:47:08.286
about modernizing Objective-C
code and we also talked

958
00:47:08.286 --> 00:47:09.946
about a number of
performance features.

959
00:47:10.716 --> 00:47:12.326
If you have any more questions,

960
00:47:12.326 --> 00:47:15.966
you can contact our Developer
Tools Evangelist, Dave DeLong,

961
00:47:16.156 --> 00:47:19.276
or you can go to the Apple
website or to the LLVM website.

962
00:47:19.476 --> 00:47:24.046
There are a few related
sessions, and I encourage you

963
00:47:24.046 --> 00:47:26.496
to attend these sessions
or to watch them online.

964
00:47:28.506 --> 00:47:31.756
Thank you, very much,
and have a good week.

965
00:47:32.436 --> 00:47:32.896
Bye-bye.

966
00:47:33.016 --> 00:47:35.000
[ Applause ]
