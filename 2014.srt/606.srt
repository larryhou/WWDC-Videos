
1
00:00:11.076 --> 00:00:12.496
>> Hello. My name is Norman.

2
00:00:12.646 --> 00:00:16.586
I'd like to give you a quick
tour on some of the details

3
00:00:16.586 --> 00:00:18.436
in what's new in SpriteKit.

4
00:00:19.316 --> 00:00:22.206
So last year we had announced
SpriteKit at a conference,

5
00:00:22.506 --> 00:00:24.536
a high performance
2D game engine

6
00:00:24.536 --> 00:00:25.946
with built-in physics support.

7
00:00:26.256 --> 00:00:28.656
We also built tools
right inside of Xcode

8
00:00:28.656 --> 00:00:31.626
to help developers improve their
game content iteration time

9
00:00:32.046 --> 00:00:35.906
like the particle editor and the
automatic [inaudible] generator.

10
00:00:36.636 --> 00:00:38.856
And this year we made
SpriteKit even better.

11
00:00:39.506 --> 00:00:42.846
We have awesome graphics
technologies like shaders,

12
00:00:43.016 --> 00:00:45.606
lightings and shadows
that help you really bring

13
00:00:45.606 --> 00:00:46.956
out the liveliness of your game.

14
00:00:47.746 --> 00:00:49.946
We also have good
simulation technologies

15
00:00:49.946 --> 00:00:52.626
like per-pixel physics
occlusion, physics field,

16
00:00:53.076 --> 00:00:54.926
universal kinematics
and constraints.

17
00:00:55.246 --> 00:00:57.746
They really allow you to
build rich user interactions.

18
00:00:59.086 --> 00:00:59.836
So that's not all.

19
00:01:00.566 --> 00:01:03.956
In Xcode 6's release we now
have a SpriteKit editor built

20
00:01:03.956 --> 00:01:07.366
into the IDE that allow
you to create game scenes

21
00:01:07.366 --> 00:01:08.556
without writing any code.

22
00:01:08.686 --> 00:01:13.106
And you can use the very same
editor to interact with any

23
00:01:13.106 --> 00:01:15.206
of the new and existing
SpriteKit features.

24
00:01:15.576 --> 00:01:16.386
So how cool is that?

25
00:01:18.936 --> 00:01:21.056
So, for the agenda for
this session we're going

26
00:01:21.056 --> 00:01:23.656
to start looking at how
to use custom shaders

27
00:01:23.726 --> 00:01:26.146
to customize the drawing
behaviors of your sprite,

28
00:01:26.766 --> 00:01:29.546
how to add lightings and
shadows to your scene

29
00:01:30.046 --> 00:01:32.316
and we really have a lot
of new physics updates I'd

30
00:01:32.316 --> 00:01:33.696
like to give you an update on.

31
00:01:34.296 --> 00:01:35.136
And the integration

32
00:01:35.136 --> 00:01:37.446
with SceneKit really
brings new possibilities

33
00:01:37.446 --> 00:01:39.016
of writing to these games.

34
00:01:39.426 --> 00:01:42.826
It also blurs the lines
between the actual 2D game

35
00:01:42.826 --> 00:01:44.186
and 3D game implementations.

36
00:01:45.196 --> 00:01:48.146
And lastly, I'm going to give
you a quick tour and demo

37
00:01:48.146 --> 00:01:51.426
of the new SpriteKit editor
and some other improvements

38
00:01:51.426 --> 00:01:53.056
in already existing APIs.

39
00:01:53.056 --> 00:01:57.746
So the first thing I want
to talk about is shaders.

40
00:01:59.076 --> 00:02:02.916
SpriteKit does a fantastic job
of extracting the lower-level,

41
00:01:59.076 --> 00:02:02.916
SpriteKit does a fantastic job
of extracting the lower-level,

42
00:02:02.916 --> 00:02:06.416
platform-dependent graphics
APIs away from our users.

43
00:02:06.986 --> 00:02:11.096
But from time to time there's
always a very special effect

44
00:02:11.096 --> 00:02:17.016
they want to achieve, say a
custom blur or a heat signature

45
00:02:17.016 --> 00:02:20.396
when you turn on thermal
vision, the post-effect,

46
00:02:20.596 --> 00:02:23.196
or when you build a space game
where the spaceship's hit,

47
00:02:23.366 --> 00:02:26.306
taking damage, you want to have
a custom warping effect just on,

48
00:02:26.306 --> 00:02:27.026
like, the sprite.

49
00:02:27.786 --> 00:02:30.716
The shaders become a more
relevant solution in this case

50
00:02:30.996 --> 00:02:33.406
and for this release we
do give you the ability.

51
00:02:35.126 --> 00:02:36.916
So here we have a
SpriteKit shader demo.

52
00:02:37.006 --> 00:02:39.746
We're actually just
rendering a single sprite

53
00:02:39.746 --> 00:02:43.086
without any textures but
the sprite itself is running

54
00:02:43.086 --> 00:02:43.876
on custom shaders.

55
00:02:44.266 --> 00:02:45.716
So the shader does a
lot of things here.

56
00:02:46.196 --> 00:02:47.986
Its' rendering all the
stars in the background;

57
00:02:47.986 --> 00:02:50.936
it's also drawing the grid;
also provides the warping effect

58
00:02:50.936 --> 00:02:53.366
of the grid; and also
when the touch --

59
00:02:53.456 --> 00:02:56.746
the user touches any of
the screen areas it's going

60
00:02:56.746 --> 00:02:58.176
to provide an energy effect.

61
00:02:58.686 --> 00:03:00.356
So all of these are
done in shaders.

62
00:02:58.686 --> 00:03:00.356
So all of these are
done in shaders.

63
00:03:00.686 --> 00:03:05.326
So to do this we're also passing
the actual touch locations

64
00:03:05.326 --> 00:03:06.786
down to the shaders as uniform.

65
00:03:06.786 --> 00:03:09.066
So in a shader, shader
knows, "Okay,

66
00:03:09.316 --> 00:03:10.566
the user just touched this area.

67
00:03:10.566 --> 00:03:12.196
Now let's render
the warping here

68
00:03:12.506 --> 00:03:15.176
and render the energy
effect associated with it."

69
00:03:15.916 --> 00:03:18.786
So let's have a look at what the
overview of a shader looks like.

70
00:03:19.276 --> 00:03:22.316
So shader helps you
really customize the way

71
00:03:22.316 --> 00:03:23.136
that sprites are drawn.

72
00:03:23.136 --> 00:03:26.896
You have 100 percent control of
how every single pixel is going

73
00:03:26.896 --> 00:03:28.086
to be output on the screen.

74
00:03:29.236 --> 00:03:32.606
The shader syntax uses
very a C-like GLSL syntax,

75
00:03:32.916 --> 00:03:36.846
a very powerful tool to have
any of the powerful effects,

76
00:03:36.846 --> 00:03:38.996
like image processing or, to --

77
00:03:38.996 --> 00:03:42.956
all the way to fast motion blurs
that's being used in 3D games.

78
00:03:43.626 --> 00:03:45.726
And whether you are
new to SpriteKit

79
00:03:45.726 --> 00:03:48.776
or existing SpriteKit users,
you can drop this custom shader

80
00:03:48.776 --> 00:03:50.946
in with just a single
line of code.

81
00:03:51.506 --> 00:03:55.756
So to use custom shaders we
create a brand new object called

82
00:03:55.756 --> 00:03:56.656
SKShaders object.

83
00:03:56.956 --> 00:04:00.406
It is essentially a
container that holds the GLSL,

84
00:03:56.956 --> 00:04:00.406
It is essentially a
container that holds the GLSL,

85
00:04:00.406 --> 00:04:01.866
the OpenGL ES fragment shader.

86
00:04:01.866 --> 00:04:03.816
So we're following the GLSL --

87
00:04:03.876 --> 00:04:08.466
OpenGL ES 2.0 standard and once
you write a shader it can be

88
00:04:08.526 --> 00:04:10.666
deployed to both OS X and iOS.

89
00:04:11.996 --> 00:04:14.726
So here is a list of the
nodes that's being supported

90
00:04:14.726 --> 00:04:15.366
in SpriteKit.

91
00:04:15.366 --> 00:04:17.546
So SKSpriteNode supports
custom shaders

92
00:04:18.016 --> 00:04:21.435
and SKShapeNode now supports
custom shaders on both drawings,

93
00:04:21.435 --> 00:04:22.616
the stroking and filling.

94
00:04:23.366 --> 00:04:24.666
And SKEmmiterNode.

95
00:04:24.986 --> 00:04:28.696
So with the particle effect you
have a custom shader running

96
00:04:28.696 --> 00:04:30.936
on every single emitter
particles in the Scene.

97
00:04:31.466 --> 00:04:33.086
And lastly the EffectNode

98
00:04:33.086 --> 00:04:35.246
and SKScene now support
custom shaders.

99
00:04:35.546 --> 00:04:37.426
So that gives you
the powerful ability

100
00:04:37.426 --> 00:04:41.006
to not only use the CI filters
to have a full-screen effect,

101
00:04:41.306 --> 00:04:44.646
but also you can have a shader
to have any possible effect

102
00:04:44.646 --> 00:04:45.876
that you want to implement.

103
00:04:46.836 --> 00:04:49.286
So, as soon as the shader is
getting uploaded to the sprite

104
00:04:49.286 --> 00:04:53.026
and it's being run at the pixel
level, we're also passing a lot

105
00:04:53.026 --> 00:04:54.646
of building attributes
to the shader.

106
00:04:54.646 --> 00:04:57.716
So we don't have to set
up a brand-new attribute

107
00:04:57.716 --> 00:04:59.366
or uniforms and pass it in.

108
00:04:59.546 --> 00:05:01.626
So, for example, here
we're passing the u-texture

109
00:04:59.546 --> 00:05:01.626
So, for example, here
we're passing the u-texture

110
00:05:01.886 --> 00:05:03.926
that gives it to you as
what texture is being used

111
00:05:03.926 --> 00:05:05.806
for the current sprite
as well as,

112
00:05:05.806 --> 00:05:08.336
as well as the texture
coordinate and the size

113
00:05:08.336 --> 00:05:10.606
of the sprite that's
in pixel size.

114
00:05:12.606 --> 00:05:14.776
So how does shader
work in SpriteKit?

115
00:05:14.916 --> 00:05:20.756
Once you know about the SKShader
class now it has two possible

116
00:05:21.056 --> 00:05:22.296
attributes that you
can start on.

117
00:05:22.296 --> 00:05:23.876
The first one is
the shader source.

118
00:05:24.236 --> 00:05:26.166
You can create a shader
from two possibilities

119
00:05:26.166 --> 00:05:27.206
by attaching the source.

120
00:05:27.496 --> 00:05:29.816
One is creating the
shader from a file

121
00:05:30.186 --> 00:05:33.356
and also you can set the
shader from a string.

122
00:05:34.726 --> 00:05:37.556
And the shader itself also
has an array of uniforms.

123
00:05:37.556 --> 00:05:41.076
These are optional, but if your
shader actually requires any

124
00:05:41.076 --> 00:05:43.956
of the external parameters
that're being set in your game,

125
00:05:44.376 --> 00:05:48.156
you can use that SK uniforms
on the uniforms property.

126
00:05:48.966 --> 00:05:51.146
So now once we have
these two properties set,

127
00:05:51.606 --> 00:05:54.796
the shader is loaded
and is ready to go.

128
00:05:55.996 --> 00:05:58.116
And we have a scene
here, for example,

129
00:05:58.116 --> 00:05:59.746
a scene has three
separate sprites.

130
00:06:00.096 --> 00:06:02.416
You can assign a shader
directly to the scene.

131
00:06:02.416 --> 00:06:05.396
You can assign the shader
to any of the sprites

132
00:06:05.486 --> 00:06:08.056
and then they picked up
the effect right away

133
00:06:08.056 --> 00:06:12.066
in the next, in the next frame.

134
00:06:12.066 --> 00:06:14.916
So creating a shader will have
the new API called SKShader.

135
00:06:14.916 --> 00:06:16.576
It can create with a file.

136
00:06:16.576 --> 00:06:19.386
SKShader WithFileNamed with
passing like "blur.fsh".

137
00:06:19.476 --> 00:06:23.946
The shader will look like any
G, OpenGL fragment program

138
00:06:23.946 --> 00:06:25.056
that has a main function

139
00:06:25.506 --> 00:06:27.726
and in the return values
and the gl-FragColor.

140
00:06:28.246 --> 00:06:29.316
And if the shader needs any

141
00:06:29.316 --> 00:06:32.486
of the custom uniforms you can
just set a uniforms array here

142
00:06:32.486 --> 00:06:36.066
with creating SKUinform
uniformWithName.

143
00:06:36.066 --> 00:06:37.016
You give it a name here.

144
00:06:37.016 --> 00:06:39.146
We call it u-red,
that's a floating type

145
00:06:39.666 --> 00:06:42.196
and the next one we're
setting a u texture,

146
00:06:42.196 --> 00:06:45.516
or passing in a secondary
texture to the custom shader.

147
00:06:46.036 --> 00:06:50.516
So the supported types are
float, texture, back to 2,

148
00:06:50.516 --> 00:06:54.376
3 and 4 and matrix
2x2, 3x3 and 4x4.

149
00:06:57.186 --> 00:06:59.636
And for the full list
of the custom symbols

150
00:06:59.636 --> 00:07:00.976
that we're passing
into the shader,

151
00:06:59.636 --> 00:07:00.976
that we're passing
into the shader,

152
00:07:00.976 --> 00:07:02.406
as soon as your shader
is getting run,

153
00:07:02.646 --> 00:07:03.446
here is the full list.

154
00:07:03.666 --> 00:07:07.226
So in terms of uniform, you get
direct access to the texture

155
00:07:07.226 --> 00:07:10.316
of the sprite, the
sprite size in pixels,

156
00:07:10.626 --> 00:07:13.416
the global time (in case you
need to do any of the animation

157
00:07:13.416 --> 00:07:16.736
in terms of color or shapes)
and you also have access,

158
00:07:17.006 --> 00:07:19.336
if you have a custom shader
that's running on a shape,

159
00:07:19.766 --> 00:07:21.256
to the shape path length.

160
00:07:22.296 --> 00:07:24.716
In terms of varying we're
passing the texture coordinate,

161
00:07:24.866 --> 00:07:28.366
the color mix, as well as
the distance of the path

162
00:07:29.316 --> 00:07:32.136
and we also have a very
convenient method in the shader,

163
00:07:32.136 --> 00:07:34.826
so you can call directly,
called SKDefaultShading.

164
00:07:35.056 --> 00:07:37.486
This is as if you were

165
00:07:37.486 --> 00:07:40.316
to let SpriteKit render
the current sprite

166
00:07:40.416 --> 00:07:44.406
and give me the pixel value
of the current behavior.

167
00:07:44.966 --> 00:07:47.576
So the shaders are cool.

168
00:07:47.576 --> 00:07:50.656
There's some best practices
I'd like to call out.

169
00:07:50.656 --> 00:07:54.666
So number one, I'd like to
recommend using built-in

170
00:07:54.666 --> 00:07:56.266
uniforms as much as possible.

171
00:07:56.516 --> 00:07:58.656
So we do passing a lot of
uniforms for you to use.

172
00:07:58.656 --> 00:08:00.856
That gives you a lot
of raw attributes

173
00:07:58.656 --> 00:08:00.856
That gives you a lot
of raw attributes

174
00:08:00.856 --> 00:08:03.246
of what we're doing
at the OpenGL level.

175
00:08:03.746 --> 00:08:07.346
But if you do need to access
all the same uniforms,

176
00:08:07.606 --> 00:08:08.966
please use the building one

177
00:08:08.966 --> 00:08:10.656
to minimize the amount
of redundancy.

178
00:08:11.246 --> 00:08:14.466
And also we would recommend

179
00:08:14.466 --> 00:08:17.416
to avoid changing this shader
source in the middle of a frame

180
00:08:17.416 --> 00:08:19.926
because that will force a
shader recompilation happening

181
00:08:20.006 --> 00:08:21.386
at the backend.

182
00:08:21.386 --> 00:08:25.596
And also when the shader is
being loaded and we recommend

183
00:08:25.596 --> 00:08:28.046
to loadset all the
uniforms upfront

184
00:08:29.006 --> 00:08:30.776
and you can change
uniforms that reframe,

185
00:08:30.776 --> 00:08:31.896
but that's nice and fast.

186
00:08:32.176 --> 00:08:34.746
But adding or removing
uniforms will also cause another

187
00:08:34.746 --> 00:08:35.746
shader recompilation.

188
00:08:37.885 --> 00:08:40.106
Also in terms of draw
call performance we

189
00:08:40.106 --> 00:08:44.496
like to share the same shader
instance as much as possible

190
00:08:44.496 --> 00:08:45.996
because the same shader running

191
00:08:45.996 --> 00:08:49.406
on multiple drawing instances
gets to batch together.

192
00:08:50.556 --> 00:08:53.476
And we'll recommend to
initialize the shader

193
00:08:53.476 --> 00:08:57.756
at load time and initialize the
shader using a filename rather

194
00:08:57.756 --> 00:09:01.786
than initialize shader using
string because if the shaders --

195
00:08:57.756 --> 00:09:01.786
than initialize shader using
string because if the shaders --

196
00:09:01.786 --> 00:09:04.566
multiple shaders are sharing
the same shader source then

197
00:09:04.566 --> 00:09:07.376
SpriteKit will pick it
up as identical shaders

198
00:09:07.376 --> 00:09:10.276
or drawbacks -- draw
call batching performance

199
00:09:10.556 --> 00:09:11.296
remain high.

200
00:09:11.636 --> 00:09:15.616
So the summary of using
custom shaders: it allows you

201
00:09:15.616 --> 00:09:18.876
to completely customize the
way sprites are being rendered

202
00:09:18.876 --> 00:09:19.436
on the screen.

203
00:09:19.716 --> 00:09:22.666
You have raw access to a
lot of building attributes

204
00:09:22.666 --> 00:09:25.326
that we're passing
down to the shader.

205
00:09:25.826 --> 00:09:27.756
And it can create an
infinite number of cool

206
00:09:27.756 --> 00:09:29.196
and unique effects
for your game.

207
00:09:29.596 --> 00:09:32.496
Next I want to talk about
lightings and shadows.

208
00:09:33.856 --> 00:09:35.726
So lightings and
shadows really bring

209
00:09:35.726 --> 00:09:37.636
out the liveliness
of your games.

210
00:09:37.636 --> 00:09:39.556
Say, if I'm building
a dungeons game,

211
00:09:39.556 --> 00:09:41.296
and walking in a
long corridor...

212
00:09:41.536 --> 00:09:44.106
All of a sudden the
area gets dark,

213
00:09:44.106 --> 00:09:46.576
and all of a sudden
I see a very dim,

214
00:09:46.576 --> 00:09:48.536
shaky light at the
end of the hallway...

215
00:09:48.536 --> 00:09:52.436
that kind of brings out
that really scary atmosphere

216
00:09:52.436 --> 00:09:54.946
and mood for the player.

217
00:09:55.646 --> 00:09:57.036
So to create a light

218
00:09:57.036 --> 00:10:00.966
in SpriteKit we introduce a
new type called SKLightNode.

219
00:09:57.036 --> 00:10:00.966
in SpriteKit we introduce a
new type called SKLightNode.

220
00:10:01.966 --> 00:10:05.476
You can add it to the scene and
position it to anywhere you want

221
00:10:06.226 --> 00:10:07.246
and it can light any

222
00:10:07.246 --> 00:10:09.056
of the sprites that're
being participated

223
00:10:09.056 --> 00:10:10.066
in the current light.

224
00:10:10.686 --> 00:10:14.376
You can change the color,
shadow and falloff of the light

225
00:10:15.006 --> 00:10:19.196
and will support up to 8 lights,
like, for a single sprite.

226
00:10:20.096 --> 00:10:23.176
And the bottom line
is SKLightNode is just

227
00:10:23.176 --> 00:10:24.186
another SKNode.

228
00:10:24.736 --> 00:10:27.746
You can move it around,
turn it to another sprite

229
00:10:27.746 --> 00:10:29.806
if you want the light to
follow one of your sprites.

230
00:10:30.206 --> 00:10:34.386
You can run actions on it,
have it run follow path.

231
00:10:34.906 --> 00:10:35.926
It's really cool.

232
00:10:37.246 --> 00:10:38.206
So now let's look at some

233
00:10:38.206 --> 00:10:41.196
of the basic add
properties for SKLightNode.

234
00:10:41.336 --> 00:10:42.356
So here we have a scene.

235
00:10:42.606 --> 00:10:43.446
It's very bland.

236
00:10:43.646 --> 00:10:45.736
We add a light source
in the scene.

237
00:10:46.926 --> 00:10:48.656
Now if -- we can change
to the lightColor,

238
00:10:48.656 --> 00:10:50.596
we decide the lightColor
to be yellow,

239
00:10:50.676 --> 00:10:52.836
it adds a yellow tint
to the light color.

240
00:10:53.666 --> 00:10:56.646
And now if we set a
shadowColor to be gray...

241
00:10:57.756 --> 00:10:59.806
and now the boxes start
casting shadows...

242
00:11:01.056 --> 00:11:03.686
and lastly if we want
to see a little bit more

243
00:11:03.686 --> 00:11:05.816
out of the scene we
set the ambientColor

244
00:11:05.816 --> 00:11:08.436
to really bring the scene
up a little bit more.

245
00:11:08.926 --> 00:11:12.336
So let's look at the additional
attributes for SKLightNode.

246
00:11:12.426 --> 00:11:13.576
The number one is falloff.

247
00:11:13.966 --> 00:11:18.916
Falloff controls the radius of
the light in terms of the effect

248
00:11:19.576 --> 00:11:21.786
and we also take what
works really well

249
00:11:21.786 --> 00:11:25.116
with our physics properties
with the category of BitMasks.

250
00:11:25.666 --> 00:11:28.476
So with SpriteNode now
you have individual,

251
00:11:28.476 --> 00:11:30.936
big control of whether the
sprite is participating

252
00:11:30.936 --> 00:11:33.176
in the lighting, whether
it's casting shadows

253
00:11:33.176 --> 00:11:34.876
or whether it's receiving
shadows.

254
00:11:35.116 --> 00:11:37.546
You have fine control
of exactly how you want

255
00:11:37.546 --> 00:11:40.376
to control these 3 attributes
for each individual sprite.

256
00:11:40.906 --> 00:11:44.316
And now since we are
talking about SpriteNode,

257
00:11:44.816 --> 00:11:48.236
SpriteNode also has a brand new
property called normalTexture,

258
00:11:48.236 --> 00:11:50.186
which you can assign
normalTexture with.

259
00:11:50.706 --> 00:11:54.306
So usually normalTexture
is heavily used in 3D games

260
00:11:54.746 --> 00:11:58.176
and normalTexture uses the
pixel RGB value to describe

261
00:11:58.176 --> 00:12:00.556
where the normal vector for the
surface is pointing towards,

262
00:11:58.176 --> 00:12:00.556
where the normal vector for the
surface is pointing towards,

263
00:12:00.826 --> 00:12:03.466
so the lighting calculation
can be used upon

264
00:12:03.466 --> 00:12:04.616
with the normal vectors.

265
00:12:05.166 --> 00:12:07.136
So here we're using
the exact same formula.

266
00:12:08.026 --> 00:12:09.876
So to render the scene

267
00:12:10.596 --> 00:12:15.216
with a normal map we use the
traditional A + B = C formula,

268
00:12:15.216 --> 00:12:17.266
which means you supply
the texture --

269
00:12:17.746 --> 00:12:21.726
you supply the normalTexture
-- SpriteKit will do its magic

270
00:12:21.726 --> 00:12:25.406
and give you the result,
which is lighting up the scene

271
00:12:25.406 --> 00:12:27.866
with the bumpy service
that's being mapped.

272
00:12:28.226 --> 00:12:31.026
So here you-- as you can see
I can just set normalTexture

273
00:12:31.026 --> 00:12:34.126
directly on the SKSpriteNode
by loading it

274
00:12:34.566 --> 00:12:36.466
from the normal .png file.

275
00:12:38.156 --> 00:12:40.326
So now being SpriteKit we

276
00:12:40.326 --> 00:12:43.886
like to make our user's
life as easy as possible.

277
00:12:43.886 --> 00:12:48.876
So in addition to the A + B =
C formula we get you directly

278
00:12:48.876 --> 00:12:49.926
from A to C.

279
00:12:50.196 --> 00:12:52.426
You do not need to
supply any NormalMap.

280
00:12:52.496 --> 00:12:55.706
So, what we do is we take
the source texture image

281
00:12:56.016 --> 00:13:00.286
and perform image analyzation
on every single pixel,

282
00:12:56.016 --> 00:13:00.286
and perform image analyzation
on every single pixel,

283
00:13:00.286 --> 00:13:01.886
and based on the
bightness of each pixel,

284
00:13:02.236 --> 00:13:04.026
we have a multi-path algorithm

285
00:13:04.026 --> 00:13:05.986
that generate the
best normal map

286
00:13:06.336 --> 00:13:08.196
that describes the
current picture.

287
00:13:08.426 --> 00:13:12.066
So if you give us a picture
that you take from the beach,

288
00:13:12.066 --> 00:13:13.446
which is a bunch of rocks,

289
00:13:13.446 --> 00:13:16.686
and their rounded
edges are really sharp

290
00:13:16.686 --> 00:13:18.716
yet the surface remains
very smooth...

291
00:13:19.246 --> 00:13:20.466
So here it's very easy.

292
00:13:20.466 --> 00:13:21.736
It's magic one liner.

293
00:13:21.736 --> 00:13:26.286
All we need to do is just
sprite.normalTexture = generate

294
00:13:26.736 --> 00:13:29.706
a NormalMap from the
existing sprite's texture.

295
00:13:29.706 --> 00:13:30.226
[ Applause ]

296
00:13:30.226 --> 00:13:31.646
That's not all.

297
00:13:32.426 --> 00:13:36.736
There is not a solution, or
a one-size-fits-all solution.

298
00:13:37.246 --> 00:13:40.806
So, in addition we provide two
more parameters for you guys

299
00:13:40.806 --> 00:13:44.216
to change the dynamic behavior
of the GeneratingNormalMap

300
00:13:44.556 --> 00:13:46.506
in terms of smoothness, in terms

301
00:13:46.506 --> 00:13:49.596
of contrast (which is how
bumpy you want the main surface

302
00:13:49.596 --> 00:13:50.146
to be).

303
00:13:50.936 --> 00:13:51.836
And this will give --

304
00:13:51.836 --> 00:13:54.326
in combination will give you
an infinite number of looks.

305
00:13:54.326 --> 00:13:59.356
For example, our cobblestone I
just have two for loops running

306
00:13:59.356 --> 00:14:01.636
on these parameters
with 1 second delay.

307
00:13:59.356 --> 00:14:01.636
on these parameters
with 1 second delay.

308
00:14:01.636 --> 00:14:03.976
As you can see it
actually changed the look.

309
00:14:03.976 --> 00:14:06.006
You can get an infinite
number of looks out of it.

310
00:14:06.306 --> 00:14:07.086
And the best part

311
00:14:07.086 --> 00:14:10.376
about automatic NormalMap
generation is you can do this

312
00:14:10.376 --> 00:14:11.596
on dynamic content.

313
00:14:11.956 --> 00:14:15.516
If the user takes a picture
from outside and decides to put

314
00:14:15.516 --> 00:14:16.706
that in the game, guess what?

315
00:14:16.746 --> 00:14:18.696
You can light it without
any normal texture.

316
00:14:18.956 --> 00:14:20.516
We can do all of this for you.

317
00:14:21.046 --> 00:14:24.896
So to summarize lighting
and shadows,

318
00:14:25.726 --> 00:14:27.286
they are very easy to use.

319
00:14:27.376 --> 00:14:30.126
SKLightNode is just
like any SKNode.

320
00:14:30.126 --> 00:14:31.266
You can run animation on it.

321
00:14:31.266 --> 00:14:32.116
You can parent it.

322
00:14:32.386 --> 00:14:34.796
You can set up colors and
everything is a one-liner.

323
00:14:35.376 --> 00:14:38.896
Automatic normal map generation
really provides this dynamic

324
00:14:38.896 --> 00:14:39.466
look for you.

325
00:14:39.586 --> 00:14:42.816
You don't have to spend time
sitting down with artists

326
00:14:42.816 --> 00:14:45.486
and trying to figure out how
to hand-paint a normal map.

327
00:14:45.796 --> 00:14:49.266
"Oh, it's purple facing outward
or green facing to the left."

328
00:14:49.646 --> 00:14:50.926
You don't have to
do any of that.

329
00:14:50.926 --> 00:14:53.176
We take out the nitty-gritty
detail for you.

330
00:14:53.586 --> 00:14:56.386
There's some best
practices in terms

331
00:14:56.386 --> 00:14:57.826
of performance I'd
like to point out.

332
00:14:58.116 --> 00:14:59.836
It's okay to have multiple
lights in the scene

333
00:14:59.836 --> 00:15:01.536
and it runs reasonably fast.

334
00:14:59.836 --> 00:15:01.536
and it runs reasonably fast.

335
00:15:01.776 --> 00:15:03.866
But if you have -- the number

336
00:15:03.866 --> 00:15:06.736
of lights that's lighting
the very same sprite

337
00:15:06.736 --> 00:15:07.556
actually matters.

338
00:15:07.836 --> 00:15:10.776
And if I have more than two
lights lighting the same sprite

339
00:15:11.156 --> 00:15:13.906
you might not be able
to stay on constant 60

340
00:15:13.906 --> 00:15:15.406
on certain iOS hardwares.

341
00:15:15.456 --> 00:15:16.776
It's just something
to point out.

342
00:15:17.226 --> 00:15:22.516
Next I'd like to point out
all the new physics features

343
00:15:22.516 --> 00:15:23.166
that we have.

344
00:15:23.286 --> 00:15:24.166
So let's look at them.

345
00:15:24.776 --> 00:15:29.526
Number 1, per-pixel physics
updates: we have constraints,

346
00:15:29.926 --> 00:15:32.996
allows to remove the boilerplate
code in your updates.

347
00:15:33.286 --> 00:15:34.986
We also have inverse kinematics:

348
00:15:34.986 --> 00:15:37.646
allow to you build
mechanical AI.

349
00:15:37.946 --> 00:15:41.216
We also have physics fields
that apply these forces,

350
00:15:41.216 --> 00:15:43.666
allow you to build the
next space game simulation.

351
00:15:44.576 --> 00:15:47.356
So let's look at the per-pixel
physics body creation.

352
00:15:48.426 --> 00:15:50.806
With the current
implementation on the left side,

353
00:15:51.276 --> 00:15:54.836
if I want to build a
gears game, I can't.

354
00:15:55.456 --> 00:15:58.486
The best thing I can do
is use bounding circles

355
00:15:58.586 --> 00:16:00.096
and create the bounding circles

356
00:15:58.586 --> 00:16:00.096
and create the bounding circles

357
00:16:00.096 --> 00:16:01.836
around these box,
uh, these gears.

358
00:16:01.836 --> 00:16:04.136
They don't actually
grind each other

359
00:16:04.136 --> 00:16:05.656
and the teeth don't interlock.

360
00:16:06.176 --> 00:16:08.006
Okay, maybe I can
fake it a little bit.

361
00:16:08.096 --> 00:16:10.146
I reduce the radius
of the physics bodies

362
00:16:10.146 --> 00:16:11.936
so that the teeth might overlap,

363
00:16:12.416 --> 00:16:15.096
but they still don't
touch exactly.

364
00:16:15.096 --> 00:16:19.176
And also, the angular
velocity don't transfer

365
00:16:19.176 --> 00:16:20.376
from one gear to another.

366
00:16:20.826 --> 00:16:24.316
But now with a single line of
code you can generate from --

367
00:16:24.586 --> 00:16:28.326
go from there to give
you a physics, uh,

368
00:16:28.496 --> 00:16:30.946
a pixel-based physics body.

369
00:16:31.286 --> 00:16:32.016
It's very easy.

370
00:16:32.016 --> 00:16:32.286
[ Applause ]

371
00:16:32.286 --> 00:16:34.116
So when we introspect
the source image,

372
00:16:34.466 --> 00:16:37.676
based on the alpha mask we
generate a rough shape and based

373
00:16:37.676 --> 00:16:41.126
on the shape we generate an
exact shape that's the minimal

374
00:16:41.266 --> 00:16:42.676
in order to fit the
current sprite.

375
00:16:43.336 --> 00:16:44.276
It's very accurate.

376
00:16:44.346 --> 00:16:45.956
And now, to build
the gears demo,

377
00:16:46.266 --> 00:16:49.166
you can just have a couple
one-liners, have the same code

378
00:16:49.166 --> 00:16:52.126
in there, just change from
using bounding circles

379
00:16:52.126 --> 00:16:55.576
to using image-based physics
body and you are good to go.

380
00:16:55.796 --> 00:16:57.786
And they can be pinned,
they can be transferring

381
00:16:57.786 --> 00:17:00.016
and interlocking;
it's really fun.

382
00:16:57.786 --> 00:17:00.016
and interlocking;
it's really fun.

383
00:17:01.116 --> 00:17:02.506
So, let's look at how we do it.

384
00:17:03.066 --> 00:17:06.506
So, with the current API
to create a physics body

385
00:17:06.506 --> 00:17:09.506
with a bounding box
we use physicsBody

386
00:17:10.296 --> 00:17:14.616
and bodyWithRectangleOfSize will
give you an exact bounding box

387
00:17:14.616 --> 00:17:16.316
of the dimensions that
you have specified.

388
00:17:17.026 --> 00:17:20.616
Now, with a new API it's
the same initializer.

389
00:17:20.616 --> 00:17:21.336
Convenient.

390
00:17:21.336 --> 00:17:23.136
Instead you're just
passing the texture

391
00:17:23.376 --> 00:17:24.556
and the size of the texture.

392
00:17:24.856 --> 00:17:28.136
For example, a hammer here will
give you the exact hammer body

393
00:17:28.136 --> 00:17:29.266
that's traced with the outline.

394
00:17:29.266 --> 00:17:32.416
You no longer have to
do that yourself or try

395
00:17:32.416 --> 00:17:35.186
to build any approximation
of the physics bodies.

396
00:17:37.196 --> 00:17:38.206
Just like the automatic

397
00:17:38.206 --> 00:17:41.066
and NormalMap generation there's
not a one solution fits all.

398
00:17:41.256 --> 00:17:44.246
If you have a source
art that has a lot

399
00:17:44.246 --> 00:17:46.756
of semi-transparent
pixels we do allow you

400
00:17:46.756 --> 00:17:50.596
to specify the alpha
threshold, which defines

401
00:17:50.866 --> 00:17:53.606
which pixels are being
interpolated during the process

402
00:17:53.606 --> 00:17:55.246
as opaque or not.

403
00:17:56.116 --> 00:18:02.346
So in summary, per-pixel physics
body is very easy to create.

404
00:17:56.116 --> 00:18:02.346
So in summary, per-pixel physics
body is very easy to create.

405
00:18:02.516 --> 00:18:03.856
They're very accurate.

406
00:18:05.236 --> 00:18:08.886
And whether you are existing
SpriteKit users or new

407
00:18:08.886 --> 00:18:13.876
to the APIs it's just a matter
of setting one line change

408
00:18:13.876 --> 00:18:17.166
in your codes to create really
accurate physics simulations.

409
00:18:18.306 --> 00:18:20.376
So again I'd like to point
out the performance tips.

410
00:18:20.986 --> 00:18:24.476
SpriteKit does a really good
job of optimizing this algorithm

411
00:18:24.526 --> 00:18:27.446
and we provide a good
balance between performance

412
00:18:27.446 --> 00:18:30.386
and accuracy, but the
texture size matters.

413
00:18:30.936 --> 00:18:35.266
So if you are passing in a
2K by 2K texture and scale it

414
00:18:35.266 --> 00:18:38.566
down to 10 percent
by rendering a 20 by,

415
00:18:38.566 --> 00:18:42.826
200 by 200 sprite we do have
to work down the whole 2K

416
00:18:42.946 --> 00:18:46.396
by 2K pixels in order to
figure out the exact shape,

417
00:18:46.916 --> 00:18:48.986
so just something
to think about.

418
00:18:49.746 --> 00:18:54.776
Next: a brand new
API, the constraints

419
00:18:54.776 --> 00:18:58.436
to help you really simplify
the game update logic.

420
00:18:59.526 --> 00:19:02.576
The constraints, the motivation
of creating constraint for us is

421
00:18:59.526 --> 00:19:02.576
The constraints, the motivation
of creating constraint for us is

422
00:19:02.576 --> 00:19:05.976
to really remove the boilerplate
code in your updates.

423
00:19:05.976 --> 00:19:08.846
So, a lot of times if I
want to move a character

424
00:19:09.066 --> 00:19:10.406
but I want a health indicator

425
00:19:10.406 --> 00:19:13.736
to follow the character
that's exactly 5 pixels above,

426
00:19:13.736 --> 00:19:14.856
2 pixels behind...

427
00:19:15.576 --> 00:19:17.466
I need to put that in
the update somewhere.

428
00:19:17.466 --> 00:19:20.146
I need to have a cannon; you
want to orient the cannon

429
00:19:20.146 --> 00:19:21.446
to follow the airplane.

430
00:19:21.946 --> 00:19:25.076
Guess what, I need to add that
code in to calculate the angle

431
00:19:25.076 --> 00:19:26.596
and figure out the delta,

432
00:19:26.596 --> 00:19:29.136
translate the delta rotation
inside the translation.

433
00:19:29.336 --> 00:19:31.396
Or if the airplane wants
to land on the runway,

434
00:19:31.396 --> 00:19:32.756
I need to orient that first.

435
00:19:33.456 --> 00:19:35.956
We do all of that work
for you; we can do it

436
00:19:35.956 --> 00:19:36.906
with simple constraints.

437
00:19:39.516 --> 00:19:43.146
So now we add, because of the
constraint that's being added,

438
00:19:43.956 --> 00:19:47.456
we need to add some new
features in our update loop.

439
00:19:47.846 --> 00:19:51.016
So in the update loop, we
expand it to some new selectors.

440
00:19:51.576 --> 00:19:55.386
Number 1, right after physics
simulation now the scene starts

441
00:19:55.386 --> 00:19:56.606
kicking in the constraint.

442
00:19:56.976 --> 00:19:59.636
So constraints are not
limited to physics anymore,

443
00:19:59.636 --> 00:20:01.386
so you don't have
to worry about "Oh,

444
00:19:59.636 --> 00:20:01.386
so you don't have
to worry about "Oh,

445
00:20:01.386 --> 00:20:02.976
is the character standing
on a conveyor belt?

446
00:20:03.106 --> 00:20:05.156
Is it going to be pushed

447
00:20:05.156 --> 00:20:07.526
over because the box
is right beside it?"

448
00:20:07.696 --> 00:20:09.116
Constraints will take
care of that for you.

449
00:20:09.646 --> 00:20:11.436
And right after constraint
update,

450
00:20:11.436 --> 00:20:15.066
users have another chance
of doing another update.

451
00:20:15.066 --> 00:20:18.196
We do give the user a
callback on didApplyConstraints

452
00:20:18.436 --> 00:20:21.896
so here you have a chance to do
any other last minute cleanup.

453
00:20:23.826 --> 00:20:25.766
And the basis of constraints,

454
00:20:25.906 --> 00:20:28.906
again we'll have a new object
called SKConstraint object.

455
00:20:29.036 --> 00:20:31.776
It is used to wrap around
this mathematical constraint

456
00:20:31.776 --> 00:20:33.946
on the properties of the node
that you want to animate.

457
00:20:34.696 --> 00:20:37.216
So the constraints
are then attached

458
00:20:37.216 --> 00:20:39.696
to nodes via the new
constraints array.

459
00:20:40.406 --> 00:20:42.216
And the scene will
apply the constraints

460
00:20:42.296 --> 00:20:43.676
to the attached node.

461
00:20:43.906 --> 00:20:47.006
So what kind of constraints
can it set on a node?

462
00:20:47.416 --> 00:20:51.076
You can set the constraints
on position, orientation

463
00:20:51.446 --> 00:20:53.896
and distance and you
can quickly enable

464
00:20:53.896 --> 00:20:55.426
and disable between frames.

465
00:20:56.866 --> 00:20:58.706
So for example, let's
look at a quick example

466
00:20:58.706 --> 00:21:02.246
of how the orientToNode
constraint works.

467
00:20:58.706 --> 00:21:02.246
of how the orientToNode
constraint works.

468
00:21:02.616 --> 00:21:04.166
So we just call SKConstraint

469
00:21:04.266 --> 00:21:07.856
with orientToNode
initializer and follow a node.

470
00:21:07.856 --> 00:21:10.976
So here the arrow's just
following the circle

471
00:21:10.976 --> 00:21:12.976
and then we're just
passing the circle.

472
00:21:13.146 --> 00:21:16.616
[inaudible] the SKNode and
the range of offset is 0

473
00:21:16.616 --> 00:21:19.376
and you can set, I want to
lead the circle following in

474
00:21:19.376 --> 00:21:22.196
or lagging it, you
have that possibility.

475
00:21:22.836 --> 00:21:26.526
So once the constraint is
created I just directly set

476
00:21:27.056 --> 00:21:29.186
on the arrow's constraints
property.

477
00:21:30.616 --> 00:21:33.636
Next, how do we set
position of constraint?

478
00:21:34.056 --> 00:21:37.886
So here we create a positional
range of minus 100 to 100.

479
00:21:38.646 --> 00:21:43.056
We can first set the limit
of constraint on the X axis.

480
00:21:43.056 --> 00:21:46.086
This will limit the movement
in the X direction of the node.

481
00:21:47.506 --> 00:21:49.626
Now we can also set
it on the Y direction,

482
00:21:49.626 --> 00:21:51.696
that will give a
limitation on the Y axis.

483
00:21:53.056 --> 00:21:56.896
And if you combine these two
together you are limiting the

484
00:21:56.896 --> 00:22:00.806
movement of the current
node to a 200 by 200 box;

485
00:21:56.896 --> 00:22:00.806
movement of the current
node to a 200 by 200 box;

486
00:22:01.166 --> 00:22:02.526
very, very simple to use.

487
00:22:02.816 --> 00:22:05.056
You no longer have to
write all this update code

488
00:22:05.436 --> 00:22:09.156
that will manually snap
the object back in the box.

489
00:22:09.786 --> 00:22:13.056
So in summary, it really
helps you remove a lot

490
00:22:13.056 --> 00:22:14.166
of the boilerplate code,

491
00:22:14.426 --> 00:22:16.386
making sure you just write
the code that's focused

492
00:22:16.436 --> 00:22:17.926
on building the game
you want rather

493
00:22:17.926 --> 00:22:19.706
than having to fix up things.

494
00:22:20.546 --> 00:22:23.876
And also the -- because the
constraints is the array

495
00:22:24.496 --> 00:22:30.196
that you can add the multiple
constraints into the same array

496
00:22:30.196 --> 00:22:32.466
and the order of
evaluation happens from --

497
00:22:33.116 --> 00:22:35.256
is based on the order of the
insertion into the array.

498
00:22:35.966 --> 00:22:38.646
And we also offer a lot
of varieties of constraint

499
00:22:38.646 --> 00:22:41.256
into position orientation
and distance.

500
00:22:41.726 --> 00:22:47.096
Next, I'd like to talk
about inverse kinematics.

501
00:22:47.786 --> 00:22:50.216
This is usually a very
strange word for people

502
00:22:50.756 --> 00:22:54.066
who doesn't have a mechanical
engineering degree or people

503
00:22:54.066 --> 00:22:56.706
who haven't written
an animation engine.

504
00:22:57.116 --> 00:23:01.566
So inverse kinematics allow
you to use kinematics equations

505
00:22:57.116 --> 00:23:01.566
So inverse kinematics allow
you to use kinematics equations

506
00:23:01.566 --> 00:23:04.326
to solve the joint parameters

507
00:23:04.486 --> 00:23:06.526
if you have a joint
hierarchy trying to reach

508
00:23:06.526 --> 00:23:08.696
for things in a 2D space.

509
00:23:09.136 --> 00:23:12.226
So here I'm trying to use
the robot arm reaching

510
00:23:12.226 --> 00:23:15.346
for where my mouse cursor is
pointing and I want to set

511
00:23:15.346 --> 00:23:18.226
up the exact behavior of
how the robot will move.

512
00:23:18.576 --> 00:23:21.176
I imagine to do that you
will update yourself and try

513
00:23:21.176 --> 00:23:22.146
to do this every frame.

514
00:23:22.146 --> 00:23:24.016
Okay, it's easy to
move the hand and now,

515
00:23:24.016 --> 00:23:26.026
what does the lower
hand is going to do?

516
00:23:26.026 --> 00:23:28.336
Followed by what the upper
hand is going to do to provide

517
00:23:28.336 --> 00:23:29.626
that realistic behavior.

518
00:23:29.886 --> 00:23:32.706
So you can do this for arms
and you can do this for legs.

519
00:23:33.076 --> 00:23:34.916
You can do it with
blend with animation.

520
00:23:36.006 --> 00:23:39.306
So number 1 of using inverse
kinematics is you need

521
00:23:39.306 --> 00:23:40.436
to have a joint hierarchy.

522
00:23:40.546 --> 00:23:41.386
So for example, if you look

523
00:23:41.386 --> 00:23:44.196
at the robot arm it's a
joint of three pieces.

524
00:23:44.496 --> 00:23:50.236
We start with the upper arm
(that's the root node) followed

525
00:23:50.236 --> 00:23:53.066
by the lower arm (which
is attached as a child

526
00:23:53.706 --> 00:23:57.136
to the upper arm) and then we'll
have the claw (which is attached

527
00:23:57.136 --> 00:23:59.216
as a child to the lower arm).

528
00:24:00.766 --> 00:24:02.236
So now each of these joints --

529
00:24:02.386 --> 00:24:06.216
to create a realistic look I
need to set up some constraint.

530
00:24:06.436 --> 00:24:10.666
For example, my arm, my elbow
probably opens at 180 degrees

531
00:24:10.706 --> 00:24:13.166
and closes at 30
and anything beyond

532
00:24:13.166 --> 00:24:14.506
that range is going to snap.

533
00:24:14.506 --> 00:24:16.616
I can't take it anymore.

534
00:24:17.176 --> 00:24:19.036
So you can set up
that constraint

535
00:24:19.036 --> 00:24:20.706
for each individual
node to create

536
00:24:20.706 --> 00:24:22.376
that really realistic behavior.

537
00:24:24.536 --> 00:24:26.976
So with SpriteKit how do
you do inverse kinematics?

538
00:24:27.466 --> 00:24:29.166
How do I set up the constraint?

539
00:24:29.166 --> 00:24:31.196
How do I set up the
parent-child hierarchy?

540
00:24:32.426 --> 00:24:33.516
You don't have to do that,

541
00:24:33.796 --> 00:24:35.746
because we use the
existing scene graph

542
00:24:35.746 --> 00:24:37.836
that already have the
parent-child relationship

543
00:24:38.176 --> 00:24:39.186
and we are good to go.

544
00:24:39.186 --> 00:24:42.476
The only thing you need to set
up is setting up the constraints

545
00:24:42.476 --> 00:24:44.806
on how each joints
open and close

546
00:24:44.916 --> 00:24:46.846
to create the realistic
look that you want

547
00:24:47.156 --> 00:24:48.586
and would provide actions

548
00:24:48.636 --> 00:24:50.606
to drive these constraints
of the chain.

549
00:24:51.496 --> 00:24:53.696
So the joint rotates
around its anchor point.

550
00:24:53.936 --> 00:24:56.446
So by default the anchor
point is at 0.5 and 0.5

551
00:24:56.446 --> 00:24:58.606
and that's not really
realistic for my shoulder.

552
00:24:58.766 --> 00:25:02.976
Probably set it to
0.5 - or, 0 and 0.5.

553
00:24:58.766 --> 00:25:02.976
Probably set it to
0.5 - or, 0 and 0.5.

554
00:25:04.556 --> 00:25:07.616
So the constraint that we set is
called SKReachConstraint object.

555
00:25:07.796 --> 00:25:09.176
It simply have to
two properties;

556
00:25:09.176 --> 00:25:11.476
the lower angle limit
and upper angle limit.

557
00:25:11.926 --> 00:25:15.966
Once you have these angles
specified you can attach

558
00:25:16.226 --> 00:25:18.646
that to any of the SKNode
that's in the scene.

559
00:25:19.266 --> 00:25:21.896
And now you have a perfectly
working joint hierarchy.

560
00:25:22.376 --> 00:25:24.116
How do I drive it?

561
00:25:24.766 --> 00:25:27.256
To drive it, we provide
SKActions.

562
00:25:27.426 --> 00:25:30.926
We have two variants,
reachToNode and reachToPosition.

563
00:25:31.326 --> 00:25:33.786
So, if you want to
reach to a moving target

564
00:25:33.786 --> 00:25:35.486
or any stationary position

565
00:25:35.486 --> 00:25:37.196
within the scene
you can use either

566
00:25:37.246 --> 00:25:39.806
of the variants that's
being specified.

567
00:25:40.226 --> 00:25:44.306
So, here I have a quick
example of one-liner writing,

568
00:25:44.486 --> 00:25:47.506
running the SKAction of
reaching a constraint.

569
00:25:47.506 --> 00:25:51.856
So here we have a simple
4 -- 3 joint constraint.

570
00:25:51.856 --> 00:25:52.746
I use constraint.

571
00:25:52.846 --> 00:25:55.116
Each joint will have a
constraint of opening

572
00:25:55.116 --> 00:25:56.676
from 0 to 180 degrees.

573
00:25:57.036 --> 00:25:59.776
As you can see when the mouse
moves it actually obeys the

574
00:25:59.776 --> 00:26:02.346
constraint and tries
not to overbend and,

575
00:25:59.776 --> 00:26:02.346
constraint and tries
not to overbend and,

576
00:26:02.386 --> 00:26:04.446
but it really give you
that realistic look

577
00:26:04.766 --> 00:26:06.946
of mechanical bell
mechanical AI.

578
00:26:07.496 --> 00:26:14.406
And now we also take the same
inverse kinematics solver to 3D.

579
00:26:14.656 --> 00:26:16.376
It's much, much more interesting

580
00:26:16.376 --> 00:26:18.856
but it's also very
closely implemented just

581
00:26:18.856 --> 00:26:20.856
like this SpriteKit API.

582
00:26:20.986 --> 00:26:21.786
So you have SK --

583
00:26:21.936 --> 00:26:26.606
SCNIKConstraint and each node
has a SKConstraints array

584
00:26:26.606 --> 00:26:27.876
that you set these
constraints on.

585
00:26:28.136 --> 00:26:30.376
Also you have animation
influenceFactor.

586
00:26:30.546 --> 00:26:32.716
So here, I'll just
give you a quick demo.

587
00:26:33.186 --> 00:26:37.396
You have a 3D scene with a
3D character playing a punch

588
00:26:37.396 --> 00:26:39.696
animation, nothing,
nothing else is running.

589
00:26:40.836 --> 00:26:46.816
But now with IK running
I can blend it on top

590
00:26:46.816 --> 00:26:50.066
of the animation playback
at 60 frames per second,

591
00:26:50.426 --> 00:26:53.416
making sure the hand is always
punching at a red target.

592
00:26:53.846 --> 00:26:57.036
So now imagine the possibility
of I'm building a tennis game.

593
00:26:57.356 --> 00:26:59.606
All I now need is
two animations.

594
00:26:59.606 --> 00:27:01.886
One is the back paddle
and forward paddle,

595
00:26:59.606 --> 00:27:01.886
One is the back paddle
and forward paddle,

596
00:27:02.196 --> 00:27:05.746
everything else I will let IK
take care of it so I don't have

597
00:27:05.746 --> 00:27:08.286
to build an infinite number
of animation combinations

598
00:27:08.316 --> 00:27:10.776
for the game to also
have the realistic look.

599
00:27:11.666 --> 00:27:14.836
So this really opened up
a lot of opportunities.

600
00:27:15.276 --> 00:27:18.186
So, in summary, inverse
kinematics is really easy

601
00:27:18.186 --> 00:27:18.596
to use.

602
00:27:18.596 --> 00:27:19.936
You don't even need
to set it up.

603
00:27:19.936 --> 00:27:21.876
The scene graph will
take care of it.

604
00:27:21.876 --> 00:27:24.236
And the constraints can be set

605
00:27:24.236 --> 00:27:25.786
on every single joint
that you have.

606
00:27:25.786 --> 00:27:27.866
You can control the
opening and closing angle

607
00:27:28.276 --> 00:27:31.336
and to drive these chains
you just run a single action

608
00:27:31.336 --> 00:27:34.096
one-liner and tell
the joint to reach

609
00:27:34.096 --> 00:27:35.456
out for a position or a node.

610
00:27:35.876 --> 00:27:40.236
Next, I want to talk
about physics fields.

611
00:27:41.886 --> 00:27:45.546
Now physics fields are
a type of field forces

612
00:27:45.856 --> 00:27:48.066
that apply the generated forces

613
00:27:48.406 --> 00:27:50.696
to the object that's
being part of the scene.

614
00:27:51.176 --> 00:27:54.696
So here, I'm having a space
cannon launching off cannonballs

615
00:27:55.286 --> 00:27:59.506
that interact with 2 different
radial gravity fields.

616
00:28:00.296 --> 00:28:04.016
As you can see, as the
cannonballs get closer

617
00:28:05.456 --> 00:28:09.386
to the planet the linear
acceleration gets converted

618
00:28:09.386 --> 00:28:12.776
into angular velocity and
start orbiting the planet

619
00:28:12.776 --> 00:28:13.416
or shoots out.

620
00:28:15.456 --> 00:28:16.806
So, we use the fields

621
00:28:16.806 --> 00:28:21.946
to simulate any physical field
forces and fields can interact

622
00:28:21.946 --> 00:28:23.716
with the physics bodies
that's in the region.

623
00:28:23.896 --> 00:28:25.516
And the region is the place

624
00:28:25.516 --> 00:28:27.856
where we define the
field effect areas.

625
00:28:28.516 --> 00:28:31.126
And we have a lot of different
fields that's provided

626
00:28:31.126 --> 00:28:32.096
with this release.

627
00:28:32.596 --> 00:28:33.596
There's about 10 of them.

628
00:28:34.956 --> 00:28:37.206
So, when those fields
get updated...

629
00:28:37.516 --> 00:28:40.466
So number 1, I need to have
field nodes in the scene graph.

630
00:28:40.566 --> 00:28:42.136
They are just like any SKNode.

631
00:28:42.136 --> 00:28:43.396
You can add them to a scene.

632
00:28:43.806 --> 00:28:45.626
You can run action
on them as well.

633
00:28:45.976 --> 00:28:48.396
You can parent it to
another sprite so if you want

634
00:28:48.396 --> 00:28:53.696
to have a really big cookie
planet you can add a radial

635
00:28:53.696 --> 00:28:56.456
gravity field as a child and
move that cookie planet around

636
00:28:56.456 --> 00:28:58.746
and then the field is
going to follow it.

637
00:28:58.746 --> 00:29:01.336
And if there are physics
bodies that's located

638
00:28:58.746 --> 00:29:01.336
And if there are physics
bodies that's located

639
00:29:01.336 --> 00:29:05.056
within this region and the
bitMask matches the interaction

640
00:29:05.056 --> 00:29:05.766
will start happening.

641
00:29:05.926 --> 00:29:10.286
Now, the control fields, fields
will provide a lot of parameters

642
00:29:10.286 --> 00:29:12.556
that will allow you
to get the exact look

643
00:29:12.556 --> 00:29:14.676
and different interactions
that you want.

644
00:29:15.066 --> 00:29:16.636
You can control number
1, region.

645
00:29:16.916 --> 00:29:22.106
That's the area of effect of how
big of the area I want the field

646
00:29:22.106 --> 00:29:23.556
to interact with the user with.

647
00:29:24.376 --> 00:29:27.556
Now, the strength in combination

648
00:29:27.556 --> 00:29:30.246
of falloff controls
what's the magnitude

649
00:29:30.246 --> 00:29:31.796
of force that's being applied

650
00:29:31.796 --> 00:29:33.866
to each individual object
that's in the field.

651
00:29:34.536 --> 00:29:36.966
And minimal radius is
just a clamp radius

652
00:29:37.516 --> 00:29:40.636
and bitMask can be
used to differentiate

653
00:29:40.636 --> 00:29:43.996
which physics body you want to
interact with this field or not.

654
00:29:45.266 --> 00:29:47.016
Now, let's look at the regions.

655
00:29:47.566 --> 00:29:49.866
The SKRegions define
the area of effect

656
00:29:49.866 --> 00:29:51.216
for this particular field.

657
00:29:51.626 --> 00:29:54.926
The region defines
this area in 2D space.

658
00:29:55.276 --> 00:29:58.616
By default it is infinite and
you can create a rectangle,

659
00:29:58.616 --> 00:30:00.986
circle or even create
a region from CGPath.

660
00:29:58.616 --> 00:30:00.986
circle or even create
a region from CGPath.

661
00:30:01.396 --> 00:30:05.306
You can do a lot of complicated
operations on them like invert,

662
00:30:05.306 --> 00:30:06.976
subtract, union and intersect.

663
00:30:07.686 --> 00:30:10.476
So for example, here, I'm
if building Earth here

664
00:30:10.476 --> 00:30:13.646
and the radial gravity around
the Earth, as you can see,

665
00:30:13.646 --> 00:30:15.496
is pulling everything
towards the center.

666
00:30:15.676 --> 00:30:21.436
So, in addition to physics
bodies fields can also interact

667
00:30:21.436 --> 00:30:23.596
with SpriteKit particle effects.

668
00:30:24.226 --> 00:30:26.446
So, as long as you
set the fieldBitMask

669
00:30:26.446 --> 00:30:29.266
on the particle effects,
every single emitted object --

670
00:30:30.056 --> 00:30:31.506
particles can interact
with the field.

671
00:30:31.506 --> 00:30:32.966
So, here we have a noise field

672
00:30:32.966 --> 00:30:35.386
that apply a coherent
noise force to each

673
00:30:35.386 --> 00:30:36.486
of the emitted particles.

674
00:30:36.486 --> 00:30:39.776
Now, let's look at some

675
00:30:39.776 --> 00:30:41.876
of the basic fields
that's being provided

676
00:30:41.876 --> 00:30:44.436
so everyone can get a feeling

677
00:30:44.436 --> 00:30:47.586
of what fields are
really looking like.

678
00:30:48.286 --> 00:30:50.936
So, by default we provide the
base, linear gravity field.

679
00:30:50.936 --> 00:30:53.776
This is just to simulate
Earth's gravity in one dimension

680
00:30:53.776 --> 00:30:56.566
and you can change the direction
at any time or if you go

681
00:30:56.566 --> 00:31:00.186
up it will attract the object
at the correct location.

682
00:30:56.566 --> 00:31:00.186
up it will attract the object
at the correct location.

683
00:31:01.296 --> 00:31:03.876
And second, if I want to
simulate a space game,

684
00:31:03.876 --> 00:31:06.156
have a planetarium
gravity effect,

685
00:31:06.356 --> 00:31:10.196
we have the radial gravity
field node that you can use.

686
00:31:10.196 --> 00:31:13.196
For example, here the object
carries a linear velocity,

687
00:31:13.196 --> 00:31:14.516
but when it reaches close

688
00:31:14.516 --> 00:31:17.316
to the orbit the linear
gravity's converting

689
00:31:17.316 --> 00:31:18.806
into angular velocity

690
00:31:18.806 --> 00:31:23.676
so the object actually
orients around the planet.

691
00:31:24.176 --> 00:31:25.786
We also have a spring field.

692
00:31:25.976 --> 00:31:27.456
This is the imaginary field

693
00:31:27.456 --> 00:31:30.136
as it's imagining every
single object in the scene --

694
00:31:30.356 --> 00:31:33.276
in the field -- actually have
a spring hooked from one end

695
00:31:33.276 --> 00:31:34.396
and attached to the node.

696
00:31:34.776 --> 00:31:37.446
So, here you can see they're
being oscillated back and forth.

697
00:31:40.006 --> 00:31:41.586
And we also have noise fields

698
00:31:41.796 --> 00:31:44.836
that apply a coherent
noise force

699
00:31:45.446 --> 00:31:47.976
to every single object that's
being participated in the scene.

700
00:31:53.236 --> 00:31:55.886
And electric fields
are particularly cool.

701
00:31:56.046 --> 00:31:59.736
So, imagine each of the objects
have charges, positive charges

702
00:31:59.736 --> 00:32:04.266
and negative charges and here
we have an electric field

703
00:31:59.736 --> 00:32:04.266
and negative charges and here
we have an electric field

704
00:32:04.266 --> 00:32:06.146
that carries positive charges.

705
00:32:06.316 --> 00:32:10.676
And positive charge attracts
objects with negative charges

706
00:32:10.676 --> 00:32:14.136
and repel objects
with the same charge.

707
00:32:14.246 --> 00:32:18.726
So, here the red particles, or
red cannons actually, that...

708
00:32:18.726 --> 00:32:21.506
when they carry a positive
charge they get repelled away.

709
00:32:21.726 --> 00:32:23.856
And the green ones
carry a negative charge

710
00:32:24.086 --> 00:32:25.956
and are being attracted
and interact

711
00:32:25.956 --> 00:32:27.766
with the electric field.

712
00:32:28.516 --> 00:32:31.356
So, fields we provide
-- physics fields

713
00:32:31.356 --> 00:32:33.256
as building blocks
as like Legos.

714
00:32:33.256 --> 00:32:36.446
Feel free to interact
with them and build,

715
00:32:36.896 --> 00:32:37.836
combine them together.

716
00:32:38.106 --> 00:32:40.576
So, you can combine
them together

717
00:32:40.576 --> 00:32:43.816
to have big building blocks and
each of the fields can interact

718
00:32:43.816 --> 00:32:44.766
with different fields.

719
00:32:45.256 --> 00:32:49.166
So for example, if I want
to implement one variation

720
00:32:49.166 --> 00:32:54.426
of the Lorenz attractor I can
simply have 4 magnetic fields

721
00:32:54.426 --> 00:32:57.086
sitting right by each
other with opposite charge.

722
00:32:57.476 --> 00:33:02.156
And, what happens if I send
particles through the field?

723
00:32:57.476 --> 00:33:02.156
And, what happens if I send
particles through the field?

724
00:33:02.726 --> 00:33:09.136
So, that's what it looks like
so -- which is very cool.

725
00:33:09.136 --> 00:33:10.116
[ Applause ]

726
00:33:10.116 --> 00:33:12.896
So, in summary the
fields are very fast,

727
00:33:13.186 --> 00:33:14.346
they're very efficient.

728
00:33:14.636 --> 00:33:16.506
We have a brand new
implementation for --

729
00:33:16.936 --> 00:33:18.916
and we actually have a lot of --

730
00:33:18.916 --> 00:33:21.346
spent a lot of optimization
effort on this feature.

731
00:33:21.906 --> 00:33:23.426
And you can use fields
to interact

732
00:33:23.426 --> 00:33:26.066
with either physics
bodies or particles to have

733
00:33:26.066 --> 00:33:29.346
that really fun interaction
experience for the user.

734
00:33:29.866 --> 00:33:32.956
And you can also use fields
to interact with other fields

735
00:33:32.956 --> 00:33:34.556
to have a combined effect.

736
00:33:35.486 --> 00:33:37.786
Next, I want to talk about
integration with SceneKit.

737
00:33:38.506 --> 00:33:41.066
We worked really closely
together with the SceneKit team

738
00:33:41.066 --> 00:33:43.186
to make sure we have the
best possible experience

739
00:33:43.476 --> 00:33:45.796
for bringing 3D content
into 2D games.

740
00:33:46.456 --> 00:33:47.566
So, here we have a demo.

741
00:33:47.566 --> 00:33:51.616
The spaceship is in 3D,
object that's in a 2D and same

742
00:33:51.966 --> 00:33:56.696
as the asteroid that's in
the 3D object but we'll bring

743
00:33:56.836 --> 00:34:00.556
into the 2D background.

744
00:33:56.836 --> 00:34:00.556
into the 2D background.

745
00:34:01.046 --> 00:34:03.846
So, the integration
brings new possibilities

746
00:34:03.846 --> 00:34:08.676
to developing 2D games so we
can now officially include 3D

747
00:34:08.676 --> 00:34:10.156
content into SpriteKit games.

748
00:34:10.596 --> 00:34:13.116
You can control any
of the 3D objects just

749
00:34:13.116 --> 00:34:14.746
like any other SKNode.

750
00:34:14.746 --> 00:34:15.866
You can run action on it.

751
00:34:15.866 --> 00:34:16.775
You can run scale.

752
00:34:17.056 --> 00:34:20.596
You can make it follow paths or
even make any 3D manipulations.

753
00:34:22.735 --> 00:34:25.666
It's deeply integrated
of the two frameworks,

754
00:34:25.666 --> 00:34:27.196
yet it would remain
loosely coupled

755
00:34:27.196 --> 00:34:30.956
as two independent solutions
for the game developers.

756
00:34:31.266 --> 00:34:33.496
So, it is rendered very
efficiently together,

757
00:34:33.496 --> 00:34:36.196
SceneKit is rendering directly
into the OpenGL content.

758
00:34:36.196 --> 00:34:38.386
We're not passing -- we're
not rendering to texture

759
00:34:38.386 --> 00:34:40.366
and then passing texture around
between the two frameworks.

760
00:34:40.746 --> 00:34:43.045
This is a very efficient
solution.

761
00:34:43.926 --> 00:34:45.585
So, to bring 3D content

762
00:34:45.585 --> 00:34:49.226
into 2D-based games
we created SK3DNode.

763
00:34:49.516 --> 00:34:51.235
It is the toll-free
bridge allowing you

764
00:34:51.235 --> 00:34:54.096
to incorporate any 3D content
into SpriteKit-based games.

765
00:34:55.036 --> 00:34:59.536
So, once you have SK3DNode you
can attach any of the scnScenes

766
00:34:59.696 --> 00:35:03.876
to this SK3DNode in order for
it to render in this SKScene.

767
00:34:59.696 --> 00:35:03.876
to this SK3DNode in order for
it to render in this SKScene.

768
00:35:04.656 --> 00:35:07.626
And once you have the scnScene
you can set the scnScene

769
00:35:07.626 --> 00:35:11.246
property on an SK3DNode and they
will start using this SceneKit

770
00:35:11.246 --> 00:35:15.026
render in our render path.

771
00:35:15.506 --> 00:35:17.366
So, how do we create
an SK3DNode?

772
00:35:17.476 --> 00:35:19.976
And we have the initializer
create a scnNodeWith

773
00:35:19.976 --> 00:35:22.566
ViewportSize, you
specify a static size.

774
00:35:23.016 --> 00:35:25.676
You can attach any of the
scnScene, SceneKit scenes

775
00:35:25.676 --> 00:35:28.326
or SceneKit objects through
the scnScene property.

776
00:35:30.076 --> 00:35:33.576
You also have access to SCNNode,
which gives you the point

777
00:35:33.576 --> 00:35:35.046
of view of where the
default camera --

778
00:35:35.366 --> 00:35:37.836
or if there is a camera,
where is the pointer --

779
00:35:37.836 --> 00:35:39.936
where is the camera looking
at, at the current scene.

780
00:35:40.576 --> 00:35:42.656
And if the scene doesn't
have any lighting you can use

781
00:35:42.656 --> 00:35:44.056
one-liner automatic --

782
00:35:44.286 --> 00:35:46.966
autoenable DefaultLighting
that will turn on--

783
00:35:46.966 --> 00:35:48.256
add a default light to the scene

784
00:35:48.256 --> 00:35:50.026
so all the objects
are properly lit.

785
00:35:51.676 --> 00:35:54.466
So, here is a quick example,
if we want to add a 3D alien

786
00:35:54.466 --> 00:35:55.146
from a [inaudible] into SKScene,

787
00:35:55.146 --> 00:35:57.346
which is called SK3DNode
initialize

788
00:35:57.346 --> 00:35:58.276
with a default viewport.

789
00:35:58.516 --> 00:36:02.526
Load scnScene and set the scene
and add it to the SKScene.

790
00:35:58.516 --> 00:36:02.526
Load scnScene and set the scene
and add it to the SKScene.

791
00:36:02.526 --> 00:36:05.506
Now, the 3D alien object
is going to appear.

792
00:36:05.696 --> 00:36:09.346
Now, the integration
also goes both ways.

793
00:36:09.636 --> 00:36:13.026
SpriteKit now powers all the
texture needs for SceneKit

794
00:36:13.026 --> 00:36:16.256
as well as sounds so you can
use any SpriteKit texture object

795
00:36:16.326 --> 00:36:18.816
directly on SceneKit,
that including all

796
00:36:18.816 --> 00:36:20.826
of the tools we built
from the last version,

797
00:36:21.136 --> 00:36:23.676
which is the automatic
TextureAtlas generation

798
00:36:23.676 --> 00:36:25.326
within Xcode as well

799
00:36:25.326 --> 00:36:27.636
as the procedurally
generated normal map.

800
00:36:27.636 --> 00:36:30.386
So, you can automatically
generate a normal map,

801
00:36:30.746 --> 00:36:33.506
put it on any 3D object and
the effect looks really,

802
00:36:33.506 --> 00:36:33.976
really cool.

803
00:36:35.036 --> 00:36:37.376
And SpriteKit and SceneKit
also share the same audio

804
00:36:37.376 --> 00:36:38.286
playback interface.

805
00:36:38.906 --> 00:36:43.696
So, having the integration
within the 2 frameworks really,

806
00:36:43.696 --> 00:36:45.766
really add a lot of
possibilities here.

807
00:36:45.766 --> 00:36:49.126
You can have another level
of interaction with you user.

808
00:36:49.126 --> 00:36:51.726
For example, have a constant
background of 3D and all

809
00:36:51.726 --> 00:36:54.296
of the sudden you see a 3D
object flying out of the screen.

810
00:36:54.656 --> 00:36:58.756
It's actually making the user
having a third perspective

811
00:36:59.196 --> 00:37:00.376
of what a game looks like.

812
00:36:59.196 --> 00:37:00.376
of what a game looks like.

813
00:37:01.346 --> 00:37:03.786
Lastly, I want to
talk about tools here.

814
00:37:03.906 --> 00:37:09.006
So, for Xcode 6 we have released
a brand new SpriteKit editor.

815
00:37:10.086 --> 00:37:14.116
It is part of Xcode release and
you can use it to create any

816
00:37:14.116 --> 00:37:16.186
of the game scenes
without writing any code.

817
00:37:16.596 --> 00:37:19.246
You can also use it to interact
any of the SpriteKit features.

818
00:37:20.376 --> 00:37:24.936
In a nutshell, everything you
have seen here today can be done

819
00:37:24.936 --> 00:37:26.056
inside of SpriteKit Editor

820
00:37:26.056 --> 00:37:27.336
without writing any
lines of code.

821
00:37:27.336 --> 00:37:28.086
It forces you also...

822
00:37:28.086 --> 00:37:28.153
[ Applause ]

823
00:37:28.153 --> 00:37:28.676
Thank you!

824
00:37:28.676 --> 00:37:33.586
It also enables you to
write the data-driven model.

825
00:37:34.256 --> 00:37:37.096
Writing games usually
deals with a lot of data.

826
00:37:37.836 --> 00:37:40.486
And we want to shift
the focus from focusing

827
00:37:40.486 --> 00:37:44.266
on designing one level rather
than have a generic approach

828
00:37:44.526 --> 00:37:46.206
of data-oriented
programming model.

829
00:37:46.616 --> 00:37:49.766
So, now with SpriteKit Editor
we actually separate the game

830
00:37:49.766 --> 00:37:51.286
content from the game logic.

831
00:37:51.666 --> 00:37:54.416
So, you no longer have to
manually add a spaceship,

832
00:37:55.186 --> 00:37:58.166
set a degree at 10-10 and
launch the game, recompile it

833
00:37:58.166 --> 00:38:01.106
and launch the game and
"I'm about five pixels off.

834
00:37:58.166 --> 00:38:01.106
and launch the game and
"I'm about five pixels off.

835
00:38:01.106 --> 00:38:02.936
Maybe I'll add 5 pixels and..."

836
00:38:02.936 --> 00:38:06.056
It takes all the guessing work
out of your iteration process!

837
00:38:06.056 --> 00:38:06.296
[ Applause ]

838
00:38:06.296 --> 00:38:10.516
And we also provide
simplified game templates that's

839
00:38:10.516 --> 00:38:12.776
in both Swift and Objective-C.

840
00:38:13.376 --> 00:38:15.636
So, out of the box
you are good to go

841
00:38:15.636 --> 00:38:18.816
and have a brand new scene
created for you and ready

842
00:38:18.816 --> 00:38:20.966
for drag-and-drop and
play, create your level,

843
00:38:21.256 --> 00:38:24.126
and making sure your game
is running on day one.

844
00:38:25.266 --> 00:38:28.546
Not only can you use
SpriteKit Editor as an editor,

845
00:38:28.546 --> 00:38:30.486
you can use it as
a debugger as well.

846
00:38:31.006 --> 00:38:33.146
So, if you're in the middle
of running your scene,

847
00:38:33.146 --> 00:38:35.466
and one of your ships
becomes missing,

848
00:38:35.966 --> 00:38:38.346
you can use this one line
of code and just type

849
00:38:38.346 --> 00:38:40.956
that in a debugger,
you get an SKS file.

850
00:38:41.046 --> 00:38:43.506
And guess what, you can
load that back into Xcode

851
00:38:43.506 --> 00:38:46.576
and see what's going on for that
scene and you trace back exactly

852
00:38:46.576 --> 00:38:47.606
where the scene hierarchy is.

853
00:38:48.266 --> 00:38:49.786
So, in the case of, say...

854
00:38:49.946 --> 00:38:52.266
If the spaceship got hidden
because of the Z order,

855
00:38:52.586 --> 00:38:54.956
you can totally see
that within the Xcode.

856
00:38:55.756 --> 00:38:59.066
And if you have an existing
game that's not even written

857
00:38:59.066 --> 00:39:01.536
for data-oriented programming,
you can use the same line

858
00:38:59.066 --> 00:39:01.536
for data-oriented programming,
you can use the same line

859
00:39:01.536 --> 00:39:02.906
of code to serialize it out.

860
00:39:02.906 --> 00:39:07.336
And if you need to retouch
it or adding new features,

861
00:39:08.246 --> 00:39:11.296
dragging new Xcode in -- use the
editor and add new features in.

862
00:39:11.466 --> 00:39:12.306
They are ready to go.

863
00:39:12.306 --> 00:39:13.246
[ Applause ]

864
00:39:13.246 --> 00:39:14.886
So, some of the basic
features that we provide

865
00:39:14.886 --> 00:39:16.266
for the SpriteKit
Editor allow you

866
00:39:16.266 --> 00:39:18.556
to do basic object
manipulation and placement,

867
00:39:18.556 --> 00:39:21.916
they include position,
orientation and scale.

868
00:39:22.416 --> 00:39:25.646
You can set up a physics bodies,
bounding box, bounding circles

869
00:39:25.646 --> 00:39:28.286
or even the brand new
per-pixel physics set up.

870
00:39:28.686 --> 00:39:31.976
You can bring in 3D content
from [inaudible] directly

871
00:39:31.976 --> 00:39:34.446
into a 2D scene and save
it and load it in game

872
00:39:34.726 --> 00:39:36.586
and see the 3D object
and it's ready for --

873
00:39:36.856 --> 00:39:37.996
ready to be manipulated.

874
00:39:38.596 --> 00:39:40.036
And we can set up shadows

875
00:39:40.306 --> 00:39:43.586
and lighting effects,
inverse kinematics.

876
00:39:43.976 --> 00:39:46.606
You can set up an inverse
kinematic joint hierarchy right

877
00:39:46.606 --> 00:39:49.766
inside of Xcode and preview
that effect right here.

878
00:39:50.256 --> 00:39:53.066
We also provide an integrated
shader editor, allowing you

879
00:39:53.066 --> 00:39:57.356
to have a WYSIWYG effect
of editing your shaders

880
00:39:57.356 --> 00:39:58.756
and tuning your shader uniforms.

881
00:39:59.546 --> 00:40:01.436
So, I'm going to give
you a quick demo.

882
00:39:59.546 --> 00:40:01.436
So, I'm going to give
you a quick demo.

883
00:40:02.346 --> 00:40:05.006
So, from Monday's talk, the
"State of the Union" demo,

884
00:40:05.006 --> 00:40:06.886
hopefully you have seen
how to use SpriteKit Editor

885
00:40:06.886 --> 00:40:11.176
to create physics bodies, set
up per-pixel physics collusions

886
00:40:11.676 --> 00:40:13.936
and also interact with
field forces and 3D objects.

887
00:40:14.106 --> 00:40:17.276
So, today the topic that
I'm going to cover is how

888
00:40:17.276 --> 00:40:19.996
to use SpriteKit
Editor to set up lights

889
00:40:20.286 --> 00:40:23.066
and shadows using
inverse kinematics and how

890
00:40:23.066 --> 00:40:24.586
to use the building
shader editor

891
00:40:24.586 --> 00:40:25.976
to quickly iterate your shaders.

892
00:40:26.296 --> 00:40:27.126
So, let's have a look.

893
00:40:28.196 --> 00:40:31.606
So, here we have a brand
new lighting scene.

894
00:40:31.856 --> 00:40:35.506
So, nothing is in
here and ready to go.

895
00:40:36.006 --> 00:40:39.346
If you click in the object
library this gives you any

896
00:40:39.346 --> 00:40:41.556
existing textures that's
in a current project.

897
00:40:41.686 --> 00:40:43.306
So, if I just drag
in a cobblestone

898
00:40:44.066 --> 00:40:46.246
and I can make it
slightly bigger.

899
00:40:47.416 --> 00:40:49.576
And to see any of the
SpriteKit widgets,

900
00:40:49.676 --> 00:40:52.196
you just open the object library
and, because we're adding

901
00:40:52.196 --> 00:40:54.076
in a SpriteKit scene,
its content-sensitive.

902
00:40:54.076 --> 00:40:56.796
It knows these are the SpriteKit
objects that're relevant

903
00:40:56.796 --> 00:40:59.016
for this editing experience.

904
00:40:59.356 --> 00:41:00.596
And now let's drag a light in.

905
00:40:59.356 --> 00:41:00.596
And now let's drag a light in.

906
00:41:01.086 --> 00:41:04.056
It doesn't do quite what I want
yet, because it hasn't lit yet.

907
00:41:04.406 --> 00:41:07.706
As you can see the lighting
mask that we have on the sprite

908
00:41:07.706 --> 00:41:09.556
or on the cobblestone
is not set.

909
00:41:09.626 --> 00:41:12.586
So, here if we set it to be
1 we you see that right away,

910
00:41:13.166 --> 00:41:14.856
no code of writing, nothing.

911
00:41:15.096 --> 00:41:17.486
So, if you save this file,
load it in your scene,

912
00:41:18.016 --> 00:41:19.486
this is exactly what
you're going to get,

913
00:41:19.486 --> 00:41:22.306
because SpriteKit Editor
actually uses SpriteKit writing

914
00:41:22.306 --> 00:41:23.046
instead of Xcode.

915
00:41:24.356 --> 00:41:27.366
So, now we can move the scene
around, move the light around.

916
00:41:27.646 --> 00:41:28.676
You can see different effects.

917
00:41:29.286 --> 00:41:31.826
And now it's kind of
2D-ish and blandish.

918
00:41:32.456 --> 00:41:34.016
Maybe we can change the texture

919
00:41:34.076 --> 00:41:36.376
so we can automatically generate
a normal map on the fly.

920
00:41:36.886 --> 00:41:39.136
Say if I want to make
stone a little bit sharp,

921
00:41:39.136 --> 00:41:42.536
but also have a bit of
contrast I can do that.

922
00:41:43.166 --> 00:41:44.296
It's just two numbers.

923
00:41:44.946 --> 00:41:46.976
And if I want to
make it slightly...

924
00:41:46.976 --> 00:41:48.796
mm, maybe it's too sharp,

925
00:41:48.936 --> 00:41:52.426
it might look very
discomfort to walk on.

926
00:41:52.426 --> 00:41:54.356
So, if I want to have --

927
00:41:54.666 --> 00:41:56.926
lower that, that's
slightly more subtle look.

928
00:41:56.926 --> 00:41:59.596
And if I move that object

929
00:41:59.596 --> 00:42:02.646
around as you can see
the light, real light.

930
00:41:59.596 --> 00:42:02.646
around as you can see
the light, real light.

931
00:42:02.646 --> 00:42:03.386
[ Applause ]

932
00:42:03.386 --> 00:42:07.886
So, now let's go ahead and
add a stone object here.

933
00:42:08.196 --> 00:42:09.156
That's a little bit too big.

934
00:42:09.346 --> 00:42:10.356
Let's make it smaller.

935
00:42:10.996 --> 00:42:12.896
And I want the stone
to be lit as well

936
00:42:12.956 --> 00:42:14.626
so let's set the
lighting mask to be 1,

937
00:42:14.876 --> 00:42:18.286
same as the scene object, okay.

938
00:42:18.916 --> 00:42:23.106
And because we want to have
maybe a 3D look for this,

939
00:42:23.106 --> 00:42:24.996
maybe the stone will
need to cast shadows...

940
00:42:24.996 --> 00:42:28.776
we just need to set the
shadow mask on that.

941
00:42:28.776 --> 00:42:34.696
So, move it around and now
we can change some properties

942
00:42:35.006 --> 00:42:35.826
of lighting.

943
00:42:36.616 --> 00:42:38.216
So, I can change the
lighting color...

944
00:42:38.586 --> 00:42:39.716
Oh that's a little weird.

945
00:42:42.186 --> 00:42:48.066
Something normalish, warm color
is the way to go, so there.

946
00:42:48.616 --> 00:42:52.756
As soon as you hit File,
Save the scene is ready

947
00:42:52.756 --> 00:42:54.166
and you are good to go.

948
00:42:54.306 --> 00:42:59.046
You don't have to do SKLightNode
in it, add it to scene,

949
00:42:59.046 --> 00:43:00.646
position equals -- none of that.

950
00:42:59.046 --> 00:43:00.646
position equals -- none of that.

951
00:43:01.116 --> 00:43:02.646
So, this is very cool.

952
00:43:03.486 --> 00:43:05.646
So, next I want to show
is the inverse kinematics,

953
00:43:05.756 --> 00:43:07.496
so here I have a
preassembled robot.

954
00:43:07.496 --> 00:43:09.666
I'm just going to give
you a quick overview.

955
00:43:09.916 --> 00:43:11.416
So, here I have the arm object.

956
00:43:12.516 --> 00:43:16.236
Arm is parented directly to
the scene for the upper arm.

957
00:43:17.076 --> 00:43:20.676
The lower arm is attached as
a parent for the upper arm.

958
00:43:21.416 --> 00:43:24.346
And we have the claw that
attach to the lower arm.

959
00:43:25.116 --> 00:43:28.206
So, to launch or set
up inverse kinematics

960
00:43:28.206 --> 00:43:30.956
for this robot I just need
to start simulate a scene,

961
00:43:31.676 --> 00:43:37.536
select these objects and I
can run inverse kinematics

962
00:43:37.836 --> 00:43:39.516
on the robot right
inside of the editor

963
00:43:39.866 --> 00:43:41.346
and to see how it's set up.

964
00:43:42.126 --> 00:43:44.456
And if you want, that doesn't
look quite right, maybe I need

965
00:43:44.456 --> 00:43:46.326
to set a little bit of
constraint on there.

966
00:43:46.666 --> 00:43:50.916
Maybe I need to limit to say
90 degrees to 180 degrees

967
00:43:50.946 --> 00:43:54.616
for that joint and you
can have the same effect.

968
00:43:56.676 --> 00:44:00.146
As you can see it
actually reaches back

969
00:43:56.676 --> 00:44:00.146
As you can see it
actually reaches back

970
00:44:00.146 --> 00:44:02.356
and it will not over-bend
that arm at the elbow.

971
00:44:03.186 --> 00:44:05.936
So, that's the inverse
kinematics, very easy to set up.

972
00:44:05.936 --> 00:44:08.216
Again, you don't have to
write any lines of code

973
00:44:08.296 --> 00:44:10.736
to see the code effect or
use any of the features here.

974
00:44:11.186 --> 00:44:13.166
Plus I want to go
over our shaders.

975
00:44:13.526 --> 00:44:15.906
To uses shaders is very easy.

976
00:44:16.956 --> 00:44:19.616
So, here from the widget
library I can just pull

977
00:44:19.616 --> 00:44:21.246
in a solid color of sprite.

978
00:44:22.366 --> 00:44:25.616
And here I happen to have a
custom shader that I can run.

979
00:44:25.726 --> 00:44:27.676
So, how do I set
a custom shader?

980
00:44:28.536 --> 00:44:30.916
SpriteKit Editor automatically
process your work space

981
00:44:30.986 --> 00:44:33.386
and figure out how many
FSH files that you have.

982
00:44:33.746 --> 00:44:34.926
So, here I have a single one.

983
00:44:35.216 --> 00:44:37.336
I set that and boom,
I'm good to go.

984
00:44:37.446 --> 00:44:37.516
So...

985
00:44:37.516 --> 00:44:38.076
[ Applause ]

986
00:44:38.076 --> 00:44:39.416
This is only half
of the equation.

987
00:44:40.256 --> 00:44:44.136
To actually -- the iteration
experience is even better.

988
00:44:45.926 --> 00:44:50.316
So, here if I want to make a
change to the shader I just call

989
00:44:50.316 --> 00:44:51.716
in the assistant editor.

990
00:44:52.326 --> 00:44:56.376
If I just click on the object
it knows which shader you used

991
00:44:56.466 --> 00:44:58.926
and it brings up the
shader source side-by-side

992
00:44:58.926 --> 00:44:59.996
and you're ready to edit.

993
00:45:00.136 --> 00:45:03.456
You're ready to make changes and
monitor your whole workspace.

994
00:45:03.876 --> 00:45:08.886
So, now if I notice the radius
of the center of the circle,

995
00:45:08.886 --> 00:45:10.066
I want to shift it a little bit.

996
00:45:10.106 --> 00:45:14.556
So, if I change it to 0.2 and
0.2 and then what happened?

997
00:45:15.156 --> 00:45:18.006
Usually you need to
rebuild your application.

998
00:45:18.356 --> 00:45:19.956
You need to rerun
the application.

999
00:45:20.546 --> 00:45:23.036
The application will upload
a new shader to the OpenGL,

1000
00:45:23.036 --> 00:45:25.376
GL's driver will compile whether

1001
00:45:25.606 --> 00:45:27.396
if you forget a semicolon,
guess what?

1002
00:45:27.396 --> 00:45:28.546
You start that process again.

1003
00:45:29.846 --> 00:45:32.276
Here you just need
to do File, Save.

1004
00:45:33.386 --> 00:45:35.386
So, if I make -- Oh, it
automatically saved for me.

1005
00:45:35.386 --> 00:45:37.166
So, if I change it back to 0.5,

1006
00:45:37.166 --> 00:45:41.106
0.5 and file save you see
the live change right here.

1007
00:45:43.336 --> 00:45:46.216
And what if I decide to
add a brand new uniforms

1008
00:45:46.726 --> 00:45:47.286
to the shader?

1009
00:45:47.286 --> 00:45:50.186
So, here I want to
add a speed parameter

1010
00:45:50.186 --> 00:45:53.296
so I can control the
effect that I'm having here.

1011
00:45:53.296 --> 00:45:55.806
So, if I save that, guess what?

1012
00:45:55.806 --> 00:46:00.306
You have real OpenGL annotation
error right inside of Xcode.

1013
00:45:55.806 --> 00:46:00.306
You have real OpenGL annotation
error right inside of Xcode.

1014
00:46:00.626 --> 00:46:03.096
So, here because I
introduced a new uniform

1015
00:46:03.466 --> 00:46:05.966
that has not been
declared so the declaration

1016
00:46:05.966 --> 00:46:07.796
of current time fails at any --

1017
00:46:08.066 --> 00:46:10.076
the two other places
that I referenced

1018
00:46:10.406 --> 00:46:12.456
to current time will
fail as well.

1019
00:46:12.716 --> 00:46:13.746
So, how do we fix that?

1020
00:46:13.746 --> 00:46:17.066
Because we add this new
uniform, let's go ahead and add

1021
00:46:17.066 --> 00:46:18.066
that in the dictionary.

1022
00:46:19.496 --> 00:46:20.916
So, because we're calling it

1023
00:46:20.916 --> 00:46:22.756
"u.speed" we make
sure the name matches,

1024
00:46:22.756 --> 00:46:26.366
u.speed and has a value of 0.

1025
00:46:27.116 --> 00:46:30.796
And if I change that to 1
I see the live effect right

1026
00:46:30.856 --> 00:46:33.396
in the editor and
make it spin faster.

1027
00:46:33.986 --> 00:46:34.776
Ooh, see there?

1028
00:46:35.796 --> 00:46:36.866
OK, let's make it slower.

1029
00:46:39.386 --> 00:46:42.376
So, live shader editing,
right inside of Xcode.

1030
00:46:42.376 --> 00:46:42.443
[ Applause ]

1031
00:46:42.443 --> 00:46:44.376
So that's the demo of
our SpriteKit Editor.

1032
00:46:45.806 --> 00:46:48.696
Lastly, I want to go over
some additional improvements

1033
00:46:48.696 --> 00:46:49.316
that we have done

1034
00:46:49.316 --> 00:46:52.676
to the existing SpriteKit
framework APIs.

1035
00:46:52.866 --> 00:46:54.936
So, for those of you who
are new to SpriteKit,

1036
00:46:55.246 --> 00:46:58.266
here is the brand
new update clock

1037
00:46:58.266 --> 00:46:59.666
that we have done for this year.

1038
00:47:01.576 --> 00:47:04.286
As the frame starts we
start with update function.

1039
00:47:04.556 --> 00:47:06.536
So, this is where you can
set up your game logic.

1040
00:47:07.806 --> 00:47:10.826
After that, scene will
start evaluating actions.

1041
00:47:12.366 --> 00:47:15.906
After the actions are evaluated
user gets a callback saying,

1042
00:47:15.906 --> 00:47:18.796
"Okay if I animate, or move
this object from A to B,

1043
00:47:19.366 --> 00:47:20.586
do I need to do anything else?"

1044
00:47:21.466 --> 00:47:24.646
After the actions,
physics kicks in and set

1045
00:47:24.646 --> 00:47:27.156
up the physics use
stepping for the frame.

1046
00:47:27.856 --> 00:47:29.746
Once physics simulation
is finished,

1047
00:47:29.886 --> 00:47:32.336
user gets another callback
with the simulated physics.

1048
00:47:32.426 --> 00:47:34.156
And this is where
you can set up, say,

1049
00:47:34.156 --> 00:47:35.626
if the player gets pushed off,

1050
00:47:36.066 --> 00:47:38.136
maybe I move back
by another 5 pixels.

1051
00:47:38.886 --> 00:47:41.466
And now with the
brand-new constraints API

1052
00:47:41.686 --> 00:47:46.116
where adding a scene will
apply constraints right

1053
00:47:46.116 --> 00:47:46.796
at this moment.

1054
00:47:47.196 --> 00:47:50.706
After constraints are being
applied user gets another

1055
00:47:50.706 --> 00:47:53.486
notification of -- with
didApplyConstraints.

1056
00:47:53.996 --> 00:47:57.656
And now we also added one more
selector for user to react

1057
00:47:57.656 --> 00:47:59.186
on called didFinishUpdate.

1058
00:47:59.436 --> 00:48:02.696
This is absolutely the last
stop before SpriteKit packages

1059
00:47:59.436 --> 00:48:02.696
This is absolutely the last
stop before SpriteKit packages

1060
00:48:02.696 --> 00:48:05.566
everything up and send
it to the graphics GPU

1061
00:48:05.766 --> 00:48:06.426
for the current frame.

1062
00:48:06.426 --> 00:48:09.526
And SpriteKit renders
the current frame

1063
00:48:10.206 --> 00:48:12.876
and the same loop continues
60 times per second.

1064
00:48:14.436 --> 00:48:17.046
Now, SKTexture got a
little bit revamped here.

1065
00:48:17.046 --> 00:48:20.206
We introduce a new type of
texture called mutable texture.

1066
00:48:21.046 --> 00:48:23.946
You can create from data and
can be modified very efficiently

1067
00:48:23.986 --> 00:48:24.626
every frame.

1068
00:48:24.816 --> 00:48:26.786
We provide a callback
block allowing you

1069
00:48:26.786 --> 00:48:29.146
to make modifications
to the raw pointers.

1070
00:48:29.246 --> 00:48:31.516
So, here if I'm just
making changes

1071
00:48:31.516 --> 00:48:33.596
to the raw pixel data
you can set that.

1072
00:48:34.236 --> 00:48:37.856
So, if you have a really cool
CPU-based post-processing effect

1073
00:48:37.856 --> 00:48:39.706
and you want to modify
a texture,

1074
00:48:40.156 --> 00:48:41.366
you have the freedom to do that.

1075
00:48:41.626 --> 00:48:44.456
If you want to have a custom
data, you want to send it

1076
00:48:44.456 --> 00:48:48.546
to a shader as input by sending
up all the data as textures,

1077
00:48:49.036 --> 00:48:51.326
you can do that as well.

1078
00:48:51.696 --> 00:48:55.196
Also SKTextures can
generate noise textures now.

1079
00:48:55.196 --> 00:48:57.606
It generates coherent
noise that gives you --

1080
00:48:57.606 --> 00:48:59.366
or the noise vector
from a sphere.

1081
00:48:59.996 --> 00:49:01.776
So, it supports both
the noise generated

1082
00:48:59.996 --> 00:49:01.776
So, it supports both
the noise generated

1083
00:49:01.776 --> 00:49:04.866
in the grayscale color,
grayscale or the color output.

1084
00:49:05.216 --> 00:49:08.196
If it's generated from a
noise vector we have to stay

1085
00:49:08.246 --> 00:49:09.796
in the color output space.

1086
00:49:10.236 --> 00:49:13.556
So, here, to create the noise
texture, you just call texture

1087
00:49:13.556 --> 00:49:15.586
with noise, which you can
control the smoothness,

1088
00:49:15.896 --> 00:49:19.326
as well as control the size.

1089
00:49:19.856 --> 00:49:22.716
Now, SKShapeNode also received
a lot of revamp this year.

1090
00:49:23.086 --> 00:49:25.576
So, we added convenient
constructors for common shapes.

1091
00:49:25.706 --> 00:49:29.586
They include rectangles,
circles, ellipse and splines.

1092
00:49:30.436 --> 00:49:36.116
We also allow you to set texture
and shaders for both the stroke

1093
00:49:36.256 --> 00:49:38.006
and fill for the actual shape.

1094
00:49:39.056 --> 00:49:40.696
You can use ShapeNode
to interact

1095
00:49:40.696 --> 00:49:41.886
with your physics as well.

1096
00:49:41.886 --> 00:49:46.776
If you build up this very
complex shape using ShapeNode,

1097
00:49:47.006 --> 00:49:49.206
you can just access the
path property directly

1098
00:49:49.656 --> 00:49:52.316
and then get a CG path,
send it directly to physics,

1099
00:49:52.446 --> 00:49:54.216
physics will create a
physics body for you.

1100
00:49:56.456 --> 00:50:00.606
We've also made creating pin
joints much, much easier.

1101
00:49:56.456 --> 00:50:00.606
We've also made creating pin
joints much, much easier.

1102
00:50:00.806 --> 00:50:04.696
So, with SKphysicsBody we now
have a new property called

1103
00:50:04.696 --> 00:50:04.976
"pinned".

1104
00:50:06.056 --> 00:50:10.886
To pin an object to
another object you just need

1105
00:50:10.886 --> 00:50:11.946
to set one property.

1106
00:50:12.126 --> 00:50:13.506
So, here I have a big gear.

1107
00:50:13.716 --> 00:50:14.936
I want to pin it to the board.

1108
00:50:15.376 --> 00:50:18.506
I just set the property to
yes, SpriteKit will figure

1109
00:50:18.506 --> 00:50:22.176
out all the parents of
the conversion space

1110
00:50:22.176 --> 00:50:23.926
and whether the other
object has physics body.

1111
00:50:23.926 --> 00:50:26.616
It will take care of all of
that detail for you, very cool.

1112
00:50:28.556 --> 00:50:32.606
Now, in addition to pin joint
we also make creating weld joint

1113
00:50:32.606 --> 00:50:33.696
really, really easy.

1114
00:50:34.066 --> 00:50:36.176
So, weld joint is just
the same as pin joint,

1115
00:50:36.176 --> 00:50:39.696
which means pinned equal YES,
but if it won't allow rotation

1116
00:50:40.646 --> 00:50:42.526
that means I'm welded
to my parents.

1117
00:50:42.906 --> 00:50:44.216
So, here I have a small gear

1118
00:50:44.266 --> 00:50:46.916
that will be welded
to the big gear.

1119
00:50:47.826 --> 00:50:52.646
So, we set 2 properties and the
physics is automatically set

1120
00:50:52.646 --> 00:50:53.046
up for you.

1121
00:50:54.416 --> 00:50:58.756
In addition, physics body can
now be created using compound

1122
00:50:58.756 --> 00:50:59.456
physics bodies.

1123
00:50:59.626 --> 00:51:00.666
All you need to do is just,

1124
00:50:59.626 --> 00:51:00.666
All you need to do is just,

1125
00:51:00.666 --> 00:51:03.226
in SKPhysicsBody we'll
add a new initializer

1126
00:51:03.226 --> 00:51:04.446
called bodyWithBodies.

1127
00:51:04.446 --> 00:51:07.626
You pass in an array of the
different physics body shapes.

1128
00:51:07.776 --> 00:51:11.556
And for example, hammer here
is contained with 2 rectangles,

1129
00:51:11.826 --> 00:51:14.726
one for the top and the handle.

1130
00:51:15.896 --> 00:51:18.416
Now, SKTexture Atlas is our --

1131
00:51:19.416 --> 00:51:22.116
one of the key components
to allow users

1132
00:51:22.116 --> 00:51:24.466
to have efficient
graphics performance.

1133
00:51:24.656 --> 00:51:28.136
So, anything that's in a
texture atlas we allow OpenGL

1134
00:51:28.136 --> 00:51:29.436
to do efficient batching here.

1135
00:51:29.856 --> 00:51:32.556
So, it's now supported for
both SpriteKit and SceneKit.

1136
00:51:32.986 --> 00:51:36.366
We support both retina and
non-retina resolutions.

1137
00:51:36.526 --> 00:51:39.896
So, if you have a game and
have all the assets put

1138
00:51:39.896 --> 00:51:43.676
in one folder the Texture Atlas
generator will separate them

1139
00:51:43.676 --> 00:51:44.126
for you.

1140
00:51:44.126 --> 00:51:46.086
So, you don't have to
pay the memory overhead.

1141
00:51:46.086 --> 00:51:49.206
If you're loading the Texture
Atlas on a retina device,

1142
00:51:49.406 --> 00:51:51.736
you don't have to load
the non-retina asset.

1143
00:51:52.136 --> 00:51:56.636
It also supports the
full 32-bit pixel format

1144
00:51:57.166 --> 00:51:59.116
and also the compressed
16 format.

1145
00:52:00.116 --> 00:52:02.866
Now, one of the big
changes: we now support

1146
00:52:02.866 --> 00:52:04.676
up to 4k by 4k resolution.

1147
00:52:04.676 --> 00:52:09.066
So, it's a simple change in the
Xcode settings for your project.

1148
00:52:10.446 --> 00:52:14.726
And in addition we
support Runtime Texture

1149
00:52:14.726 --> 00:52:15.876
Atlas generation.

1150
00:52:16.706 --> 00:52:18.806
So, if you have downloadable
content, say,

1151
00:52:18.886 --> 00:52:21.296
user downloaded a new
level, everything is coming

1152
00:52:21.296 --> 00:52:25.046
in loose files, or users go take
-- go out and take some pictures

1153
00:52:25.046 --> 00:52:27.006
and decide to use that
in-game as a cube map,

1154
00:52:27.746 --> 00:52:30.316
you can just simply pass
into the SKTextureAtlas API

1155
00:52:30.316 --> 00:52:32.736
and we'll automatically
stitch it for you

1156
00:52:33.066 --> 00:52:36.676
and trim off the
transparent pixels.

1157
00:52:37.946 --> 00:52:42.676
So, in summary we really have
a lot of new features packed

1158
00:52:42.676 --> 00:52:44.266
in this year's SpriteKit
release.

1159
00:52:44.266 --> 00:52:46.076
We have a lot of cool
graphics technology

1160
00:52:46.076 --> 00:52:48.906
like custom shaders,
lighting and shadows.

1161
00:52:49.156 --> 00:52:53.676
We have really cool simulation
effects like inverse kinematics,

1162
00:52:53.876 --> 00:52:57.776
physics field, per-pixel
physics and constraints.

1163
00:52:58.706 --> 00:53:01.506
All of these features can
be done using one line,

1164
00:52:58.706 --> 00:53:01.506
All of these features can
be done using one line,

1165
00:53:01.836 --> 00:53:04.516
or no lines at all if you
use the SpriteKit Editor.

1166
00:53:05.256 --> 00:53:08.426
So, the SpriteKit Editor is a
new edition to the Xcode family

1167
00:53:08.426 --> 00:53:09.706
and is a really,
really cool feature.

1168
00:53:09.706 --> 00:53:11.046
I highly encourage
you to use it.

1169
00:53:11.766 --> 00:53:15.036
And it's also a good learning
experience to see how any

1170
00:53:15.036 --> 00:53:18.476
of the new features interact
with each other within a scene.

1171
00:53:19.106 --> 00:53:21.046
And we can't wait to
see what you can come

1172
00:53:21.046 --> 00:53:22.196
up with all these technologies

1173
00:53:22.196 --> 00:53:24.096
and tools we provided
for this release.

1174
00:53:24.556 --> 00:53:27.766
So, with that said, if you
have any questions or feedback

1175
00:53:27.766 --> 00:53:30.976
or anything you want to see in
the future, we would like to --

1176
00:53:31.316 --> 00:53:35.206
you can feel free to contact
our Developer Evangelist Allan

1177
00:53:35.206 --> 00:53:37.956
Schaffer and Filip Iliescu

1178
00:53:38.596 --> 00:53:42.436
and we have a revamped SpriteKit
Programming Guide that's

1179
00:53:42.436 --> 00:53:43.566
on the Developer Portal.

1180
00:53:43.566 --> 00:53:45.326
So, if you want to pick
up the documentation

1181
00:53:45.326 --> 00:53:47.266
for these new features
they're already there.

1182
00:53:48.196 --> 00:53:50.566
And for the related session
right after this session is the

1183
00:53:50.566 --> 00:53:52.206
"Best Practices for
Building SpriteKit Games".

1184
00:53:52.416 --> 00:53:53.636
We're going to go into depth

1185
00:53:53.636 --> 00:53:56.176
of what are the best performance
practices and how to set

1186
00:53:56.176 --> 00:53:58.356
up a game right in order
to use these new features

1187
00:53:58.906 --> 00:54:00.936
and set up for scalability.

1188
00:53:58.906 --> 00:54:00.936
and set up for scalability.

1189
00:54:01.386 --> 00:54:04.136
And as I said before,
we worked really closely

1190
00:54:04.136 --> 00:54:07.596
with the SceneKit team to
making sure SceneKit is also a

1191
00:54:08.206 --> 00:54:10.176
high-level 3D API
just like SpriteKit.

1192
00:54:10.256 --> 00:54:12.326
I highly encourage you to
check out the SceneKit sessions

1193
00:54:12.326 --> 00:54:14.626
for tomorrow in the same
room for two sessions.

1194
00:54:15.376 --> 00:54:17.476
And with that said,
thank you very much,

1195
00:54:17.526 --> 00:54:18.596
this is the end of the session.

1196
00:54:18.596 --> 00:54:20.976
I hope you guys have the
rest of the -- a good week.

1197
00:54:21.516 --> 00:54:24.300
[ Applause ]
