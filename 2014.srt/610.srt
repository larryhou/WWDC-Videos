
1
00:00:13.196 --> 00:00:13.986
>> Hello.

2
00:00:15.516 --> 00:00:18.766
[ Applause ]

3
00:00:19.266 --> 00:00:22.636
Welcome to Session 610:
"Building a Game with SceneKit."

4
00:00:24.256 --> 00:00:27.686
SceneKit is an amazing
technology that makes it easy

5
00:00:27.686 --> 00:00:31.196
to write casual 3D games.

6
00:00:31.376 --> 00:00:34.796
Because SceneKit is a high
level API that integrates well

7
00:00:34.916 --> 00:00:37.936
with other Cocoa frameworks,
it's really easy to write games.

8
00:00:38.106 --> 00:00:39.926
We built this demo for WWDC,

9
00:00:39.926 --> 00:00:43.266
and I only required
a few lines of code.

10
00:00:44.176 --> 00:00:47.516
We believe that building
a casual 3D game

11
00:00:47.636 --> 00:00:50.726
with SceneKit is really easy,
and anybody can do that.

12
00:00:50.966 --> 00:00:51.976
It's really fantastic.

13
00:00:53.136 --> 00:00:55.746
So, this is a hands-on session,

14
00:00:55.746 --> 00:00:57.226
so hopefully you
are already familiar

15
00:00:57.226 --> 00:00:58.646
with the basics of SceneKit.

16
00:00:58.806 --> 00:01:01.766
You should know what
a scene graph is;

17
00:00:58.806 --> 00:01:01.766
You should know what
a scene graph is;

18
00:01:01.906 --> 00:01:06.006
that nodes have attributes such
as geometry, camera and lights;

19
00:01:06.426 --> 00:01:10.186
and if not, we have great
sessions about this,

20
00:01:10.186 --> 00:01:11.996
one just before and
one last year.

21
00:01:12.606 --> 00:01:15.086
I encourage you to check
these presentations

22
00:01:15.086 --> 00:01:19.796
because they have 3D slides
entirely made in SceneKit.

23
00:01:19.846 --> 00:01:22.086
So, in this session, we
will start really quick

24
00:01:22.296 --> 00:01:26.596
by showing you how to start
in Xcode, how to add 3D assets

25
00:01:26.596 --> 00:01:29.056
to your project, and have
your first scene rendered

26
00:01:29.056 --> 00:01:29.646
to the screen.

27
00:01:30.586 --> 00:01:32.716
Then we will show you
our Bananas demos.

28
00:01:33.096 --> 00:01:35.756
It's a great demo because
it shows many features

29
00:01:35.756 --> 00:01:37.846
of the SceneKit framework,
and we will use

30
00:01:37.846 --> 00:01:39.646
that demo throughout
the rest of the session.

31
00:01:40.046 --> 00:01:42.046
We will explain to
you how we made it

32
00:01:42.046 --> 00:01:43.656
so then you can create
your own games.

33
00:01:43.846 --> 00:01:46.656
And finally, Thomas will
join me onstage to talk

34
00:01:46.656 --> 00:01:49.496
about performance and creating
custom tools for SceneKit.

35
00:01:50.966 --> 00:01:52.536
Okay, let's get started.

36
00:01:52.536 --> 00:01:58.686
The first thing you want to have
when building a 3D app is a view

37
00:01:58.686 --> 00:02:01.786
to render your scene, and
that's just easy as you see.

38
00:01:58.686 --> 00:02:01.786
to render your scene, and
that's just easy as you see.

39
00:02:02.476 --> 00:02:05.596
While integrating between
the interface builder,

40
00:02:05.906 --> 00:02:09.246
so all what you have to
do is drag an SCNView

41
00:02:09.246 --> 00:02:11.986
from the object library and
drop it onto your [inaudible].

42
00:02:13.996 --> 00:02:17.396
Then you open the inspector,

43
00:02:17.396 --> 00:02:19.286
where you can set the
visual properties,

44
00:02:19.506 --> 00:02:22.456
and you simply specify
the name of the 3D scene.

45
00:02:22.666 --> 00:02:26.716
You click Build and Run,
and boom: Without having

46
00:02:27.266 --> 00:02:28.826
to write any single
line of code,

47
00:02:28.906 --> 00:02:30.606
you have your first scene
rendered on the screen.

48
00:02:30.606 --> 00:02:34.976
Now, if you are starting a new
project, you might want to start

49
00:02:35.186 --> 00:02:36.506
with a new game template.

50
00:02:37.086 --> 00:02:40.246
It's really convenient because
it creates a universal app

51
00:02:40.516 --> 00:02:44.946
that runs on iPhone and iPad,
and it has a full-screen 3D view

52
00:02:45.046 --> 00:02:48.316
that displays a scene
you can interact with.

53
00:02:51.356 --> 00:02:52.946
The way you add 3D assets

54
00:02:53.106 --> 00:02:55.576
to your game is just
SceneKit asset catalogs.

55
00:02:56.906 --> 00:03:00.206
SceneKit asset catalogs
are new feature in Xcode 6,

56
00:02:56.906 --> 00:03:00.206
SceneKit asset catalogs
are new feature in Xcode 6,

57
00:03:00.256 --> 00:03:03.986
and they allow you to organize
and optimize your 3D assets.

58
00:03:05.136 --> 00:03:09.386
The structure of SceneKit
asset catalogs is preserved

59
00:03:09.466 --> 00:03:11.286
when they are copied
into your target.

60
00:03:11.886 --> 00:03:15.686
Also, they automatically track
files that are added to them

61
00:03:15.686 --> 00:03:17.136
or removed from them on disc.

62
00:03:21.056 --> 00:03:23.366
They are really convenient

63
00:03:23.366 --> 00:03:25.646
because they can optimize
your 3D assets for you.

64
00:03:25.936 --> 00:03:30.326
For instance, they help
with up axis conversion.

65
00:03:31.196 --> 00:03:33.246
SceneKit follows the
up axis conversion,

66
00:03:33.396 --> 00:03:36.996
which means that the positive y
axis is the one that looks up.

67
00:03:38.336 --> 00:03:39.896
This is a convention
that is followed

68
00:03:39.896 --> 00:03:42.186
by many other applications
and frameworks,

69
00:03:42.606 --> 00:03:44.696
but some exporters
do things differently

70
00:03:44.746 --> 00:03:47.936
and use a z up axis convention.

71
00:03:48.486 --> 00:03:49.796
With SceneKit asset catalogs,

72
00:03:49.916 --> 00:03:51.216
you don't have to
think about that.

73
00:03:51.716 --> 00:03:52.466
We automatically

74
00:03:52.466 --> 00:03:56.396
and transparently convert all
the animations and geometries

75
00:03:56.396 --> 00:03:59.056
in your scene so that they
follow the up axis convention.

76
00:04:00.396 --> 00:04:01.616
We are also able

77
00:04:01.956 --> 00:04:05.596
to automatically interleave
your geometries at build time.

78
00:04:06.396 --> 00:04:10.496
This means that your
vertices' position, normal,

79
00:04:10.496 --> 00:04:13.546
and texture coordinates are
stored in a single buffer

80
00:04:13.546 --> 00:04:15.156
that makes the GPU really happy

81
00:04:15.156 --> 00:04:18.266
and faster rendering
your geometries.

82
00:04:18.736 --> 00:04:22.346
And finally, on iOS we
support PVRTC textures.

83
00:04:22.606 --> 00:04:24.866
If you have two versions
of the same texture,

84
00:04:25.116 --> 00:04:27.356
one with the PVRTC
file extension -

85
00:04:27.356 --> 00:04:30.406
which is a compressed file
format that is optimized

86
00:04:30.406 --> 00:04:33.776
for iOS - and another version
- for instance, a PNG -

87
00:04:33.776 --> 00:04:38.196
this code will automatically
select the PVRTC texture

88
00:04:38.196 --> 00:04:40.696
when you target iOS
and the regular version

89
00:04:40.746 --> 00:04:41.976
when you target OS X.

90
00:04:45.346 --> 00:04:48.476
So, this is how it
works: Your artist works

91
00:04:48.866 --> 00:04:50.546
in their favorite
authoring tool;

92
00:04:51.196 --> 00:04:54.106
they export all the animation
and models you want to use

93
00:04:54.106 --> 00:04:56.096
in your app in a
COLLADA document.

94
00:04:56.456 --> 00:04:59.736
Then you take over and
you import this document

95
00:05:00.116 --> 00:05:01.326
in SceneKit asset catalogs.

96
00:05:01.706 --> 00:05:03.706
But there is much more
you can do with Xcode.

97
00:05:05.576 --> 00:05:08.116
To help you have a better
understanding of your scene,

98
00:05:08.216 --> 00:05:10.076
we built a scene
[inaudible] into Xcode.

99
00:05:11.406 --> 00:05:13.626
This tool is really great,
not only to allow you

100
00:05:13.626 --> 00:05:17.446
to have a better understanding
of what is inside your scene,

101
00:05:17.546 --> 00:05:20.496
but it's also useful to
tweak and refine the scene.

102
00:05:21.856 --> 00:05:25.846
For instance, with direct
manipulation you can place the

103
00:05:25.846 --> 00:05:29.106
nodes where you want, you can
rotate them and scale them,

104
00:05:29.446 --> 00:05:33.406
and that's much less code
to write in your app.

105
00:05:33.646 --> 00:05:36.156
You can also see how
nodes are arranged.

106
00:05:36.616 --> 00:05:38.996
You can re-bound them.

107
00:05:39.926 --> 00:05:40.856
You can merge them.

108
00:05:40.976 --> 00:05:46.356
You can create and delete nodes
as well as node attributes.

109
00:05:46.606 --> 00:05:49.836
You can immediately see which
node has a camera, light,

110
00:05:49.836 --> 00:05:54.406
or geometry attached to
it, and it also allows you

111
00:05:54.406 --> 00:05:56.866
to have a quick look at all
the entities in your scene.

112
00:05:57.306 --> 00:06:00.526
Remember that in SceneKit
node attributes are shared

113
00:05:57.306 --> 00:06:00.526
Remember that in SceneKit
node attributes are shared

114
00:06:00.526 --> 00:06:02.296
by default, and this
is a great way

115
00:06:02.296 --> 00:06:04.986
to know how many unique
objects you have in your scene,

116
00:06:05.326 --> 00:06:09.266
and it helps for performance.

117
00:06:09.266 --> 00:06:11.716
Of course, we have
inspectors in this editor.

118
00:06:12.386 --> 00:06:15.416
You can edit node properties,
and as you make changes,

119
00:06:15.516 --> 00:06:18.146
they are automatically
reflected in the viewports.

120
00:06:19.106 --> 00:06:22.306
This works for node
attributes as well.

121
00:06:22.686 --> 00:06:26.966
You can edit all the camera,
lights and geometry properties

122
00:06:26.966 --> 00:06:28.556
that are exposed
in the raw APIs.

123
00:06:28.556 --> 00:06:31.646
And finally, it works
on materials.

124
00:06:32.216 --> 00:06:33.016
This is really cool.

125
00:06:33.556 --> 00:06:36.946
It allows you to finely tweak
the rendering of your objects.

126
00:06:37.056 --> 00:06:39.986
You can control exactly how
they will render in your scene,

127
00:06:40.516 --> 00:06:43.656
because what you see
here in the editor,

128
00:06:43.816 --> 00:06:46.446
that is exactly how SceneKit
will render the scene

129
00:06:46.446 --> 00:06:47.216
in your app.

130
00:06:47.326 --> 00:06:48.486
It's a huge timesaver.

131
00:06:49.816 --> 00:06:51.666
In addition to the scene editor,

132
00:06:51.666 --> 00:06:53.386
we have a particle
system editor.

133
00:06:53.896 --> 00:06:57.456
It's really useful to edit
particle system properties,

134
00:06:57.716 --> 00:07:01.026
and it becomes very convenient
when you have to do things

135
00:06:57.716 --> 00:07:01.026
and it becomes very convenient
when you have to do things

136
00:07:01.026 --> 00:07:03.076
that would be very
tiresome in code.

137
00:07:03.286 --> 00:07:05.906
For instance, finding
the right animation curve

138
00:07:05.906 --> 00:07:10.776
to control the size of your
particles can take a very long

139
00:07:10.836 --> 00:07:11.456
time in code.

140
00:07:11.806 --> 00:07:13.836
With the editor and
immediate feedback,

141
00:07:13.836 --> 00:07:14.886
it's really quick and easy.

142
00:07:18.196 --> 00:07:20.976
So, we've already
covered a lot here.

143
00:07:21.736 --> 00:07:23.606
We know how to work
with an artist.

144
00:07:23.606 --> 00:07:25.546
You know how to tweak
scenes in the editor.

145
00:07:25.976 --> 00:07:29.386
You can automatically optimize
them using the asset catalogs,

146
00:07:29.386 --> 00:07:31.846
and you can render them on
the screen without having

147
00:07:31.846 --> 00:07:32.966
to write any line of code.

148
00:07:33.796 --> 00:07:35.896
And now, to show you
how truly simple it is

149
00:07:35.946 --> 00:07:38.516
to write a casual 3D
game, we built a demo.

150
00:07:39.996 --> 00:07:42.856
So, first it's a sample code,
so might you have any questions

151
00:07:42.856 --> 00:07:45.736
about what you are going to see
on the screen, you will be able

152
00:07:45.736 --> 00:07:48.086
to dive into the code
and see how it was done.

153
00:07:48.566 --> 00:07:50.646
And it's a great sample code

154
00:07:50.646 --> 00:07:54.226
because it illustrates many
features of SceneKit: animation,

155
00:07:54.336 --> 00:07:57.386
lighting and shadows,
physics, particles

156
00:07:57.386 --> 00:07:58.286
and advanced rendering.

157
00:07:59.186 --> 00:08:03.046
So, let's have a
look at the demo.

158
00:07:59.186 --> 00:08:03.046
So, let's have a
look at the demo.

159
00:08:03.046 --> 00:08:05.246
So, this is our game
named "Bananas."

160
00:08:06.116 --> 00:08:09.566
As you can see, we are in the
jungle controlling an explorer.

161
00:08:09.926 --> 00:08:12.566
We use gestures to make the
character walk along the path.

162
00:08:12.646 --> 00:08:16.476
On the track, we can collect
bananas, but there are enemies.

163
00:08:16.736 --> 00:08:20.436
We have some animated monkeys
that throw coconuts at us.

164
00:08:20.546 --> 00:08:22.606
So [inaudible], you
can jump and run.

165
00:08:23.456 --> 00:08:26.836
Look how the scene
looks gorgeous.

166
00:08:27.166 --> 00:08:29.456
We have perfect [inaudible]
real-time lighting

167
00:08:29.456 --> 00:08:31.136
as well as real-time shadows.

168
00:08:31.436 --> 00:08:36.096
Look how the character is lit
when it approaches the torches.

169
00:08:36.176 --> 00:08:38.905
As we advance in the game,
we encounter obstacles.

170
00:08:39.476 --> 00:08:43.616
Here is a lava flow, and falling
into it is not a good idea.

171
00:08:45.456 --> 00:08:46.926
So here we have to start again,

172
00:08:47.476 --> 00:08:49.836
and you will notice how
the explorer produce dust

173
00:08:50.076 --> 00:08:50.676
as she runs.

174
00:08:50.986 --> 00:08:55.056
If you look at the background,
you will notice a volcano.

175
00:08:55.116 --> 00:08:57.086
The volcano is erupting,

176
00:08:57.086 --> 00:08:59.166
and this is where
the lava comes from.

177
00:08:59.166 --> 00:09:02.576
In fact, everything that's
in this scene is animated:

178
00:08:59.166 --> 00:09:02.576
In fact, everything that's
in this scene is animated:

179
00:09:02.976 --> 00:09:05.396
the character and the
enemies, the lava,

180
00:09:05.396 --> 00:09:07.246
the torches, the vines as well.

181
00:09:09.376 --> 00:09:11.826
And as you can see,
everything is 3D in this scene.

182
00:09:12.676 --> 00:09:15.546
When the character moves, the
camera follows in 3D space

183
00:09:15.856 --> 00:09:17.136
and offers new points of view.

184
00:09:21.086 --> 00:09:23.846
We also have a soundtrack
and sound effects.

185
00:09:23.846 --> 00:09:27.766
There is also a basic UI that
show you how much time is left

186
00:09:27.916 --> 00:09:29.216
and your current score.

187
00:09:30.666 --> 00:09:33.416
This one's really supposed to
be on an iPad, but it works

188
00:09:33.416 --> 00:09:38.906
on iPhone too at 60
frames per second.

189
00:09:39.026 --> 00:09:40.356
Okay. Thanks, Thomas.

190
00:09:40.576 --> 00:09:40.926
Thank you.

191
00:09:42.516 --> 00:09:48.716
[ Applause ]

192
00:09:49.216 --> 00:09:50.636
So, this was "Bananas."

193
00:09:51.856 --> 00:09:55.646
It's an All Objective-C project,
and it's a small project:

194
00:09:56.286 --> 00:09:59.446
only 2,700 lines of code

195
00:09:59.646 --> 00:10:03.656
for everything you saw
onscreen today for iOS and OS X.

196
00:09:59.646 --> 00:10:03.656
for everything you saw
onscreen today for iOS and OS X.

197
00:10:05.476 --> 00:10:10.256
And so, you don't have
to have a big team

198
00:10:10.256 --> 00:10:12.606
to write a 3D casual
game with SceneKit.

199
00:10:12.856 --> 00:10:15.476
Bananas was written by
a team of one designer

200
00:10:15.476 --> 00:10:17.266
and only one engineer.

201
00:10:17.686 --> 00:10:19.876
It's really easy
to make such games.

202
00:10:20.046 --> 00:10:22.306
So first, a quick look
behind the scenes.

203
00:10:23.426 --> 00:10:24.836
Here is our world.

204
00:10:24.836 --> 00:10:27.976
It's a simple track on
which the character walks.

205
00:10:29.546 --> 00:10:33.276
Look how palm trees and rocks do
not always stand on the ground.

206
00:10:33.876 --> 00:10:36.636
This is because your scene
should only be made of elements

207
00:10:36.636 --> 00:10:40.626
that will, at some point,
be visible from the camera.

208
00:10:41.126 --> 00:10:42.076
Here is a side view.

209
00:10:42.396 --> 00:10:45.166
As you can see, vines
aren't attached to anything.

210
00:10:45.166 --> 00:10:48.076
They float in the air, and
the world suddenly ends.

211
00:10:48.796 --> 00:10:52.336
There's no need to have extra
geometry pushed to the GPU

212
00:10:52.336 --> 00:10:54.026
if it's never rendered
onto the screen.

213
00:10:56.336 --> 00:10:57.966
We have low [inaudible]
for the mountains

214
00:10:57.966 --> 00:11:00.676
and the volcano as
the background.

215
00:10:57.966 --> 00:11:00.676
and the volcano as
the background.

216
00:11:01.266 --> 00:11:04.566
It's absolutely fine to cheat
when you write 3D games.

217
00:11:04.836 --> 00:11:08.366
Here, the scene is sparse,
and you have to find tricks

218
00:11:08.366 --> 00:11:11.446
to make the scene gorgeous
but really cheap to render.

219
00:11:11.786 --> 00:11:18.276
So to give you some idea
of reasonable numbers,

220
00:11:18.556 --> 00:11:20.046
here are statistics
from the game.

221
00:11:21.016 --> 00:11:24.796
We have 10 lights in the world,
but each object is only affected

222
00:11:24.796 --> 00:11:25.916
by three lights at most.

223
00:11:26.586 --> 00:11:28.726
We have 200k polygons
in the world,

224
00:11:28.726 --> 00:11:31.546
but at each frame,
only 80 are rendered.

225
00:11:31.546 --> 00:11:36.126
And to finish, we have at
most 50 draw calls per frame,

226
00:11:36.126 --> 00:11:37.306
and that will make more sense

227
00:11:37.306 --> 00:11:39.236
when Thomas talks
about performance.

228
00:11:42.166 --> 00:11:46.026
So of course we use SceneKit
assets catalogs in "Bananas."

229
00:11:46.456 --> 00:11:50.946
We have about 25 3D documents
that store animation, models,

230
00:11:51.036 --> 00:11:52.536
textures and particle systems.

231
00:11:53.506 --> 00:11:57.736
And how do you use that many
different documents you want

232
00:11:57.736 --> 00:11:59.366
to consider in your game?

233
00:12:00.126 --> 00:12:02.786
Well, let's take this example.

234
00:12:02.936 --> 00:12:06.286
Here we have a document
which stores the jungle,

235
00:12:06.286 --> 00:12:08.006
and then those are documents

236
00:12:08.476 --> 00:12:11.556
which stores our animated
monkey, and we want to view

237
00:12:11.556 --> 00:12:13.046
that monkey in our world.

238
00:12:13.436 --> 00:12:15.516
The first step is really easy.

239
00:12:15.776 --> 00:12:18.096
All you have to do is
to load the two scenes.

240
00:12:18.596 --> 00:12:21.596
We have to - where you
have to be careful is

241
00:12:21.596 --> 00:12:23.866
that you cannot directly
add the root node

242
00:12:23.866 --> 00:12:25.676
of one scene to another scene.

243
00:12:26.436 --> 00:12:29.666
This is because root nodes
are not meant to be rebounded.

244
00:12:30.426 --> 00:12:31.726
What you have to do instead is

245
00:12:32.566 --> 00:12:35.856
to retrieve the node you're
interested in by using its name

246
00:12:36.406 --> 00:12:38.516
and then add it to
the original scene.

247
00:12:38.796 --> 00:12:45.056
And of course, you can add
multiple copies of that node.

248
00:12:45.056 --> 00:12:48.516
So SceneKit is a high level
API that [inaudible] well

249
00:12:48.516 --> 00:12:51.426
with other APIs on
the web platform,

250
00:12:51.816 --> 00:12:54.946
so we support game controllers
to control the character.

251
00:12:54.946 --> 00:12:57.736
But we also leverage
gesture recognizers

252
00:12:57.736 --> 00:13:01.516
and implemented our own
"D-pad" gesture recognizer

253
00:12:57.736 --> 00:13:01.516
and implemented our own
"D-pad" gesture recognizer

254
00:13:01.516 --> 00:13:04.176
to make the character jump
and go left and right.

255
00:13:04.766 --> 00:13:08.516
And then on OS X, we also
support game controllers

256
00:13:08.636 --> 00:13:10.736
and simply listen
to keyboard events.

257
00:13:12.476 --> 00:13:14.696
So how do we move the character?

258
00:13:14.696 --> 00:13:15.876
First, we have to animate it.

259
00:13:16.456 --> 00:13:19.946
Our character is skinned, which
means that it has a skeleton

260
00:13:19.946 --> 00:13:22.676
with bones, and by
animating these bones,

261
00:13:22.766 --> 00:13:24.136
we can define the geometry

262
00:13:24.136 --> 00:13:26.936
and make the character
adopt defined postures.

263
00:13:27.186 --> 00:13:31.136
Our character can
run, jump and be idle.

264
00:13:31.356 --> 00:13:33.436
And you have different
animations

265
00:13:33.676 --> 00:13:35.346
for the bones in these files.

266
00:13:36.636 --> 00:13:39.636
Animating a character
is just as easy

267
00:13:40.146 --> 00:13:43.276
as retrieving a Core
Animation animation

268
00:13:43.276 --> 00:13:45.566
by using the assigned
sceneSource class.

269
00:13:45.846 --> 00:13:47.806
It allows us to retrieve
an animation,

270
00:13:48.196 --> 00:13:52.816
with a unique identifier
of the animation

271
00:13:52.816 --> 00:13:54.416
that you can find in Xcode.

272
00:13:55.446 --> 00:13:58.046
And then, animating the
character is just as easy

273
00:13:58.516 --> 00:14:02.926
as adding this animation
to the character node.

274
00:13:58.516 --> 00:14:02.926
as adding this animation
to the character node.

275
00:14:03.136 --> 00:14:05.276
Okay, so now we animating
the character,

276
00:14:05.276 --> 00:14:06.586
but we still have to move it.

277
00:14:06.906 --> 00:14:08.456
There are many ways to do that,

278
00:14:08.456 --> 00:14:10.886
and here is the technique
we used in "Bananas."

279
00:14:14.386 --> 00:14:18.106
In our authoring tool,
we placed empty nodes

280
00:14:18.106 --> 00:14:21.416
at different locations
in the scene.

281
00:14:21.606 --> 00:14:24.296
We then use a [inaudible]
of time

282
00:14:24.896 --> 00:14:26.306
to interpolate these values.

283
00:14:26.736 --> 00:14:29.546
It's a smooth parametric
curve that goes

284
00:14:29.546 --> 00:14:31.026
through each of these locations.

285
00:14:31.156 --> 00:14:33.956
And then moving the
character is just as easy

286
00:14:34.716 --> 00:14:37.016
as evaluating this function

287
00:14:37.016 --> 00:14:42.396
at different times,
between zero and one.

288
00:14:42.396 --> 00:14:45.106
And for the camera, when the
character goes to the right,

289
00:14:45.416 --> 00:14:49.056
we simply [inaudible] the
camera, and at each frame,

290
00:14:49.446 --> 00:14:54.126
we move it by 120 feet its
distance to the character.

291
00:14:55.336 --> 00:14:57.856
This gives us these nice
[inaudible] animations that's

292
00:14:57.856 --> 00:15:01.686
really pleasing when
you play the game.

293
00:14:57.856 --> 00:15:01.686
really pleasing when
you play the game.

294
00:15:01.896 --> 00:15:05.856
Note, in iOS 8 and
OS X Yosemite,

295
00:15:05.856 --> 00:15:09.006
SceneKit has an active
support for physics.

296
00:15:09.216 --> 00:15:12.046
And we use collision detection
at many places in the game -

297
00:15:12.886 --> 00:15:14.776
to make the character
stay on the path,

298
00:15:15.216 --> 00:15:17.386
to detect when we
are hit by coconuts

299
00:15:17.386 --> 00:15:19.266
and when we collect
bananas, for instance.

300
00:15:20.266 --> 00:15:21.156
How does it work?

301
00:15:21.566 --> 00:15:25.166
Well, each scene has a physics
world, which has a delegate.

302
00:15:25.306 --> 00:15:27.976
And each time a collision
occurs in the scene,

303
00:15:28.326 --> 00:15:30.826
the delegate is notified
and can react.

304
00:15:31.656 --> 00:15:35.066
We can also explicitly perform
ray tests, and that what we use

305
00:15:35.066 --> 00:15:39.596
to compute is the
altitude of the character.

306
00:15:39.596 --> 00:15:43.776
So we cast a ray and compute the
intersection between that ray

307
00:15:43.776 --> 00:15:48.346
and the ground to calculate
the altitude of the character.

308
00:15:50.926 --> 00:15:55.636
Animating items is different
than animating a character.

309
00:15:55.926 --> 00:15:59.176
For items such as the
bananas, we use actions

310
00:15:59.176 --> 00:16:01.616
that was presented in
the previous session,

311
00:15:59.176 --> 00:16:01.616
that was presented in
the previous session,

312
00:16:01.696 --> 00:16:04.966
that really easy to
manipulate programmatically.

313
00:16:09.266 --> 00:16:11.126
So here's the lighting
in "Bananas."

314
00:16:11.716 --> 00:16:14.096
As you can see, we have objects

315
00:16:14.096 --> 00:16:16.006
that aren't affected
by any light.

316
00:16:16.276 --> 00:16:17.866
They use a constant
lighting model.

317
00:16:18.866 --> 00:16:22.166
For all the other objects in the
scene, we add an ambient light,

318
00:16:22.166 --> 00:16:24.326
so it's very ambient
when it's all black.

319
00:16:25.506 --> 00:16:27.586
Next, we have the
directional key light.

320
00:16:27.586 --> 00:16:33.056
And under there directional
backlight, to add more contrast.

321
00:16:34.036 --> 00:16:37.016
Finally, for torches
and lava flows,

322
00:16:37.016 --> 00:16:39.106
we have only directional lights.

323
00:16:39.656 --> 00:16:44.976
With this dynamic lighting,
we also want shadows,

324
00:16:44.976 --> 00:16:47.426
and we have multiple
techniques in "Bananas."

325
00:16:47.606 --> 00:16:49.006
First, static shadows.

326
00:16:50.566 --> 00:16:53.516
Static shadows are suitable for
objects that aren't animated

327
00:16:53.516 --> 00:16:55.426
in the scene, such
as the palm trees.

328
00:16:57.076 --> 00:16:59.096
Static shadows are
baked into textures,

329
00:16:59.566 --> 00:17:02.236
which means that they
are rendered offline

330
00:16:59.566 --> 00:17:02.236
which means that they
are rendered offline

331
00:17:02.236 --> 00:17:03.256
in an authoring tool.

332
00:17:03.716 --> 00:17:06.536
And that's why they are
generally very complex

333
00:17:06.536 --> 00:17:07.106
and detailed.

334
00:17:08.886 --> 00:17:12.746
Setting a static shadow is
as simple as setting an image

335
00:17:13.056 --> 00:17:15.046
to the multiplied
property of a material.

336
00:17:16.316 --> 00:17:18.746
But we also have
dynamic shadows,

337
00:17:18.856 --> 00:17:20.915
for objects that move,
such as a character.

338
00:17:22.106 --> 00:17:24.146
For dynamic shadows,
we use shadow maps.

339
00:17:24.586 --> 00:17:27.906
These are real-time shadows and
suitable for animated objects.

340
00:17:28.165 --> 00:17:31.016
And making your light
cast shadows is as simple

341
00:17:31.246 --> 00:17:33.566
as setting a property.

342
00:17:33.566 --> 00:17:35.946
Next, of course you
can mix techniques

343
00:17:35.946 --> 00:17:38.456
and use dynamic and
static shadows.

344
00:17:39.366 --> 00:17:42.006
After you make your
light cast shadows,

345
00:17:42.466 --> 00:17:47.726
you can simply exclude nodes
that are using static shadows,

346
00:17:48.016 --> 00:17:51.106
so that they don't
cast dynamic shadows.

347
00:17:51.846 --> 00:17:55.576
This can also be achieved
by using categoryBitMasks.

348
00:17:56.026 --> 00:18:00.986
You use exclusive masks
on the light and nodes

349
00:17:56.026 --> 00:18:00.986
You use exclusive masks
on the light and nodes

350
00:18:00.986 --> 00:18:02.136
that don't cast shadows.

351
00:18:04.616 --> 00:18:08.566
So this is one example of
dynamic shadows, but we have one

352
00:18:08.566 --> 00:18:11.806
on other, which we
call projected shadows.

353
00:18:12.446 --> 00:18:15.716
Projected shadows are
real-time as well,

354
00:18:16.316 --> 00:18:17.416
but they are simplified,

355
00:18:17.556 --> 00:18:19.916
and they are very suitable
for low-end devices.

356
00:18:21.276 --> 00:18:23.666
Using projected shadows is done

357
00:18:23.836 --> 00:18:26.306
by using the modulated
shadow mode.

358
00:18:27.696 --> 00:18:30.466
You set an image to the
gobo property of a light,

359
00:18:30.466 --> 00:18:32.806
and then every object
that is lit

360
00:18:33.116 --> 00:18:38.076
with this light has this
image projected on it.

361
00:18:38.326 --> 00:18:44.946
So in "Bananas," to make the
floor only receive this image,

362
00:18:45.006 --> 00:18:47.186
we use a categoryBitMask.

363
00:18:48.806 --> 00:18:50.956
Next, particle systems.

364
00:18:51.636 --> 00:18:54.226
We use particle systems
extensively in "Bananas."

365
00:18:54.376 --> 00:18:57.326
We use them for torches and
when the character walks.

366
00:18:58.696 --> 00:19:00.956
Using particle system
is real easy.

367
00:18:58.696 --> 00:19:00.956
Using particle system
is real easy.

368
00:19:01.096 --> 00:19:03.366
All you have to do is
load a particle system

369
00:19:03.366 --> 00:19:05.246
from a file and add
it to a node.

370
00:19:06.326 --> 00:19:08.416
[Inaudible] particle
system of dynamic,

371
00:19:08.556 --> 00:19:11.856
we can make the character emit
a lot of dirt when she runs

372
00:19:12.336 --> 00:19:14.436
and emit nothing
when she stands idle.

373
00:19:14.916 --> 00:19:20.466
We also have some nice visual
improvements in "Bananas."

374
00:19:21.266 --> 00:19:23.256
We use geometry animation
for the vines,

375
00:19:23.856 --> 00:19:26.546
and we use texture animation
for the lava and the volcano.

376
00:19:27.036 --> 00:19:30.336
You might have seen that smoke
is emitted by the volcano,

377
00:19:30.746 --> 00:19:33.646
and that the lava
flow is animated.

378
00:19:33.646 --> 00:19:36.576
This is done using
shader modifiers.

379
00:19:36.576 --> 00:19:40.016
What we do is we have
a shader modifier

380
00:19:40.256 --> 00:19:43.556
that continuously updates
the texture coordinates

381
00:19:43.556 --> 00:19:45.006
of the lava and the volcano.

382
00:19:45.756 --> 00:19:46.646
This is really simple.

383
00:19:48.156 --> 00:19:51.406
Next, we have some
visual postprocessing.

384
00:19:51.626 --> 00:19:54.276
We use SCNTechnique,
which is new this year

385
00:19:54.796 --> 00:19:58.526
and that lets us achieve color
effects and image deformation.

386
00:19:59.156 --> 00:20:01.536
We use that in "Bananas"
when we launch the game

387
00:19:59.156 --> 00:20:01.536
We use that in "Bananas"
when we launch the game

388
00:20:01.536 --> 00:20:03.826
to have this nice
grayscale effect.

389
00:20:05.536 --> 00:20:07.506
We also use SpriteKit overlays.

390
00:20:07.716 --> 00:20:09.676
SpriteKit overlays
are really nice,

391
00:20:09.676 --> 00:20:11.616
because they are cross-platform.

392
00:20:11.616 --> 00:20:13.676
They work on iOS and OS X.

393
00:20:13.676 --> 00:20:16.446
And they let you build
UIs that work everywhere.

394
00:20:16.836 --> 00:20:22.946
In SpriteKit - in "Bananas," we
use that to display a simple UI

395
00:20:22.946 --> 00:20:26.416
that shows you the final
score, and when you're playing,

396
00:20:26.746 --> 00:20:29.366
it shows you the current
time and your score.

397
00:20:29.876 --> 00:20:36.336
And finally, we use an SKAction
to play sound in the game.

398
00:20:36.546 --> 00:20:38.896
So as you saw, we
have a soundtrack

399
00:20:38.896 --> 00:20:40.176
as well as sound effects.

400
00:20:40.666 --> 00:20:44.166
So I hope we showed
you how simple it is

401
00:20:44.206 --> 00:20:46.406
to write casual 3D
games with SceneKit.

402
00:20:46.726 --> 00:20:50.066
We truly believe that
anyone, even a small team,

403
00:20:50.166 --> 00:20:51.616
can write games with SceneKit.

404
00:20:51.616 --> 00:20:53.626
And with that, I hand
it over to Thomas,

405
00:20:54.026 --> 00:20:55.286
to talk about performance.

406
00:20:55.836 --> 00:20:56.226
Thanks.

407
00:20:57.516 --> 00:21:01.436
[ Applause ]

408
00:20:57.516 --> 00:21:01.436
[ Applause ]

409
00:21:01.936 --> 00:21:02.356
>> Thank you.

410
00:21:03.606 --> 00:21:05.936
Okay. So let's talk
about performance now.

411
00:21:06.656 --> 00:21:11.296
So Xcode has some great
tools to get information

412
00:21:11.296 --> 00:21:14.146
about performance and in
particular with graphics,

413
00:21:14.146 --> 00:21:18.426
performance with graphics report
that you probably already knew.

414
00:21:19.356 --> 00:21:23.166
In this release of Xcode 6,
we are adding a new report,

415
00:21:24.036 --> 00:21:25.616
that we call the
SceneKit report,

416
00:21:25.946 --> 00:21:30.306
that will give you CPU time
information about your game.

417
00:21:31.266 --> 00:21:33.546
So this report is not available

418
00:21:33.546 --> 00:21:36.046
in the first seed
of Xcode 6 yet.

419
00:21:36.266 --> 00:21:38.806
So you will have to wait for the
next seed to have it in hand.

420
00:21:39.306 --> 00:21:41.666
But I would like to
present how it works now,

421
00:21:41.756 --> 00:21:43.176
since we are talking
about performance.

422
00:21:43.646 --> 00:21:48.426
So this report will give
you timing information

423
00:21:48.426 --> 00:21:50.876
about all the different
steps of your game loop.

424
00:21:51.426 --> 00:21:53.946
You'll remember your game
loop looks like this.

425
00:21:54.066 --> 00:21:56.956
It's made of both
callbacks that you implement

426
00:21:56.956 --> 00:22:01.576
to your game logic, and also
of SceneKit internal process,

427
00:21:56.956 --> 00:22:01.576
to your game logic, and also
of SceneKit internal process,

428
00:22:01.576 --> 00:22:04.626
like rendering itself or
the evaluation of physics

429
00:22:04.716 --> 00:22:06.536
and animations and constraints.

430
00:22:08.056 --> 00:22:14.616
So the SceneKit report will give
you many milliseconds aspect

431
00:22:14.616 --> 00:22:18.026
into those different steps.

432
00:22:18.026 --> 00:22:22.796
And this is for iOS only.

433
00:22:23.386 --> 00:22:28.686
But on OS X, we have something
equivalent, directly available

434
00:22:28.686 --> 00:22:31.766
in the SCNView with the
showsStatistics property.

435
00:22:32.936 --> 00:22:35.996
If you set this statistics
- this property to yes,

436
00:22:35.996 --> 00:22:38.886
it will display a little
overlay on top of your view

437
00:22:39.216 --> 00:22:41.746
that you can expand to get
more detailed statistics.

438
00:22:42.436 --> 00:22:45.166
And basically, it contains
the same information

439
00:22:45.746 --> 00:22:47.316
as the iOS report.

440
00:22:48.376 --> 00:22:52.516
Sorry - here it is.

441
00:22:52.646 --> 00:22:52.896
Okay.

442
00:22:54.186 --> 00:22:57.196
And so this is how
to get information.

443
00:22:57.296 --> 00:22:59.386
Now, let's see how to
analyze this information.

444
00:22:59.796 --> 00:23:03.876
If your game is running slow,
the first thing to understand is

445
00:22:59.796 --> 00:23:03.876
If your game is running slow,
the first thing to understand is

446
00:23:03.876 --> 00:23:06.666
if you are limited by
the CPU or by the GPU.

447
00:23:07.286 --> 00:23:12.896
For this, use a graphic report
and look at the third column.

448
00:23:13.846 --> 00:23:16.106
It will tell you how many
milliseconds are spent

449
00:23:16.106 --> 00:23:18.046
on the CPU side and
the GPU side.

450
00:23:18.856 --> 00:23:21.766
Both should be under 16
milliseconds if you want

451
00:23:21.766 --> 00:23:25.726
to run your game at
60 frames per second.

452
00:23:25.726 --> 00:23:28.816
Now let's say we are alerted
by the GPU, let's say.

453
00:23:29.596 --> 00:23:33.986
You can switch to the
SceneKit report to get details

454
00:23:33.986 --> 00:23:35.806
about the different steps.

455
00:23:36.016 --> 00:23:39.026
And then depending
on the returned -

456
00:23:39.086 --> 00:23:40.946
the numbers that are returned,

457
00:23:41.906 --> 00:23:43.836
there are some obvious
actions we can do.

458
00:23:43.946 --> 00:23:47.766
For example, if it says that
most of the time is spent

459
00:23:47.766 --> 00:23:50.426
in physics, you might
want to reduce the number

460
00:23:50.426 --> 00:23:51.946
of dynamic bodies in your scene

461
00:23:52.176 --> 00:23:54.326
or simplify the shape
of your bodies.

462
00:23:54.946 --> 00:23:56.966
And if it's in particles,

463
00:23:56.966 --> 00:23:59.626
you want to [inaudible]
reduce the number of emitters

464
00:23:59.626 --> 00:24:01.606
or reduce the number
of emitted particles.

465
00:23:59.626 --> 00:24:01.606
or reduce the number
of emitted particles.

466
00:24:02.136 --> 00:24:04.496
So these are the obvious things.

467
00:24:04.776 --> 00:24:08.436
Now, less obvious is
the time you spent

468
00:24:08.776 --> 00:24:12.856
in the rendering itself or when
pushing the OpenGL commands.

469
00:24:14.286 --> 00:24:17.746
Then it's very likely because
your scene requires too many

470
00:24:17.746 --> 00:24:18.826
draw calls to render.

471
00:24:20.496 --> 00:24:24.246
The number of draw calls
is something very important

472
00:24:24.246 --> 00:24:25.006
for your frame rate.

473
00:24:25.446 --> 00:24:26.836
And if you have too
many draw calls,

474
00:24:26.836 --> 00:24:30.186
it will impact your CPU time.

475
00:24:30.386 --> 00:24:33.576
You can check how many draw
calls your scene is doing

476
00:24:33.576 --> 00:24:35.436
with a SceneKit report
by looking

477
00:24:35.766 --> 00:24:37.086
at the third column here.

478
00:24:39.016 --> 00:24:40.196
This is for iOS.

479
00:24:40.376 --> 00:24:42.086
On OS X, you have
the same information

480
00:24:42.086 --> 00:24:45.956
in the statistics overlay
in the lower right corner.

481
00:24:46.966 --> 00:24:52.256
And if this number is big, and
if you are limited by the CPU,

482
00:24:52.386 --> 00:24:54.006
you want to reduce the
number of draw calls.

483
00:24:54.176 --> 00:24:56.816
And to do that, what
you can try to do is

484
00:24:56.816 --> 00:25:01.696
to flatten your static
objects into one single node.

485
00:24:56.816 --> 00:25:01.696
to flatten your static
objects into one single node.

486
00:25:01.986 --> 00:25:05.916
For example, in "Bananas," we
have many plants and palm trees

487
00:25:05.916 --> 00:25:10.106
that are static, and instead of
adding one node for every plant,

488
00:25:10.796 --> 00:25:14.006
we grouped them and flattened
them into a single node,

489
00:25:14.496 --> 00:25:17.446
so that it ends up
into a single draw call

490
00:25:17.446 --> 00:25:19.246
to render many plants
at the same time.

491
00:25:20.796 --> 00:25:23.896
To flatten objects,
you have two options.

492
00:25:25.296 --> 00:25:26.386
You can ask your artist

493
00:25:26.576 --> 00:25:29.216
to flatten directly
in the 3D software.

494
00:25:29.856 --> 00:25:31.726
3D software, great tools

495
00:25:31.726 --> 00:25:33.506
to flatten everything
into a single object.

496
00:25:34.066 --> 00:25:35.326
This is the recommended way,

497
00:25:35.326 --> 00:25:38.366
because everything
is pre-computed,

498
00:25:38.366 --> 00:25:39.586
so that nothing to
do at runtime.

499
00:25:39.586 --> 00:25:41.026
And this is obviously faster.

500
00:25:42.276 --> 00:25:45.606
Now if needed, you can also
flatten things programmatically

501
00:25:45.606 --> 00:25:49.376
with the flattenedClone
method and SCNNode.

502
00:25:50.156 --> 00:25:53.526
It will flatten the entire node
tree and return the new node

503
00:25:53.786 --> 00:25:55.966
with no time load that
render exactly the same.

504
00:25:56.556 --> 00:26:02.086
So flattening is really going to
improve the number of draw call,

505
00:25:56.556 --> 00:26:02.086
So flattening is really going to
improve the number of draw call,

506
00:26:02.086 --> 00:26:03.986
but don't flatten too much.

507
00:26:04.946 --> 00:26:08.626
Because let's say you
have a very large level.

508
00:26:08.976 --> 00:26:11.216
If you flatten everything
into a single node,

509
00:26:11.216 --> 00:26:14.996
it will end up into a giant
mesh, with millions of polygon.

510
00:26:15.556 --> 00:26:18.646
And so you will lose the
benefit of the culling

511
00:26:18.876 --> 00:26:20.536
of the objects that
are not visible.

512
00:26:20.916 --> 00:26:22.836
Your big mesh will
be always visible,

513
00:26:23.766 --> 00:26:26.826
and so you will push millions
of polygons at every frame,

514
00:26:27.266 --> 00:26:29.246
which is obviously not
good for the performance.

515
00:26:29.956 --> 00:26:34.116
And also, your huge mesh
will be lit by all the lights

516
00:26:34.386 --> 00:26:37.316
in the world, which is not
good for the performance,

517
00:26:37.316 --> 00:26:38.676
and I will explain why after.

518
00:26:39.706 --> 00:26:42.456
So here is how we
did in "Bananas."

519
00:26:43.016 --> 00:26:47.676
We first split the level
into chunks that are

520
00:26:47.676 --> 00:26:49.916
about the width of the viewport.

521
00:26:50.476 --> 00:26:56.646
That way, when the character
progress, we can directly -

522
00:26:56.806 --> 00:27:00.056
SceneKit automatically culls
the chunks that are not visible,

523
00:26:56.806 --> 00:27:00.056
SceneKit automatically culls
the chunks that are not visible,

524
00:27:00.056 --> 00:27:01.106
and so they are not pushed

525
00:27:01.106 --> 00:27:02.516
to the rendering
[inaudible] at all.

526
00:27:03.576 --> 00:27:07.106
And since almost every scene
in one chunk is flattened,

527
00:27:08.176 --> 00:27:10.346
that means that we
are only rendering one

528
00:27:10.346 --> 00:27:12.246
or two chunks at the same time.

529
00:27:12.246 --> 00:27:14.966
And so we are really pushing
a few number of draw calls

530
00:27:14.966 --> 00:27:16.676
to render to chunks
that are visible.

531
00:27:18.716 --> 00:27:20.716
So that's if you
are CPU limited.

532
00:27:21.506 --> 00:27:24.686
Now, if you are GPU
limited, again,

533
00:27:24.686 --> 00:27:27.846
you can use the graphic report
and look at the third column

534
00:27:27.846 --> 00:27:30.926
to check how many milliseconds
you are using on the GPU side.

535
00:27:31.396 --> 00:27:34.466
And if you are GPU limited,
there are two things to look at.

536
00:27:34.736 --> 00:27:37.086
The first one is a
tiler on one side.

537
00:27:37.086 --> 00:27:40.346
The second one is
the renderer/device.

538
00:27:40.906 --> 00:27:43.696
So this is here in
the second column.

539
00:27:44.586 --> 00:27:47.396
So let's consider the
renderer and device for now.

540
00:27:49.186 --> 00:27:52.776
If your renderer and device
usage are at 100 percent,

541
00:27:53.816 --> 00:27:56.896
it is very likely because you
are either fill rate limited,

542
00:27:57.366 --> 00:27:59.906
or you are using too
complex fragment shaders.

543
00:28:02.526 --> 00:28:04.436
So let's consider
first the fill rate.

544
00:28:04.676 --> 00:28:06.496
Fill rate means - if
you're fill rate limited,

545
00:28:06.496 --> 00:28:10.796
it means that you are asking
the GPU to render more pixels -

546
00:28:10.796 --> 00:28:14.276
more fragments per second
than it can actually render.

547
00:28:14.626 --> 00:28:16.366
If that happen, you
can first try to play

548
00:28:16.366 --> 00:28:18.796
with the content scale
factor of your view.

549
00:28:19.316 --> 00:28:24.196
By default, SceneKit is using
a 2x contents scale factor,

550
00:28:24.286 --> 00:28:25.446
which means fully [inaudible].

551
00:28:25.506 --> 00:28:29.396
But you can try, depending on
the device, to switch to 1x

552
00:28:29.396 --> 00:28:30.946
or any intermediate values.

553
00:28:31.336 --> 00:28:36.326
You can also try to reduce the
number of postprocess effects,

554
00:28:36.796 --> 00:28:38.416
since they are usually
full-screen effects.

555
00:28:38.816 --> 00:28:39.196
They are [inaudible].

556
00:28:39.196 --> 00:28:43.786
So typically deferred
shadows, depths of field,

557
00:28:43.786 --> 00:28:46.966
reflective floors and all
your custom postprocessing.

558
00:28:47.826 --> 00:28:49.646
Reduce that if you
are fill rate limited.

559
00:28:51.426 --> 00:28:54.196
Last, you can also try to play
with the anti-aliasing level

560
00:28:54.736 --> 00:28:57.676
by setting the antialiasingMode
property of the view to one

561
00:28:57.676 --> 00:29:02.466
of the available constants
known [inaudible] sampling 4x

562
00:28:57.676 --> 00:29:02.466
of the available constants
known [inaudible] sampling 4x

563
00:29:02.836 --> 00:29:04.136
for limited sampling.

564
00:29:04.476 --> 00:29:07.186
Note that on iOS, it's
already turned off by default,

565
00:29:07.186 --> 00:29:09.266
and it's 4x by default on OS X.

566
00:29:09.796 --> 00:29:12.206
So that's for the fill rate.

567
00:29:12.306 --> 00:29:13.966
Now, the other reason could be

568
00:29:13.966 --> 00:29:16.956
that you are using too
complex fragment shaders.

569
00:29:18.476 --> 00:29:22.076
And most of the time,
the complexity

570
00:29:22.076 --> 00:29:24.696
of your shaders directly
depends on the complexity

571
00:29:24.696 --> 00:29:26.196
of the lighting in your scene.

572
00:29:27.636 --> 00:29:31.746
So I remind that there
are two type of lightings:

573
00:29:31.876 --> 00:29:33.496
dynamic lighting
and static lighting.

574
00:29:33.526 --> 00:29:37.256
With static lighting, all the
light informations are baked

575
00:29:37.256 --> 00:29:37.916
into textures.

576
00:29:37.916 --> 00:29:40.416
So if they're super-fast,
it can look really great.

577
00:29:40.766 --> 00:29:43.576
But obviously, it only works
with objects that are static.

578
00:29:45.136 --> 00:29:48.796
And so here we focus on dynamic
lightings that we need to use

579
00:29:48.796 --> 00:29:49.726
when objects are moving.

580
00:29:51.116 --> 00:29:55.826
One thing important about lights
is their area of influence.

581
00:29:57.236 --> 00:30:01.086
So you can configure
the attenuation distance

582
00:29:57.236 --> 00:30:01.086
So you can configure
the attenuation distance

583
00:30:01.356 --> 00:30:05.146
with an attenuationEndDistance,
and beyond that distance,

584
00:30:05.146 --> 00:30:09.876
a light won't influence
the other objects.

585
00:30:09.876 --> 00:30:11.626
And this part is
really important,

586
00:30:11.626 --> 00:30:13.136
because we're getting
into performance.

587
00:30:13.316 --> 00:30:17.296
What matters is not the total
number of lights in your scene.

588
00:30:17.966 --> 00:30:21.346
It's the number of lights
that influence a given object.

589
00:30:22.126 --> 00:30:26.696
So for example, here, I have
three lights in my scene.

590
00:30:27.166 --> 00:30:30.586
But I configured the attenuation
distance so that most

591
00:30:30.586 --> 00:30:33.346
of the objects are only
affected by one light,

592
00:30:33.676 --> 00:30:35.046
or two lights, in
the worst case.

593
00:30:35.816 --> 00:30:38.456
So that means that the light
with the 1, or - sorry.

594
00:30:38.456 --> 00:30:41.446
The object with the 1
will be, the rendering

595
00:30:41.446 --> 00:30:43.056
of them will be relatively
cheap.

596
00:30:44.496 --> 00:30:45.616
The rendering of the objects

597
00:30:45.616 --> 00:30:48.976
with a 2 will be
slightly more expensive.

598
00:30:48.976 --> 00:30:51.776
But at least no objects in
that scene will be affected

599
00:30:51.776 --> 00:30:53.666
by 3 [inaudible]
lights at the same time.

600
00:30:55.396 --> 00:30:57.636
Here's how we did
it in "Bananas."

601
00:30:58.656 --> 00:31:01.266
We placed the torches
and the lava,

602
00:30:58.656 --> 00:31:01.266
We placed the torches
and the lava,

603
00:31:01.696 --> 00:31:04.346
so that when the character
progress in the game,

604
00:31:04.776 --> 00:31:07.366
it is never affected
by more than one torch

605
00:31:07.456 --> 00:31:11.186
or one lava at a time.

606
00:31:11.376 --> 00:31:15.886
Related to lighting, shadows,
shadows are also expensive.

607
00:31:15.886 --> 00:31:18.276
Again, there are two type of
shadows: dynamic and static.

608
00:31:18.686 --> 00:31:20.846
Static for this particular
scene is baked

609
00:31:21.076 --> 00:31:22.476
into textures with 3D 2s.

610
00:31:23.536 --> 00:31:25.816
And it's fast, so let's focus

611
00:31:25.816 --> 00:31:28.166
on dynamic shadows
for dynamic objects.

612
00:31:28.706 --> 00:31:32.636
The first thing to
consider is what mode

613
00:31:32.636 --> 00:31:33.876
of shadow you want to use.

614
00:31:34.266 --> 00:31:37.366
If you want to use the
real dynamic shadows

615
00:31:37.366 --> 00:31:39.386
with the 4-1 mode,
which is the default.

616
00:31:40.926 --> 00:31:45.336
And you might want to
consider projected shadows

617
00:31:45.336 --> 00:31:49.766
for low-end devices with the
right shadow image it can write

618
00:31:49.846 --> 00:31:53.006
to, and it is really fast.

619
00:31:53.116 --> 00:31:55.076
If you are using
dynamic shadows,

620
00:31:55.076 --> 00:31:56.286
there are still a
few things you can do

621
00:31:56.286 --> 00:31:57.406
to optimize the performance.

622
00:31:58.326 --> 00:32:01.076
The first thing is to play with
the size of the shadow map.

623
00:31:58.326 --> 00:32:01.076
The first thing is to play with
the size of the shadow map.

624
00:32:01.966 --> 00:32:04.606
When you are using dynamic
shadows, SceneKit computes

625
00:32:04.666 --> 00:32:06.966
such shadow maps at
every frame typically

626
00:32:06.966 --> 00:32:09.226
by rendering your scene from
the light point of view.

627
00:32:09.566 --> 00:32:14.636
So if you're fill rate limited,
by setting the shadow map size

628
00:32:14.686 --> 00:32:19.536
to a smaller size, it will
reduce the fill rate impact

629
00:32:19.686 --> 00:32:21.786
of the shadowMapSize
computation.

630
00:32:22.346 --> 00:32:27.856
You can also play with the
shadowSampleCount property

631
00:32:27.996 --> 00:32:28.906
on SCNLight.

632
00:32:29.466 --> 00:32:34.796
This inputs a lot to the
complexity of the shadow

633
00:32:34.796 --> 00:32:36.446
that is generated to
compute the shadows.

634
00:32:37.306 --> 00:32:40.496
Note that on iOS, it is
already 1x by default,

635
00:32:40.576 --> 00:32:42.266
which corresponds
to hard shadows.

636
00:32:42.686 --> 00:32:46.966
And it is 8x by default on
OS X for smooth shadows.

637
00:32:49.256 --> 00:32:55.346
Still about GPU, one more reason
to be limited by the renderer is

638
00:32:55.346 --> 00:32:59.526
when you are doing too many
texture sample in your game.

639
00:33:00.496 --> 00:33:02.506
So first thing to
check is to make sure

640
00:33:02.506 --> 00:33:05.536
that you are not using
unnecessary large textures

641
00:33:05.536 --> 00:33:06.116
in your game.

642
00:33:06.316 --> 00:33:09.536
For example, if your texture is
always rendered small on screen,

643
00:33:09.536 --> 00:33:11.286
there's no need to have
a huge texture for that.

644
00:33:12.466 --> 00:33:15.956
One more thing to do is, it's
better - if you're using tons

645
00:33:15.956 --> 00:33:19.286
of textures, it's better to
pack them into a texture atlas.

646
00:33:20.366 --> 00:33:22.916
For that, 3D softwares
have great tools

647
00:33:22.916 --> 00:33:25.266
to bake your textures
into texture atlases,

648
00:33:25.266 --> 00:33:27.066
and you can also use SpriteKit

649
00:33:27.526 --> 00:33:29.226
to generate texture
atlases for you.

650
00:33:31.236 --> 00:33:34.616
If you are using - if you need
to use very large textures,

651
00:33:34.616 --> 00:33:37.186
you can also try to
play with mipmapping.

652
00:33:38.386 --> 00:33:42.846
Mipmapping improves
the performance a lot

653
00:33:42.846 --> 00:33:45.426
when you are rendering a
large texture at a small size,

654
00:33:45.546 --> 00:33:48.096
because it will pick and
choose smaller resolution

655
00:33:48.586 --> 00:33:49.296
of your texture.

656
00:33:50.146 --> 00:33:51.926
It can also improve
the rendering

657
00:33:52.306 --> 00:33:56.256
by reducing some aliasing
effects and some Moire effects.

658
00:33:57.426 --> 00:33:58.596
It has some drawbacks, though.

659
00:33:58.766 --> 00:34:03.146
It takes more time to
load, and it can use also -

660
00:33:58.766 --> 00:34:03.146
It takes more time to
load, and it can use also -

661
00:34:03.146 --> 00:34:04.896
it uses also slightly
more memory.

662
00:34:06.136 --> 00:34:09.485
To turn on the mipmapping, just
set the mipFilter property on,

663
00:34:09.896 --> 00:34:13.886
the mipFilter property on
the [inaudible] property.

664
00:34:13.946 --> 00:34:16.926
Set it to linear to turn it
on and none to turn it off.

665
00:34:19.485 --> 00:34:24.246
OK. So that was for the
renderer and device part.

666
00:34:24.346 --> 00:34:26.976
Now, let's say you are
limited by the tiler this time.

667
00:34:27.886 --> 00:34:29.505
If you are limited by the tiler,

668
00:34:30.096 --> 00:34:33.686
that means that you are pushing
too many vertices to the GPU.

669
00:34:34.076 --> 00:34:35.436
And so by extension,
that you are -

670
00:34:35.436 --> 00:34:36.676
you have too many polygons.

671
00:34:37.275 --> 00:34:42.476
You can check how many
polygons your scene is rendering

672
00:34:42.476 --> 00:34:45.916
at every frame, with
SceneKit report here.

673
00:34:46.616 --> 00:34:47.536
This is for iOS.

674
00:34:48.206 --> 00:34:51.716
On OS X, you have the equivalent
in the statistics overlay here.

675
00:34:52.295 --> 00:34:55.246
And so if you have
too many polygons,

676
00:34:55.686 --> 00:34:58.386
obviously the first thing you
can try is to reduce the number

677
00:34:58.386 --> 00:34:59.546
of polygons in your models.

678
00:35:00.806 --> 00:35:02.656
And the second thing
you can try or so is

679
00:35:02.706 --> 00:35:04.696
to play with level of detail.

680
00:35:06.046 --> 00:35:08.826
SceneKit has some support
for level of details.

681
00:35:09.166 --> 00:35:12.996
For example, here I have
three version of the teapot -

682
00:35:12.996 --> 00:35:15.666
of these teapots with
more or less polygons.

683
00:35:16.236 --> 00:35:18.746
And so with the higher
and lower quality.

684
00:35:19.236 --> 00:35:23.226
And I can group them into a
single level of detail array

685
00:35:24.236 --> 00:35:26.046
and assign that to my geometry.

686
00:35:27.286 --> 00:35:32.506
Then SceneKit will automatically
use the right level of detail,

687
00:35:32.956 --> 00:35:36.786
depending on how big your
model is displayed onscreen.

688
00:35:37.046 --> 00:35:40.776
So you can associate to each
resolution either a distance

689
00:35:40.776 --> 00:35:47.986
from the camera or screen reduce
and to tell SceneKit what level

690
00:35:47.986 --> 00:35:49.936
of detail it should use.

691
00:35:51.396 --> 00:35:54.596
And this can help a lot to
reduce the number of polygons

692
00:35:54.596 --> 00:35:57.396
in your game, because with
this example, here for example,

693
00:35:57.716 --> 00:36:00.746
the teapots in the
background are rendered

694
00:35:57.716 --> 00:36:00.746
the teapots in the
background are rendered

695
00:36:00.746 --> 00:36:02.336
with a low resolution,

696
00:36:03.206 --> 00:36:06.576
and so most of the teapots are
using very low - a small number

697
00:36:06.576 --> 00:36:09.236
of polygons instead of having
the huge resolution all

698
00:36:09.236 --> 00:36:11.486
the time.

699
00:36:11.486 --> 00:36:15.676
So to sum up all of this, when
your game is running slow,

700
00:36:15.676 --> 00:36:16.626
you first need to understand

701
00:36:16.626 --> 00:36:18.766
if you are limited
by the CPU or GPU.

702
00:36:18.866 --> 00:36:22.526
And if it's with the GPU,
you have to check the tiler

703
00:36:22.526 --> 00:36:24.316
or the renderer and device.

704
00:36:24.546 --> 00:36:27.456
If you're limited by the CPU,
you can try to reduce the number

705
00:36:27.456 --> 00:36:32.326
of draw calls by
flattening your scenes,

706
00:36:32.846 --> 00:36:37.746
and also if you are using too
- if your time is spent, sorry,

707
00:36:37.746 --> 00:36:42.066
in physics or animations,
you can try to reduce that.

708
00:36:42.066 --> 00:36:44.556
If you are limited by the tiler,
you can try to play with level

709
00:36:44.556 --> 00:36:46.266
of details to reduce
the number of polygons,

710
00:36:46.516 --> 00:36:49.476
and you can also try to split
your scene in smaller chunks

711
00:36:49.786 --> 00:36:50.976
to alleviate the culling.

712
00:36:52.296 --> 00:36:54.376
If you're limited by
the renderer or device,

713
00:36:54.726 --> 00:36:58.416
you can try to simplify
your materials.

714
00:36:58.676 --> 00:37:00.966
It will end up being
simpler shaders.

715
00:36:58.676 --> 00:37:00.966
It will end up being
simpler shaders.

716
00:37:01.676 --> 00:37:05.086
You can simplify your
lighting, try to reduce the size

717
00:37:05.086 --> 00:37:07.446
of fill textures and try
to turn on mipmapping

718
00:37:07.446 --> 00:37:08.836
if you are using large textures.

719
00:37:09.286 --> 00:37:11.496
And if you are fill rate
limited, you can also try

720
00:37:11.496 --> 00:37:13.816
to reduce the number of
full-screen postprocess.

721
00:37:15.276 --> 00:37:18.496
Now some more, other
performance notes.

722
00:37:20.066 --> 00:37:21.546
First, about sharing.

723
00:37:22.816 --> 00:37:25.486
When you copy a node
in SceneKit,

724
00:37:26.116 --> 00:37:29.276
by default it shares
the attributes.

725
00:37:30.196 --> 00:37:32.456
So this is ideal
for the performance.

726
00:37:32.936 --> 00:37:38.416
But now, let's say you want to
modify NodeA.GeometryA.Material.

727
00:37:39.396 --> 00:37:42.466
It will also modify
the color of Node B.

728
00:37:42.796 --> 00:37:44.356
And so this is a common pitfall.

729
00:37:44.356 --> 00:37:46.136
If it's what you
want, that's perfect.

730
00:37:46.416 --> 00:37:49.216
Now, if you want a
different material for Node B,

731
00:37:49.636 --> 00:37:53.676
what you have to do first is
to copy the geometry as well.

732
00:37:54.706 --> 00:37:56.756
And see, the geometry
is immutable,

733
00:37:56.756 --> 00:38:01.016
it is relatively cheap,
because no geometry data is

734
00:37:56.756 --> 00:38:01.016
it is relatively cheap,
because no geometry data is

735
00:38:01.016 --> 00:38:02.096
actually copied.

736
00:38:02.266 --> 00:38:02.986
It's just shared.

737
00:38:03.536 --> 00:38:07.206
And then you can just simply
copy the material as well,

738
00:38:07.386 --> 00:38:10.616
and now you can modify Material
A and Material B independently

739
00:38:10.616 --> 00:38:13.356
to have a different material
colors for your objects.

740
00:38:15.756 --> 00:38:18.736
Another note, this
time about preloading.

741
00:38:20.276 --> 00:38:24.546
By default, SceneKit
will load the information

742
00:38:24.546 --> 00:38:26.406
on the GPU when needed.

743
00:38:26.516 --> 00:38:29.116
That means that when your
objects are never rendered,

744
00:38:29.306 --> 00:38:30.836
nothing is pushed to the GPU.

745
00:38:31.196 --> 00:38:33.586
And the first time an
object appears onscreen,

746
00:38:33.906 --> 00:38:36.756
we compute everything the GPU
needs to render that object.

747
00:38:37.336 --> 00:38:39.876
And depending on the
complexity of this object,

748
00:38:40.466 --> 00:38:43.446
it can take some time, and in
some cases, it can make you

749
00:38:43.446 --> 00:38:46.726
to miss some frame and so
suffer from frame drops.

750
00:38:48.036 --> 00:38:51.786
To avoid that, you can preload
your objects, if you want,

751
00:38:51.856 --> 00:38:54.056
with the prepareObjects
withCompletionHandler

752
00:38:54.416 --> 00:38:55.316
on SCNView.

753
00:38:56.386 --> 00:38:59.956
You can pass to this
method the following object.

754
00:39:01.406 --> 00:39:03.076
If you pass a material instance,

755
00:39:03.406 --> 00:39:05.596
SceneKit will pre-compute
all the textures

756
00:39:06.246 --> 00:39:08.066
that are referenced
by this material.

757
00:39:09.176 --> 00:39:11.016
If you pass the geometry,

758
00:39:11.646 --> 00:39:13.716
it will pre-compute all
the geometry buffers -

759
00:39:13.716 --> 00:39:17.186
like the vertices, no more than
texture coordinates - and also,

760
00:39:17.186 --> 00:39:19.556
all the materials that are
referenced by this geometry.

761
00:39:20.876 --> 00:39:25.066
If you pass a node, it will
preload the entire node tree,

762
00:39:25.476 --> 00:39:27.016
including all the geometries

763
00:39:27.016 --> 00:39:28.186
that are attached
to these nodes.

764
00:39:29.256 --> 00:39:32.616
And last, if you pass the entire
scene, it can do even more.

765
00:39:33.266 --> 00:39:36.056
It will preload the node
tree, but also all the shaders

766
00:39:36.236 --> 00:39:38.326
that are needed to
render the objects.

767
00:39:39.196 --> 00:39:42.966
It only works when you pass a
scene, because SceneKit needs

768
00:39:42.966 --> 00:39:45.586
to know how many lights
you have in your scene

769
00:39:45.776 --> 00:39:47.476
to pre-compute the
right shaders.

770
00:39:47.706 --> 00:39:51.476
In "Bananas," for
example, at launch,

771
00:39:51.636 --> 00:39:53.226
we preload the entire scene

772
00:39:53.226 --> 00:39:56.676
to have almost all our
shaders directly ready

773
00:39:56.776 --> 00:39:59.416
when the game starts.

774
00:39:59.416 --> 00:40:02.886
Okay. Some notes about custom
tools and workflow now.

775
00:39:59.416 --> 00:40:02.886
Okay. Some notes about custom
tools and workflow now.

776
00:40:03.526 --> 00:40:06.606
So I'm already presented how

777
00:40:06.606 --> 00:40:09.136
to manage your assets
in assets catalogs.

778
00:40:10.116 --> 00:40:11.946
But at some point,
you may want to sort

779
00:40:11.946 --> 00:40:14.586
of customize your workflow.

780
00:40:15.266 --> 00:40:17.226
By, for example,
building your own tools

781
00:40:17.226 --> 00:40:18.656
that we process your assets,

782
00:40:19.066 --> 00:40:21.186
or having your own tools
to debug your game.

783
00:40:22.126 --> 00:40:26.776
And for this, SceneKit
provides some APIs to help you.

784
00:40:26.906 --> 00:40:29.346
The first one is archiving.

785
00:40:30.716 --> 00:40:32.676
Now, this is new
in this release.

786
00:40:33.126 --> 00:40:35.876
All the objects of
the scene graph

787
00:40:36.126 --> 00:40:39.296
of the API conforms
to NSSecureCoding.

788
00:40:39.866 --> 00:40:44.086
So that allows you to
archive whatever object,

789
00:40:44.086 --> 00:40:47.916
an archive with a [inaudible]
NSKeyedArchiver, for example.

790
00:40:49.436 --> 00:40:53.006
SceneKit also allows you to
export your scene as COLLADA.

791
00:40:53.566 --> 00:40:58.476
And here, the advantage is
that you can export to COLLADA

792
00:40:58.476 --> 00:41:00.536
and import it back
to a 3D software.

793
00:40:58.476 --> 00:41:00.536
and import it back
to a 3D software.

794
00:41:01.766 --> 00:41:04.366
However, note that only a subset

795
00:41:04.426 --> 00:41:06.756
of SceneKit can be
exported to COLLADA.

796
00:41:07.776 --> 00:41:11.026
If we compare both, so
the first difference is

797
00:41:11.026 --> 00:41:14.396
that archives can be
directly loaded on iOS,

798
00:41:14.926 --> 00:41:17.796
although COLLADA files need
to go through Xcode first

799
00:41:17.796 --> 00:41:19.366
if you want to load them on iOS.

800
00:41:21.456 --> 00:41:26.496
Then you can import back COLLADA
files to any 3D software,

801
00:41:26.496 --> 00:41:29.316
but obviously, you can't
import SceneKit archives.

802
00:41:30.856 --> 00:41:33.396
Both report the scene
graph basics,

803
00:41:33.666 --> 00:41:37.736
like the node hierarchies, the
node names, the geometries,

804
00:41:37.736 --> 00:41:39.656
all the materials
and the animations.

805
00:41:39.776 --> 00:41:40.646
They work for both.

806
00:41:41.666 --> 00:41:46.356
But advanced features like
actions, physics, particles

807
00:41:46.356 --> 00:41:50.096
and even custom shaders,
everything is archived -

808
00:41:50.406 --> 00:41:53.976
works with archive but not
in - supported by COLLADA.

809
00:41:57.216 --> 00:41:58.106
One more note.

810
00:41:58.216 --> 00:41:59.776
As mentioned in the
previous session,

811
00:41:59.876 --> 00:42:01.726
SceneKit is now fully
[inaudible] with JavaScript.

812
00:41:59.876 --> 00:42:01.726
SceneKit is now fully
[inaudible] with JavaScript.

813
00:42:02.406 --> 00:42:04.836
This can be really
helpful for your -

814
00:42:04.836 --> 00:42:06.286
if you want to customize
your workflow

815
00:42:06.646 --> 00:42:12.636
or add debug tools
to debug your games.

816
00:42:12.636 --> 00:42:16.856
It's [inaudible]
with JavaScript call.

817
00:42:17.656 --> 00:42:21.136
And so the "Bananas" sample
code we showed in our -

818
00:42:21.236 --> 00:42:23.726
here is available on
the developer website.

819
00:42:24.136 --> 00:42:26.776
We also have three other
sample codes available:

820
00:42:27.346 --> 00:42:30.606
the little car demo we showed
in the previous session,

821
00:42:31.136 --> 00:42:33.646
the demo that was shown
in the state of the union,

822
00:42:34.586 --> 00:42:37.976
and the 3D slide that was
shown in the previous session

823
00:42:38.226 --> 00:42:39.746
that is for OS X only.

824
00:42:42.056 --> 00:42:45.796
For more information, please
contact our evangelists,

825
00:42:45.986 --> 00:42:47.786
Allan Schaffer and
Filip Iliescu.

826
00:42:48.726 --> 00:42:51.536
We have new gorgeous
documentation available

827
00:42:51.536 --> 00:42:52.886
on the developer
website, as well.

828
00:42:54.026 --> 00:42:57.056
And we have a dedicated
forum for SceneKit

829
00:42:57.356 --> 00:42:59.156
on devforums.apple.com.

830
00:42:59.156 --> 00:43:03.206
Don't hesitate to ask
your questions there.

831
00:42:59.156 --> 00:43:03.206
Don't hesitate to ask
your questions there.

832
00:43:03.386 --> 00:43:04.796
Some related sessions.

833
00:43:05.956 --> 00:43:08.326
So, obviously, the
previous sessions about

834
00:43:08.326 --> 00:43:09.226
"What's New in SceneKit.

835
00:43:09.636 --> 00:43:13.516
Also have a look to
the SpriteKit sessions,

836
00:43:13.516 --> 00:43:16.746
since both can work well
together to achieve great stuff.

837
00:43:16.746 --> 00:43:16.976
Thank you.

838
00:43:17.516 --> 00:43:20.500
[ Applause ]
