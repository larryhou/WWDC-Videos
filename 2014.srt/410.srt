
1
00:00:13.136 --> 00:00:13.976
>> Hello, everyone.

2
00:00:14.516 --> 00:00:19.106
[ Applause ]

3
00:00:19.606 --> 00:00:20.176
How's it going?

4
00:00:20.276 --> 00:00:23.706
I heard the bash was
pretty amazing last night,

5
00:00:23.786 --> 00:00:25.766
and I'm sure a lot
of you are hungover

6
00:00:26.186 --> 00:00:28.776
so I'll speak really
softly to soothe it.

7
00:00:29.396 --> 00:00:30.336
Nah, just kidding.

8
00:00:30.546 --> 00:00:31.506
There's no mercy here.

9
00:00:31.766 --> 00:00:33.256
Let's get right started.

10
00:00:33.646 --> 00:00:35.966
We have a lot of great
content for you this morning.

11
00:00:36.926 --> 00:00:40.556
You may have heard that Apple
released a new programming

12
00:00:40.556 --> 00:00:41.416
language this week.

13
00:00:42.026 --> 00:00:45.156
It's called Swift, apparently,
and it's the new language

14
00:00:45.156 --> 00:00:47.176
for the Cocoa and
Cocoa Touch platforms.

15
00:00:47.616 --> 00:00:50.356
It's a language we totally
love and it feels just awesome.

16
00:00:50.776 --> 00:00:54.346
And what's even better is that
the tools you know and love,

17
00:00:54.416 --> 00:00:57.196
the Xcode you know and love, the
source editor you know and love,

18
00:00:57.476 --> 00:01:01.256
they all just feel great, and
the debugger you know and love,

19
00:00:57.476 --> 00:01:01.256
they all just feel great, and
the debugger you know and love,

20
00:01:01.526 --> 00:01:04.946
LLDB, also feels just great.

21
00:01:06.736 --> 00:01:09.976
The thing is, you've
heard about tools

22
00:01:10.036 --> 00:01:12.636
that can help you explore Swift.

23
00:01:13.446 --> 00:01:17.376
One of them, one of them that is
not usually thought of as a tool

24
00:01:17.376 --> 00:01:20.166
for exploration is the debugger.

25
00:01:21.096 --> 00:01:23.766
The debugger has
the unique property

26
00:01:24.116 --> 00:01:27.646
that it can help you explore in
the context of your application.

27
00:01:28.416 --> 00:01:31.286
Most of you probably do have
apps and those were written

28
00:01:31.286 --> 00:01:34.656
in Objective-C and you might
have started off things

29
00:01:34.656 --> 00:01:35.456
with features.

30
00:01:35.966 --> 00:01:39.256
So, what you can do is you can
code some Swift inside your

31
00:01:39.256 --> 00:01:43.076
application and you can use
the debugger to help you step

32
00:01:43.076 --> 00:01:45.656
through your code, look
at your data and figure

33
00:01:45.656 --> 00:01:49.296
out how your fancy new Swift
features are interacting

34
00:01:49.296 --> 00:01:50.486
with your existing code base.

35
00:01:51.396 --> 00:01:55.386
And of course, if it ever
happened that there were bugs

36
00:01:55.516 --> 00:01:58.466
in your code, you could
actually use the debugger

37
00:01:58.466 --> 00:02:00.186
to be productive to fix them.

38
00:01:58.466 --> 00:02:00.186
to be productive to fix them.

39
00:02:00.816 --> 00:02:05.986
We have a lot of stuff to cover.

40
00:02:06.266 --> 00:02:10.276
We're going to talk about
some Swift types in LLDB.

41
00:02:10.276 --> 00:02:13.146
We're going to talk
about optional types,

42
00:02:13.546 --> 00:02:15.606
protocols and generics.

43
00:02:16.086 --> 00:02:19.196
These are all categories of
types that Swift introduces.

44
00:02:19.566 --> 00:02:22.046
What can you expect when
you're debugging your code

45
00:02:22.046 --> 00:02:23.236
and you try to use this?

46
00:02:24.466 --> 00:02:27.226
We're going to talk about
the mix and match situation

47
00:02:27.506 --> 00:02:30.046
where you have some Objective-C
code and some Swift code

48
00:02:30.046 --> 00:02:32.316
that are interoperating
together and you have

49
00:02:32.356 --> 00:02:34.716
to debug the result of that.

50
00:02:35.126 --> 00:02:36.496
We're going to cover stepping.

51
00:02:37.196 --> 00:02:39.576
We're going to talk
about data formatters

52
00:02:39.706 --> 00:02:42.646
and how you can expect data
formatters to work in Swift.

53
00:02:42.646 --> 00:02:45.966
And we're going to start
with name uniqueness,

54
00:02:46.286 --> 00:02:50.476
explain how Swift solves name
clashes in your, in your code

55
00:02:50.476 --> 00:02:53.016
between different frameworks
and libraries and from there,

56
00:02:53.016 --> 00:02:56.366
we're going to see how that very
same feature also helps make

57
00:02:56.416 --> 00:02:57.516
debugging awesome.

58
00:02:59.636 --> 00:03:01.566
Optional types.

59
00:02:59.636 --> 00:03:01.566
Optional types.

60
00:03:02.496 --> 00:03:05.536
Optional types introduce
a level of indirection.

61
00:03:06.346 --> 00:03:09.476
Is it something inside
the optional or is it not?

62
00:03:10.526 --> 00:03:14.956
The way I like to think of
optional types is a box.

63
00:03:15.666 --> 00:03:19.516
I got a box and it says
there's a string here.

64
00:03:20.076 --> 00:03:23.726
But I have to actually open
the box to look at the string

65
00:03:23.726 --> 00:03:27.706
and see there's a string here,
actually there's nothing here.

66
00:03:28.866 --> 00:03:32.696
In codes, that unwrapping the
box is something you have to do

67
00:03:32.786 --> 00:03:35.306
and it's called interrupting
the optional.

68
00:03:36.076 --> 00:03:37.846
LLDB helps you out.

69
00:03:37.896 --> 00:03:40.766
When you're debugging,
it will implicitly,

70
00:03:40.766 --> 00:03:44.026
automatically unwrap the
optional, open the box for you

71
00:03:44.306 --> 00:03:45.536
and show you the contents.

72
00:03:46.026 --> 00:03:48.706
And if there are no
contents, will just say nil.

73
00:03:49.406 --> 00:03:53.146
How can we expect that to look?

74
00:03:53.416 --> 00:03:56.216
Let's say we're writing code and
we create a bunch of variables.

75
00:03:56.796 --> 00:03:59.216
We create a native
Swift string optional.

76
00:03:59.766 --> 00:04:03.386
We create an NSRect as
bridge C struct optional

77
00:03:59.766 --> 00:04:03.386
We create an NSRect as
bridge C struct optional

78
00:04:03.766 --> 00:04:06.836
and we create an NSURL
optional, and we choose

79
00:04:06.836 --> 00:04:08.626
to not put anything
in the NSURL.

80
00:04:09.556 --> 00:04:12.956
The variable views will
transparently unwrap for you.

81
00:04:13.636 --> 00:04:17.026
Your string will show
just the contents

82
00:04:17.026 --> 00:04:19.856
of the string literal you
put in the, in the optional.

83
00:04:20.055 --> 00:04:21.755
The boxes open, oh,
there's a string.

84
00:04:21.956 --> 00:04:23.436
LLDB will show you the string.

85
00:04:24.136 --> 00:04:26.556
The same thing is
true for the NSRect.

86
00:04:27.066 --> 00:04:28.536
Oh, that's actually
a rectangle in there.

87
00:04:28.646 --> 00:04:31.276
I'll tell you about its
origin and its size.

88
00:04:32.146 --> 00:04:36.826
And since the NSURL happens
to be nil, we'll just say nil.

89
00:04:38.716 --> 00:04:41.776
There's a point when
this situation gets a

90
00:04:41.776 --> 00:04:42.586
little trickier.

91
00:04:43.386 --> 00:04:47.336
Since optionals are like boxes,
I can put boxes into boxes.

92
00:04:48.146 --> 00:04:50.556
It probably happened to
all of us at some point.

93
00:04:50.676 --> 00:04:52.086
We order something online

94
00:04:52.396 --> 00:04:56.096
and the shipping company sends
us a really big, bulky box.

95
00:04:56.096 --> 00:04:58.626
And then we open the
really big, bulky box

96
00:04:58.806 --> 00:05:00.306
and there's a smaller
box inside.

97
00:04:58.806 --> 00:05:00.306
and there's a smaller
box inside.

98
00:05:00.306 --> 00:05:02.556
And then there's another
smaller box inside.

99
00:05:02.556 --> 00:05:04.716
And then eventually
for all that packaging,

100
00:05:04.876 --> 00:05:07.586
all we ordered is a tiny
little thing like a clicker.

101
00:05:08.366 --> 00:05:10.606
In Swift, you can
do a similar thing

102
00:05:10.816 --> 00:05:12.746
by having nested optionals.

103
00:05:13.566 --> 00:05:15.986
In this example, we have
an optional of an optional

104
00:05:16.466 --> 00:05:19.616
and what we say is in
the outermost optional

105
00:05:19.616 --> 00:05:23.006
in the big box, we're
actually putting a smaller box,

106
00:05:23.406 --> 00:05:24.896
but the smaller box is empty.

107
00:05:26.936 --> 00:05:30.406
There's a fundamental
tension at work here.

108
00:05:30.916 --> 00:05:33.786
If I am the debugger,
I have to decide what

109
00:05:33.786 --> 00:05:34.876
to tell in this story.

110
00:05:35.156 --> 00:05:37.656
I have to decide if
I want to tell you

111
00:05:37.656 --> 00:05:41.226
that there's two boxes here
and one of them is full and one

112
00:05:41.226 --> 00:05:45.946
of them is empty, or I can just
look inside the whole layering

113
00:05:45.946 --> 00:05:48.286
of boxes and be the smart guy

114
00:05:48.286 --> 00:05:50.086
that tells you, eh,
you know what?

115
00:05:50.086 --> 00:05:51.256
There's nothing here.

116
00:05:51.256 --> 00:05:52.186
Just forget it.

117
00:05:52.186 --> 00:05:53.376
Just don't bother with it.

118
00:05:54.406 --> 00:05:58.346
By default, LLDB chooses
to be that smart guy.

119
00:05:58.726 --> 00:06:00.766
It looks inside all
the level of boxes

120
00:05:58.726 --> 00:06:00.766
It looks inside all
the level of boxes

121
00:06:01.476 --> 00:06:03.316
and it tells you, you know what?

122
00:06:03.316 --> 00:06:04.636
I looked. There's
really nothing here.

123
00:06:04.636 --> 00:06:06.296
There's no string at
the end of the day.

124
00:06:06.846 --> 00:06:12.636
But in some cases, I may
actually want to know

125
00:06:12.936 --> 00:06:14.866
that there's a box with a box

126
00:06:14.866 --> 00:06:16.876
and that the smaller box
is the one that's empty.

127
00:06:17.186 --> 00:06:19.396
Maybe it matters
for my API contact

128
00:06:19.396 --> 00:06:21.506
that that's the way things are.

129
00:06:22.076 --> 00:06:24.726
For those cases, what you want

130
00:06:24.726 --> 00:06:26.966
to be using is the
row display mode.

131
00:06:27.296 --> 00:06:29.996
Let me give you a
little background here.

132
00:06:30.786 --> 00:06:34.676
By default, LLDB has a
feature called data formatters.

133
00:06:35.496 --> 00:06:38.796
The data formatter feature is
used throughout the debugger

134
00:06:38.796 --> 00:06:42.876
when you're looking at data
to present you is no frills,

135
00:06:43.276 --> 00:06:46.556
just get me the data that
matters in my contact situation.

136
00:06:47.196 --> 00:06:49.226
But sometimes you need

137
00:06:49.226 --> 00:06:52.266
to actually see the
underlying truth

138
00:06:52.576 --> 00:06:55.846
without the debugger trying to
be smart about what to show you.

139
00:06:56.436 --> 00:06:58.626
In those situations,
what you want

140
00:06:58.626 --> 00:07:00.796
to use is this row display mode.

141
00:06:58.626 --> 00:07:00.796
to use is this row display mode.

142
00:07:01.506 --> 00:07:04.246
At the LLDB consult,
the row display,

143
00:07:04.446 --> 00:07:07.866
the show me the real guts
of my objective memory

144
00:07:07.866 --> 00:07:10.196
without formatting it
in an intelligent way,

145
00:07:10.656 --> 00:07:14.896
is invoked with the dash
dash row, or for short,

146
00:07:14.896 --> 00:07:17.596
-R option to the
expression command

147
00:07:18.066 --> 00:07:20.826
or the frame variable command.

148
00:07:21.756 --> 00:07:25.446
Some of you have probably
not used the frame variable

149
00:07:25.446 --> 00:07:26.346
command before.

150
00:07:26.896 --> 00:07:29.266
It's a little bit of
useful debugger trivia.

151
00:07:29.556 --> 00:07:33.876
There are some cases where
maybe you're debugging a really,

152
00:07:33.876 --> 00:07:38.496
really tricky situation and
you're trying to disturb

153
00:07:38.696 --> 00:07:41.216
to preserve the state
of your app as little

154
00:07:41.266 --> 00:07:42.916
as possible while
you try to figure

155
00:07:42.916 --> 00:07:44.716
out this really weird situation.

156
00:07:45.316 --> 00:07:49.906
In those cases, you want to look
at your data but you don't want

157
00:07:49.906 --> 00:07:52.566
to be running code that
could change the state

158
00:07:52.566 --> 00:07:54.026
of your app as you look at data.

159
00:07:55.106 --> 00:07:57.876
You can use the frame
variable command to say,

160
00:07:57.876 --> 00:07:58.856
"Show me one variable.

161
00:07:58.936 --> 00:08:00.266
Show me a bunch of variables.

162
00:07:58.936 --> 00:08:00.266
Show me a bunch of variables.

163
00:08:00.556 --> 00:08:04.296
Show me all my locals"
without having to execute code.

164
00:08:04.696 --> 00:08:07.246
And that is the frame
variable command.

165
00:08:08.216 --> 00:08:12.166
If you also pass it the -R
option, you get the row display.

166
00:08:12.296 --> 00:08:14.966
You get things for what they
really are under the covers.

167
00:08:15.756 --> 00:08:18.906
And if we do that to our
big box with smaller box

168
00:08:18.906 --> 00:08:20.896
with nothing inside, we see

169
00:08:20.896 --> 00:08:25.366
that the first thing LLDB
tells us is that, "Yeah,

170
00:08:25.936 --> 00:08:28.846
there is a big box and I see

171
00:08:28.846 --> 00:08:30.236
that there's something
in there."

172
00:08:30.306 --> 00:08:31.466
That's what that Some means.

173
00:08:32.346 --> 00:08:36.716
Now let me open this big box and
see exactly what is in there,

174
00:08:37.635 --> 00:08:42.946
and we see that there is a
smaller box with nothing inside.

175
00:08:43.586 --> 00:08:45.856
But it doesn't stop here.

176
00:08:46.956 --> 00:08:50.716
We told the Swift compiler
that we wanted a box

177
00:08:50.996 --> 00:08:55.146
that would fit a string, and
the Swift compiler made us a box

178
00:08:55.396 --> 00:08:56.446
that would fit a string.

179
00:08:56.936 --> 00:09:00.176
If there was a string here,
we would pretty much see that.

180
00:08:56.936 --> 00:09:00.176
If there was a string here,
we would pretty much see that.

181
00:09:00.766 --> 00:09:02.646
We would see the low-level,

182
00:09:02.646 --> 00:09:05.556
no-frills representation
of a Swift string.

183
00:09:06.796 --> 00:09:08.306
But there's no string
in this case.

184
00:09:08.856 --> 00:09:11.936
So, everything in the storage
that the compiler reserved

185
00:09:11.936 --> 00:09:13.886
for the string is zeroed

186
00:09:13.886 --> 00:09:16.086
out because there
actually is nothing.

187
00:09:20.836 --> 00:09:24.736
We've been talking
about optional types,

188
00:09:25.296 --> 00:09:28.156
but we could also talk more
in general about types.

189
00:09:29.046 --> 00:09:31.616
We could ask ourselves
the question, when we talk

190
00:09:31.616 --> 00:09:34.516
about a type, what
are we talking about?

191
00:09:35.066 --> 00:09:38.636
And that's a deep,
philosophical question.

192
00:09:38.926 --> 00:09:41.676
That's a question with
potentially a lot of answers,

193
00:09:42.566 --> 00:09:45.026
and I'm sure we would all
like to spend the rest

194
00:09:45.026 --> 00:09:47.926
of the session going back and
forth exchanging definitions

195
00:09:47.926 --> 00:09:51.786
of type, or you could just
trust me for a moment,

196
00:09:51.906 --> 00:09:54.206
I could give you a definition
that works in the context

197
00:09:54.206 --> 00:09:56.556
of the following slides,
and we could keep moving.

198
00:09:57.496 --> 00:09:59.906
Let's just do that, will we?

199
00:10:00.096 --> 00:10:04.026
I'm going to go with the idea
that a type is a classification

200
00:10:04.236 --> 00:10:07.436
that tells me, given some
data, how can I expect

201
00:10:07.526 --> 00:10:09.206
that data to be represented?

202
00:10:09.566 --> 00:10:12.866
How can I expect to be
interacting with that data?

203
00:10:12.866 --> 00:10:18.916
In a sense, I'm going to talk
about a type as if it was a hat

204
00:10:19.216 --> 00:10:20.586
that a piece of data can wear.

205
00:10:21.006 --> 00:10:24.576
A hat, data can wear a
little hat saying I'm an int,

206
00:10:25.246 --> 00:10:27.726
and our piece of data
can say, I'm a string.

207
00:10:28.506 --> 00:10:31.846
And the fancy guy down the
hall can say, I'm a UIView,

208
00:10:31.846 --> 00:10:33.206
I'm really pretty, look at me.

209
00:10:35.976 --> 00:10:40.106
The interesting thing
is unlike people's hats,

210
00:10:40.836 --> 00:10:42.486
data can have multiple types.

211
00:10:42.666 --> 00:10:46.486
The same piece of data can wear
multiple hats at the same time.

212
00:10:47.836 --> 00:10:49.156
How is that possible?

213
00:10:50.256 --> 00:10:52.976
There's a number of
ways to look at that.

214
00:10:53.076 --> 00:10:55.866
One of the ways, the one
that is actually interesting

215
00:10:55.866 --> 00:10:59.676
in the context about language
run times and debuggers is,

216
00:10:59.676 --> 00:11:02.626
for instance, the static
dynamic type distinction.

217
00:10:59.676 --> 00:11:02.626
for instance, the static
dynamic type distinction.

218
00:11:03.926 --> 00:11:08.116
We're all pretty familiar
I assume with the concept

219
00:11:08.116 --> 00:11:09.646
of declaring a variable.

220
00:11:10.076 --> 00:11:11.856
We've all done that at
one point or another.

221
00:11:12.786 --> 00:11:18.296
One of the things we do when we
declare a variable is give it a

222
00:11:18.886 --> 00:11:21.936
type, whether we do it
explicitly like in C

223
00:11:21.936 --> 00:11:26.126
or Objective-C or we let
the Swift compiler infer

224
00:11:26.126 --> 00:11:27.246
that for us.

225
00:11:27.586 --> 00:11:31.476
We declare a variable and that
variable ends up having a type.

226
00:11:32.756 --> 00:11:35.896
What does that type
do in the declaration?

227
00:11:37.306 --> 00:11:41.376
In a sense, that type is
telling the compiler to keep us,

228
00:11:41.916 --> 00:11:43.526
the code writers, honest.

229
00:11:44.666 --> 00:11:50.556
When I, when I tell the compiler
that thing is an AnyObject, I'm,

230
00:11:50.606 --> 00:11:54.396
in a sense I'm telling the
compiler, "Please make sure

231
00:11:54.546 --> 00:11:56.416
that whenever I use that object,

232
00:11:56.846 --> 00:11:59.486
I play by the rules
of any object."

233
00:12:00.176 --> 00:12:03.586
And as long as I do that,
the compiler will be happy,

234
00:12:04.636 --> 00:12:07.586
and if I break the contract,
when I told the compiler

235
00:12:07.586 --> 00:12:09.656
if this is an AnyObject,
keep me honest,

236
00:12:10.226 --> 00:12:12.046
then the compiler will complain.

237
00:12:14.496 --> 00:12:19.036
When I run time, however, things
become a little different.

238
00:12:20.426 --> 00:12:23.146
Let's say I want to
get the hash code

239
00:12:23.256 --> 00:12:25.856
for an NSURL object
or that object.

240
00:12:26.976 --> 00:12:28.616
There's a lot of different ways

241
00:12:29.276 --> 00:12:30.896
to get the hash code
for something.

242
00:12:31.966 --> 00:12:35.916
How does the system know
that when I say "url.hash",

243
00:12:36.626 --> 00:12:40.436
the implementation that I expect
is the one that will get called?

244
00:12:40.916 --> 00:12:42.196
How does that work?

245
00:12:43.256 --> 00:12:46.866
Well, that can't rely on the
fact that that's an AnyObject,

246
00:12:47.196 --> 00:12:50.556
because an any object could
potentially be almost anything.

247
00:12:51.116 --> 00:12:53.326
At that point, I could just
as well choose randomly.

248
00:12:54.516 --> 00:12:56.776
What happens is there's
a reliance

249
00:12:57.366 --> 00:12:59.576
on the runtime type
of the object.

250
00:13:00.146 --> 00:13:02.046
The system looks at the type

251
00:13:02.126 --> 00:13:05.546
that that object has while my
code is running at that moment,

252
00:13:05.816 --> 00:13:09.186
and that's called the
runtime dynamic type,

253
00:13:09.466 --> 00:13:14.316
and it uses that information to
decide which hash gets called.

254
00:13:14.386 --> 00:13:18.216
That's the magic of a
little mechanism called

255
00:13:18.296 --> 00:13:19.886
dynamic dispatch.

256
00:13:21.556 --> 00:13:25.086
So, we're here, and we
have our little URL object,

257
00:13:25.426 --> 00:13:27.176
and we're trying
to call hash on it.

258
00:13:28.486 --> 00:13:33.416
We said there's a hat on our URL
object that says "I'm a URL".

259
00:13:34.366 --> 00:13:37.996
It turns out, that's
sort of true.

260
00:13:38.116 --> 00:13:40.226
That object has ivars,
of course,

261
00:13:40.846 --> 00:13:42.956
but it also has type
information.

262
00:13:43.546 --> 00:13:46.416
For those of you
that use Objective-C,

263
00:13:46.416 --> 00:13:47.486
that would be the iSA.

264
00:13:47.916 --> 00:13:51.136
The iSA finder for that object
would be the type information.

265
00:13:52.226 --> 00:13:57.046
One of the things that the
type information tells us is

266
00:13:57.566 --> 00:14:00.866
which methods that this
objects type implement.

267
00:13:57.566 --> 00:14:00.866
which methods that this
objects type implement.

268
00:14:00.866 --> 00:14:05.646
And in this case, one of the
ones that NSURL implements,

269
00:14:05.646 --> 00:14:07.816
the example on the
slide, is hash.

270
00:14:08.646 --> 00:14:09.566
So, we found it.

271
00:14:10.026 --> 00:14:12.346
We know which hash to
call, and we're done.

272
00:14:12.626 --> 00:14:14.466
Dynamic dispatch actually works.

273
00:14:15.706 --> 00:14:19.786
What if we're trying to call
something that is not in the

274
00:14:19.786 --> 00:14:22.416
in the list of methods that
that objects type implements?

275
00:14:23.116 --> 00:14:24.856
Well, we could try
asking the base class.

276
00:14:25.436 --> 00:14:29.306
If something had the NSURL hat,

277
00:14:29.866 --> 00:14:32.376
it probably also has
the NSObject hat,

278
00:14:33.096 --> 00:14:36.946
and that means we can say,
eh, that didn't work for you

279
00:14:36.946 --> 00:14:39.996
as an NSURL, maybe that will
work for you as NSObject.

280
00:14:40.936 --> 00:14:43.846
And that's what happens
in dynamic dispatch.

281
00:14:43.956 --> 00:14:47.396
We go to the base type, we
try to find a method there,

282
00:14:47.396 --> 00:14:49.796
and if that succeeds,
then we found it.

283
00:14:50.336 --> 00:14:52.606
We can tell the method, "Hey,
here's an option for you,

284
00:14:52.606 --> 00:14:54.056
please do your thing for me.

285
00:14:54.406 --> 00:14:54.806
Thank you."

286
00:14:57.136 --> 00:15:00.446
This same concept
is also interesting

287
00:14:57.136 --> 00:15:00.446
This same concept
is also interesting

288
00:15:00.906 --> 00:15:02.726
in the context of me debugging.

289
00:15:02.726 --> 00:15:06.546
Let's say we have a
code example like that.

290
00:15:07.406 --> 00:15:10.236
We have a base class,
we have a derived class,

291
00:15:10.556 --> 00:15:14.016
which adds some information,
and we have a method.

292
00:15:14.326 --> 00:15:17.236
We have a function that takes
an object of the base class.

293
00:15:18.026 --> 00:15:21.486
We're telling the compiler in
that function, "Keep me honest

294
00:15:21.926 --> 00:15:26.016
and make sure I only do things
that are okay for me to do

295
00:15:26.276 --> 00:15:27.596
with the base class type."

296
00:15:28.226 --> 00:15:33.546
But I can call it with an object
of the derived class, can I not?

297
00:15:34.146 --> 00:15:36.036
That's perfectly okay.

298
00:15:38.016 --> 00:15:42.696
When I hit my breakpoint, the
compiler has to keep me honest,

299
00:15:43.176 --> 00:15:45.306
but the debugger doesn't
have to keep me that honest.

300
00:15:45.826 --> 00:15:47.756
Actually, the very opposite.

301
00:15:48.536 --> 00:15:52.976
I want the debugger to tell me
as much information as possible

302
00:15:52.976 --> 00:15:54.716
about that argument, X.

303
00:15:54.956 --> 00:15:59.896
I want the debugger to tell me
the dynamic type of X because on

304
00:15:59.896 --> 00:16:02.446
that dynamic type
relies the fact

305
00:15:59.896 --> 00:16:02.446
that dynamic type
relies the fact

306
00:16:02.926 --> 00:16:04.406
that I could have
more insets data,

307
00:16:04.656 --> 00:16:06.346
that I could have
changes in behavior.

308
00:16:07.096 --> 00:16:11.406
And indeed, that is exactly
what LLDB does by default.

309
00:16:12.026 --> 00:16:19.546
It shows you the dynamic
type in your variables view.

310
00:16:19.546 --> 00:16:23.256
Similar things apply
to protocols.

311
00:16:24.156 --> 00:16:26.356
In Swift, protocols are types.

312
00:16:27.436 --> 00:16:29.526
That means a number of things.

313
00:16:30.676 --> 00:16:33.326
Among them, it means that
I can declare my variables

314
00:16:33.736 --> 00:16:35.186
as of some protocol type.

315
00:16:35.706 --> 00:16:39.676
It means that I can declare
functions taking their arguments

316
00:16:39.676 --> 00:16:42.596
of protocol type or returning
object of protocol type.

317
00:16:45.356 --> 00:16:50.316
By design, objects of
protocol type are limited.

318
00:16:50.656 --> 00:16:51.866
They're constrained.

319
00:16:52.386 --> 00:16:56.526
They may only let you play
by the rules of the protocol.

320
00:16:57.876 --> 00:16:58.936
That's the whole point.

321
00:16:59.446 --> 00:17:02.566
I want to make sure
that I only do what's OK

322
00:16:59.446 --> 00:17:02.566
I want to make sure
that I only do what's OK

323
00:17:02.566 --> 00:17:04.296
to do on the protocol type.

324
00:17:05.146 --> 00:17:09.366
But again, when I'm debugging,
I want to see the full truth.

325
00:17:09.425 --> 00:17:11.616
I actually want to see
my implementing object,

326
00:17:12.286 --> 00:17:14.336
and that's what LLDB
will show you.

327
00:17:14.796 --> 00:17:17.665
Let's look at an example.

328
00:17:17.715 --> 00:17:21.586
Let's say I'm writing
an app for a zoo system

329
00:17:21.586 --> 00:17:27.076
and I'm prototyping things, so
I have a bunch of critters here.

330
00:17:27.306 --> 00:17:28.516
I have a cat and a dog.

331
00:17:28.516 --> 00:17:29.876
I don't have a dog collar

332
00:17:29.876 --> 00:17:34.806
yet because it's a
prototype but I'll get there.

333
00:17:34.986 --> 00:17:39.086
I have a function that takes
one of my creatures and asks it,

334
00:17:39.356 --> 00:17:41.346
"Could you please speak
your voice for me?"

335
00:17:41.686 --> 00:17:44.466
We can hit a breakpoint there.

336
00:17:45.086 --> 00:17:48.026
We're in a similar
situation as before.

337
00:17:48.446 --> 00:17:49.626
We declared something.

338
00:17:49.886 --> 00:17:51.576
We gave something a static type

339
00:17:51.916 --> 00:17:56.056
that is somehow abstract
compared to the real thing

340
00:17:56.056 --> 00:18:00.796
that we're probably passing
at run time, and LLDB knows

341
00:17:56.056 --> 00:18:00.796
that we're probably passing
at run time, and LLDB knows

342
00:18:00.846 --> 00:18:04.496
to figure out the dynamic
type information on our behalf

343
00:18:04.606 --> 00:18:08.396
and show us that even though
we said we wanted just any

344
00:18:08.396 --> 00:18:10.636
creature, in that
specific moment,

345
00:18:11.026 --> 00:18:14.826
while our code is executing,
what we got here is a puppy.

346
00:18:14.976 --> 00:18:17.096
And a very happy
puppy, for that matter.

347
00:18:21.776 --> 00:18:26.266
For those of you that like the
LLDB console, you may be tempted

348
00:18:26.266 --> 00:18:27.926
to try to reproduce this result.

349
00:18:29.006 --> 00:18:29.726
Be careful.

350
00:18:30.366 --> 00:18:33.016
By default, if you
just ask the debugger,

351
00:18:33.386 --> 00:18:35.966
"Can you please show me this
variable or protocol type?"

352
00:18:36.576 --> 00:18:39.566
the result you get may be
a little disappointing.

353
00:18:40.106 --> 00:18:44.526
It will probably look like that.

354
00:18:44.746 --> 00:18:45.486
What's going on?

355
00:18:45.706 --> 00:18:46.196
What is that?

356
00:18:46.236 --> 00:18:48.686
That doesn't look a
happy puppy at all.

357
00:18:49.826 --> 00:18:52.536
What is happening is you're
seeing the static type.

358
00:18:53.666 --> 00:18:58.756
We mentioned that the protocol
is somehow limiting object

359
00:18:58.836 --> 00:18:59.516
by design.

360
00:18:59.856 --> 00:19:02.696
It wants at the same
time to make sure

361
00:18:59.856 --> 00:19:02.696
It wants at the same
time to make sure

362
00:19:03.036 --> 00:19:05.846
that you only do things that
are declared in a protocol

363
00:19:06.226 --> 00:19:10.156
but you also get the dynamic
dispatching of this operations,

364
00:19:10.216 --> 00:19:12.046
the real object that
implements that.

365
00:19:12.616 --> 00:19:16.066
The result of that is what
is here on the screen.

366
00:19:17.286 --> 00:19:20.806
What you want to do is
you want to tell LLDB,

367
00:19:21.436 --> 00:19:24.026
"Please resolve the
dynamic type for me."

368
00:19:24.806 --> 00:19:28.856
The way to do that is with
the -d flag to the expression

369
00:19:28.856 --> 00:19:30.066
or frame variable command.

370
00:19:32.416 --> 00:19:35.936
That lets the debugger
resolve dynamic types.

371
00:19:37.086 --> 00:19:40.136
Now, there's two ways in
which you can ask the debugger

372
00:19:40.136 --> 00:19:41.526
to resolve dynamic types.

373
00:19:42.626 --> 00:19:45.436
There's a less restrictive
and a more restrictive way.

374
00:19:46.686 --> 00:19:49.596
Sometimes in order to
figure out the dynamic type

375
00:19:49.596 --> 00:19:53.766
of your objects, the debugger
might decide that it's best

376
00:19:54.036 --> 00:19:55.836
to run some code
under the covers

377
00:19:56.206 --> 00:20:00.016
to go ask the language run time,
"Can you help me out here?"

378
00:19:56.206 --> 00:20:00.016
to go ask the language run time,
"Can you help me out here?"

379
00:20:01.096 --> 00:20:03.376
In that most liberal
settings, the run,

380
00:20:03.416 --> 00:20:07.486
the Allow Run Target R Here
setting, you tell the debugger,

381
00:20:07.596 --> 00:20:09.916
"OK, you can go run
some code off for me.

382
00:20:09.916 --> 00:20:12.496
I don't think there's going to
be any problem if you do that.

383
00:20:12.496 --> 00:20:14.716
Just let me know the dynamic
type when you're done, please."

384
00:20:15.856 --> 00:20:18.726
Another setting is
Do Not Run Target.

385
00:20:19.356 --> 00:20:21.586
In Do Not, in Do
Not Run Target mode,

386
00:20:21.976 --> 00:20:24.926
you're telling the debugger,
"I'd really like to know

387
00:20:24.926 --> 00:20:29.616
about the dynamic type of this
thing but I prefer you not

388
00:20:29.616 --> 00:20:31.436
to run any code that might
interfere with my process.

389
00:20:32.006 --> 00:20:35.436
If it turns out that you have to
do that then just don't tell me

390
00:20:35.436 --> 00:20:36.916
about the dynamic
type, that's OK.

391
00:20:37.036 --> 00:20:37.786
I'll understand."

392
00:20:39.146 --> 00:20:41.716
Limitation is that, information

393
00:20:41.716 --> 00:20:44.566
to resolve the type will
be passed along your data.

394
00:20:45.086 --> 00:20:47.766
You will call a generic
function with an int and you'll,

395
00:20:47.766 --> 00:20:50.766
your int data will be passed
through the function as well

396
00:20:50.766 --> 00:20:53.786
as metadata that will tell
the language, "This is a,

397
00:20:53.786 --> 00:20:55.366
this is an int you're
dealing with."

398
00:20:56.016 --> 00:20:58.926
LLDB can use that
same information

399
00:20:58.926 --> 00:21:00.816
to reconstruct the
meaning of your code.

400
00:20:58.926 --> 00:21:00.816
to reconstruct the
meaning of your code.

401
00:21:00.816 --> 00:21:04.566
How does that look like?

402
00:21:05.846 --> 00:21:09.976
Let's say we have a protocol
for producing arbitrary things,

403
00:21:10.956 --> 00:21:12.846
and then we have
a concrete class

404
00:21:12.966 --> 00:21:15.076
that implements the
protocol, that conforms

405
00:21:15.106 --> 00:21:18.026
to that protocol and
it produces ints.

406
00:21:18.496 --> 00:21:23.066
And then we have a function that
says, "I can accept any producer

407
00:21:23.066 --> 00:21:26.956
of things as long as what
they produce is int."

408
00:21:27.216 --> 00:21:31.656
If I hit a break point, I expect
to see my generics resolved.

409
00:21:33.196 --> 00:21:34.436
That is indeed what happens.

410
00:21:35.346 --> 00:21:36.346
But how does it work?

411
00:21:37.796 --> 00:21:41.826
Well, LLDB looks at your
function and it realizes

412
00:21:41.866 --> 00:21:45.286
that your function takes
a generic argument, P.

413
00:21:45.946 --> 00:21:50.026
So, LLDB has to look for type
information to resolve P.

414
00:21:50.746 --> 00:21:51.606
And it finds it.

415
00:21:52.296 --> 00:21:54.746
When you debug generic code,
you're going to see a lot

416
00:21:54.746 --> 00:21:58.646
of this $ with .type
.name special variables.

417
00:21:59.196 --> 00:22:02.826
Those special variables carry
the generic type information.

418
00:21:59.196 --> 00:22:02.826
Those special variables carry
the generic type information.

419
00:22:02.826 --> 00:22:05.756
They're the Swift object
metadata for your generic type.

420
00:22:06.776 --> 00:22:10.716
Armed with that knowledge,
when LLDB sees the argument

421
00:22:10.716 --> 00:22:15.026
of type P, it knows to actually
use the generic type information

422
00:22:15.376 --> 00:22:18.506
to resolve it to its
actual dynamic type.

423
00:22:22.836 --> 00:22:27.096
We talked about a few
rules about how protocols

424
00:22:27.136 --> 00:22:28.746
and generics behave in Swift.

425
00:22:29.296 --> 00:22:32.606
Those are general rules
and for the most part,

426
00:22:33.016 --> 00:22:34.906
they apply to debug builds.

427
00:22:35.456 --> 00:22:39.016
A debug build of your
code is a very, very,

428
00:22:39.016 --> 00:22:42.416
very literal translation
of the code you just wrote

429
00:22:42.766 --> 00:22:45.166
into native executable code.

430
00:22:46.096 --> 00:22:49.886
The fact that it's very literal
a translation is actually good

431
00:22:49.956 --> 00:22:51.006
thing for debuggability

432
00:22:51.076 --> 00:22:53.096
and that's why they're
called debug builds.

433
00:22:53.956 --> 00:22:57.016
If my code is translated
literally as I'm debugging

434
00:22:57.016 --> 00:23:00.356
through it, it's really easy for
me to see the correspondence.

435
00:22:57.016 --> 00:23:00.356
through it, it's really easy for
me to see the correspondence.

436
00:23:00.786 --> 00:23:04.276
Evolution, evolutioning
machine code execution,

437
00:23:04.646 --> 00:23:06.676
evolutioning source
code execution.

438
00:23:06.966 --> 00:23:08.676
It's really easy for
the debugger to maintain

439
00:23:08.676 --> 00:23:10.456
that correspondence
between what you wrote

440
00:23:10.456 --> 00:23:12.486
and what is actually
going on on the bare,

441
00:23:12.826 --> 00:23:14.166
on the bare metal,
on the hardware.

442
00:23:15.256 --> 00:23:17.436
In an optimized build
of your code,

443
00:23:17.976 --> 00:23:19.956
while maintaining
the same semantics,

444
00:23:20.836 --> 00:23:22.566
the compiler is actually free

445
00:23:22.896 --> 00:23:27.546
to shuffle things a little bit
behind your back and that means

446
00:23:27.586 --> 00:23:29.006
that the literal evolution

447
00:23:29.006 --> 00:23:31.986
of machine code will
not correspond anymore

448
00:23:32.296 --> 00:23:35.126
to the same sequenced
evolution of your source code.

449
00:23:35.126 --> 00:23:38.916
There will be steps, there will
be jumps, data will not be there

450
00:23:38.916 --> 00:23:40.256
that was supposed to be there.

451
00:23:40.676 --> 00:23:45.686
As a result of that,
the first rule

452
00:23:45.686 --> 00:23:48.436
of debugging optimized
code is that you don't.

453
00:23:49.636 --> 00:23:51.216
I'm sure it's a lesson
some of you

454
00:23:51.216 --> 00:23:52.546
in the audience have
had to learn.

455
00:23:53.856 --> 00:23:56.856
You probably have apps
and you probably get bugs

456
00:23:57.196 --> 00:23:59.936
from those apps very,
very rarely, I'm sure.

457
00:24:00.846 --> 00:24:05.096
But sometimes it happens, and
the first thing you should do

458
00:24:05.096 --> 00:24:09.766
when you get one of those rare,
incoming bugs is reproduce it

459
00:24:09.766 --> 00:24:12.876
in a debug build of your app.

460
00:24:12.876 --> 00:24:17.496
Only if that doesn't work,
then, sorry, tough luck.

461
00:24:17.586 --> 00:24:19.576
You're going to have to
debug optimized code.

462
00:24:20.696 --> 00:24:23.006
All the usual caveats
apply to Swift

463
00:24:23.246 --> 00:24:26.836
and there's a couple new
ones that are specific

464
00:24:26.836 --> 00:24:28.766
to things we covered
in the previous slides.

465
00:24:30.546 --> 00:24:33.336
While in general, type
metadata is passed along,

466
00:24:34.516 --> 00:24:37.836
the Swift compiler is
free in optimized builds

467
00:24:37.946 --> 00:24:42.346
to actually specialize
away some types, some,

468
00:24:42.496 --> 00:24:47.216
your generic functions
for some specific types.

469
00:24:47.396 --> 00:24:50.886
Also, if the compiler can
understand what's going

470
00:24:50.886 --> 00:24:53.186
on with protocols and
the concrete types

471
00:24:53.186 --> 00:24:56.626
and implement them, it's
free to do devirtualization

472
00:24:57.046 --> 00:24:59.526
to skip dynamic dispatch
and directly call

473
00:24:59.526 --> 00:25:00.746
into the implementing object.

474
00:24:59.526 --> 00:25:00.746
into the implementing object.

475
00:25:05.856 --> 00:25:09.056
Objective-C isn't
really going anywhere.

476
00:25:10.546 --> 00:25:15.866
Some of you, we said, already
have apps and it's very likely

477
00:25:15.976 --> 00:25:17.506
that those are written
in Objective-C.

478
00:25:18.566 --> 00:25:21.476
But, even if you start
a brand new Swift app

479
00:25:21.606 --> 00:25:25.716
for the first time today after
this session, you're going

480
00:25:25.716 --> 00:25:28.406
to use Cocoa or Cocoa Touch.

481
00:25:28.826 --> 00:25:32.526
You're going to import
Foundation, import UIKit.

482
00:25:33.236 --> 00:25:35.976
Those frameworks are
written in Objective-C.

483
00:25:36.736 --> 00:25:40.046
That means wherever you
look around, there's going

484
00:25:40.046 --> 00:25:43.976
to be Objective-C in the
picture, and you're going

485
00:25:43.976 --> 00:25:47.656
to have to deal with
debugging mixed Swift

486
00:25:47.656 --> 00:25:49.306
and Objective-C situations.

487
00:25:49.946 --> 00:25:52.686
What can you expect
when that happens?

488
00:25:53.456 --> 00:25:55.556
What can you expect
to see in the LLDB,

489
00:25:55.556 --> 00:25:56.956
in the Xcode variables view?

490
00:25:57.326 --> 00:25:58.696
What can you expect as you try

491
00:25:58.696 --> 00:26:00.836
to evaluate expressions
in the LLDB console?

492
00:25:58.696 --> 00:26:00.836
to evaluate expressions
in the LLDB console?

493
00:26:01.206 --> 00:26:04.396
What can you expect when
you try to PO your objects?

494
00:26:04.996 --> 00:26:09.166
At the variables view, it goes

495
00:26:09.166 --> 00:26:11.596
by what's called a
most native experience.

496
00:26:12.236 --> 00:26:14.606
We'll show you data
in the language

497
00:26:14.606 --> 00:26:17.046
in which the type
was first written.

498
00:26:17.806 --> 00:26:21.176
In this case, we
see a Swift string

499
00:26:21.606 --> 00:26:26.436
and an NSString side-by-side,
and the Swift string is shown

500
00:26:26.436 --> 00:26:27.596
as a Swift string literal,

501
00:26:27.596 --> 00:26:29.346
as you would type in
Swift source code.

502
00:26:30.196 --> 00:26:32.776
The Objective-C string
literal is shown

503
00:26:32.776 --> 00:26:34.536
as an Objective-C
string literal.

504
00:26:34.866 --> 00:26:37.486
It's shown as if, as you
would type that same thing

505
00:26:37.846 --> 00:26:39.316
in Objective-C source code.

506
00:26:39.836 --> 00:26:44.756
In all cases, data
formatters will apply.

507
00:26:44.756 --> 00:26:49.916
If I'm evaluating
expressions, however,

508
00:26:50.606 --> 00:26:55.096
things become a little
more strongly separated.

509
00:26:55.826 --> 00:26:58.066
Expressions see two
separate worlds.

510
00:26:59.516 --> 00:27:02.836
Objects that exist in Swift
frames are all useable

511
00:26:59.516 --> 00:27:02.836
Objects that exist in Swift
frames are all useable

512
00:27:02.836 --> 00:27:06.246
by Swift expressions, and
the same is true for objects

513
00:27:06.246 --> 00:27:07.696
in Objective-C code frames.

514
00:27:08.216 --> 00:27:11.456
Your results, your
result variables,

515
00:27:11.876 --> 00:27:13.636
they get two separate
name spaces.

516
00:27:14.166 --> 00:27:15.726
A little background on that.

517
00:27:16.176 --> 00:27:18.386
When you type an LLDB
expression command,

518
00:27:18.746 --> 00:27:21.236
the result of that
expression is stored away

519
00:27:21.236 --> 00:27:23.616
in a debugger-generated
persistent variable,

520
00:27:24.086 --> 00:27:26.926
which you're very welcome to
reuse in subsequent expressions.

521
00:27:27.806 --> 00:27:31.076
The results of your Objective-C
expressions will get stored

522
00:27:31.076 --> 00:27:34.486
in variables named $0,
$1, $2, you get the idea,

523
00:27:34.826 --> 00:27:38.396
and the results of your Swift
expressions will be stored

524
00:27:38.396 --> 00:27:44.796
in variables names $R0,
$R1, and you get the idea.

525
00:27:44.796 --> 00:27:47.186
Let's see an example of how
this whole system works.

526
00:27:48.596 --> 00:27:50.886
We're stopped in a Cocoa frame.

527
00:27:51.316 --> 00:27:54.796
The F command tells,
tells us the frame

528
00:27:54.796 --> 00:27:56.046
where we're currently stopped.

529
00:27:56.486 --> 00:27:59.276
We type an Objective-C
expression because we're

530
00:27:59.276 --> 00:28:01.866
in Objective-C frame,
just be self.

531
00:27:59.276 --> 00:28:01.866
in Objective-C frame,
just be self.

532
00:28:02.096 --> 00:28:06.846
And we get a variable $0
that stores away self.

533
00:28:07.926 --> 00:28:13.436
Now, we step around a little bit
and we land in a Swift frame.

534
00:28:13.736 --> 00:28:18.966
Now, we like to try and use that
$0 persistent variable and we

535
00:28:18.966 --> 00:28:21.626
like to write an Objective-C
expression that involves it.

536
00:28:22.806 --> 00:28:24.636
That's not going to fly so well.

537
00:28:25.696 --> 00:28:29.306
Since we're in a Swift frame,
the Swift compiler is trying

538
00:28:29.306 --> 00:28:31.676
to compile your Swift,
your expression

539
00:28:32.426 --> 00:28:33.476
with the Swift syntax.

540
00:28:34.206 --> 00:28:37.036
But that's not Swift syntax,
that's Objective-C syntax.

541
00:28:37.406 --> 00:28:39.886
And so the compiler
gets really unhappy

542
00:28:40.186 --> 00:28:42.116
and he mentions things like,

543
00:28:42.536 --> 00:28:45.686
"Anonymous closure argument
not contained in a closure."

544
00:28:45.686 --> 00:28:48.386
OK, I must be doing
something wrong here.

545
00:28:49.136 --> 00:28:51.556
Well, what's going
on is you're trying

546
00:28:51.556 --> 00:28:53.056
to use the other language.

547
00:28:53.636 --> 00:28:57.426
And there's a way for you to do
that but you have to tell LLDB

548
00:28:57.956 --> 00:29:00.486
"Don't automatically infer
the language of my expressions

549
00:28:57.956 --> 00:29:00.486
"Don't automatically infer
the language of my expressions

550
00:29:00.526 --> 00:29:02.466
from the language from
the frame I stopped in.

551
00:29:03.846 --> 00:29:05.576
Use the language I
tell you to use."

552
00:29:06.296 --> 00:29:10.106
In this example, we're
using the -l, or the --

553
00:29:10.516 --> 00:29:13.096
language flag, that
expression command.

554
00:29:13.416 --> 00:29:16.866
And we're telling LLDB,
"Use the Objective C++

555
00:29:16.866 --> 00:29:17.876
expression evaluator.

556
00:29:17.876 --> 00:29:20.976
Use the Clang compiler
that is inside of you

557
00:29:20.976 --> 00:29:22.596
to actually parse
that expression."

558
00:29:22.596 --> 00:29:24.306
And then that works.

559
00:29:25.856 --> 00:29:26.686
But there's a caveat.

560
00:29:27.066 --> 00:29:28.006
There's always a caveat.

561
00:29:29.346 --> 00:29:31.576
Your locals will
not be available.

562
00:29:31.926 --> 00:29:35.026
Since you changed your
language, as we said before,

563
00:29:35.026 --> 00:29:36.566
locals are not available.

564
00:29:37.286 --> 00:29:42.236
PO is, in a way, similar
to the expression command,

565
00:29:42.796 --> 00:29:46.486
but it actually, once you get
the result of your expression,

566
00:29:46.946 --> 00:29:49.206
it goes back to that
most native experience

567
00:29:49.206 --> 00:29:50.846
that the variable view lives by.

568
00:29:51.546 --> 00:29:54.676
Swift objects will display
using data formatters.

569
00:29:55.486 --> 00:29:59.656
Objective-C objects will display
using their description method,

570
00:30:00.016 --> 00:30:03.286
much like they did
from before Xcode 6.

571
00:30:04.156 --> 00:30:06.646
That can get funny real quick.

572
00:30:07.276 --> 00:30:10.736
I can have a Swift class
that inherits NSObject

573
00:30:10.736 --> 00:30:13.806
and I can actually
override description

574
00:30:14.186 --> 00:30:16.016
for that class in Swift.

575
00:30:17.036 --> 00:30:18.986
But if I try to PO it in LLDB,

576
00:30:18.986 --> 00:30:22.546
LLDB will not even look
at that description.

577
00:30:22.546 --> 00:30:25.546
LLDB will use data formatters,
and that's what I'll get,

578
00:30:26.016 --> 00:30:28.076
because that's a Swift object.

579
00:30:28.926 --> 00:30:32.046
What if I actually wanted
to use my description?

580
00:30:33.116 --> 00:30:34.526
What if I actually want to use,

581
00:30:34.526 --> 00:30:36.626
see the Objective-C
side of things.

582
00:30:37.606 --> 00:30:39.386
It turns out there is a way.

583
00:30:40.336 --> 00:30:42.286
When there's a will
there's always a way.

584
00:30:42.656 --> 00:30:46.676
I can start from there
and I guess I have

585
00:30:46.676 --> 00:30:49.926
to write an expression,
and I guess I have

586
00:30:50.006 --> 00:30:52.976
to write an Objective-C
expression since I'm trying

587
00:30:52.976 --> 00:30:54.586
to get an Objective-C behavior.

588
00:30:54.976 --> 00:31:02.516
Skimming for the help for PO,
an expression, I can discover

589
00:30:54.976 --> 00:31:02.516
Skimming for the help for PO,
an expression, I can discover

590
00:31:02.516 --> 00:31:06.176
that the PO behavior is
actually triggered by a flag

591
00:31:06.216 --> 00:31:10.936
to the expression command, the
-O flag for object description.

592
00:31:12.636 --> 00:31:15.106
And so I can guess that I need

593
00:31:15.106 --> 00:31:16.826
to write an Objective-C
expression

594
00:31:17.146 --> 00:31:18.806
that gets an object's
description.

595
00:31:20.106 --> 00:31:21.446
But now I changed language.

596
00:31:22.306 --> 00:31:24.906
Now I can't use my
object local anymore.

597
00:31:26.736 --> 00:31:28.816
I can resort to using
its address.

598
00:31:29.346 --> 00:31:32.906
I know it lives somewhere
in memory and PO told me

599
00:31:32.906 --> 00:31:34.046
where it lives in memory.

600
00:31:34.086 --> 00:31:38.066
I can use that information to
go across the language barrier

601
00:31:38.116 --> 00:31:39.806
and bring my object
along with me.

602
00:31:40.366 --> 00:31:46.476
But, but I'm not using my
local type information anymore,

603
00:31:46.926 --> 00:31:47.856
so that's a number.

604
00:31:48.266 --> 00:31:50.716
For all Clang knows,
I'm asking it,

605
00:31:50.966 --> 00:31:52.276
"Can you please show
me that number?"

606
00:31:53.356 --> 00:31:56.356
I need to tell the compiler
that what I actually want

607
00:31:56.356 --> 00:31:59.866
to see is not the
number OX000-something.

608
00:32:00.196 --> 00:32:03.066
I want to see the object
of that location in memory.

609
00:32:04.386 --> 00:32:05.656
The simplest way to get there?

610
00:32:06.466 --> 00:32:11.306
Just cast to it, and
after all this magic,

611
00:32:12.816 --> 00:32:19.736
your result shows
up, just like that.

612
00:32:21.146 --> 00:32:21.736
Thank you [applause].

613
00:32:22.836 --> 00:32:23.196
Thank you.

614
00:32:25.786 --> 00:32:28.766
Let's very quickly step through
a couple stepping scenarios:

615
00:32:29.696 --> 00:32:31.026
protocols and closures.

616
00:32:31.606 --> 00:32:36.826
Let's say I set a break
point right where I'm trying

617
00:32:36.826 --> 00:32:40.466
to use one of my creature
objects and I step in,

618
00:32:40.466 --> 00:32:43.616
because I actually want to see
the implementation of that code

619
00:32:43.616 --> 00:32:45.326
and step through it and
see what's going on.

620
00:32:46.306 --> 00:32:47.926
It turns out that
that just works.

621
00:32:48.086 --> 00:32:50.066
LLDB lands right where
you would expect.

622
00:32:51.106 --> 00:32:53.066
But there's one extra
frame on the stack.

623
00:32:54.056 --> 00:32:56.336
There's a frame called
protocol witness

624
00:32:56.836 --> 00:32:59.046
for Creature.speak on the stack.

625
00:32:59.776 --> 00:33:02.676
That frame is the protocol,

626
00:32:59.776 --> 00:33:02.676
That frame is the protocol,

627
00:33:03.096 --> 00:33:05.056
is the protocol dynamic
dispatch frame.

628
00:33:05.666 --> 00:33:09.176
It's the code that the Swift
run time uses between where I,

629
00:33:09.286 --> 00:33:11.166
my code stops and when my code,

630
00:33:11.316 --> 00:33:13.226
and when the call
code starts executing

631
00:33:13.226 --> 00:33:15.406
to actually perform
dynamic dispatch.

632
00:33:16.076 --> 00:33:19.176
LLDB automatically steps
through writing through my code.

633
00:33:19.486 --> 00:33:22.966
And if I step out, the same
magic happens in reverse.

634
00:33:23.486 --> 00:33:27.326
The protocol in this frame just
disappears and I get right back

635
00:33:27.326 --> 00:33:29.136
into my code transparently.

636
00:33:29.646 --> 00:33:32.086
And I have more good
news for you.

637
00:33:32.956 --> 00:33:36.426
You can set break
points inside closures.

638
00:33:37.086 --> 00:33:40.126
You can expect LLDB to leave
your breakpoints inside our

639
00:33:40.156 --> 00:33:42.776
closure even if it's an
aligned anonymous closure.

640
00:33:42.776 --> 00:33:46.026
And that's what you'll
see in the stack.

641
00:33:46.096 --> 00:33:48.076
You'll see that since
your closure is aligned

642
00:33:48.076 --> 00:33:50.826
and anonymous, it's called
closure #1 in my call,

643
00:33:50.826 --> 00:33:52.266
in my calling function.

644
00:33:52.886 --> 00:33:56.036
You can also expect
to see your locals.

645
00:33:56.746 --> 00:33:59.396
Even those, yes, even
those $ variables

646
00:33:59.396 --> 00:34:01.606
that are automatically
generated by the compiler

647
00:33:59.396 --> 00:34:01.606
that are automatically
generated by the compiler

648
00:34:01.606 --> 00:34:02.716
and you never declared.

649
00:34:03.456 --> 00:34:04.756
Good news all over the board.

650
00:34:04.756 --> 00:34:06.166
First topic.

651
00:34:07.836 --> 00:34:12.246
Now, this topic is
really dear to my heart

652
00:34:12.636 --> 00:34:15.616
because that's what I usually
work on, data formatters.

653
00:34:17.056 --> 00:34:19.396
Data formatters are
a way in LLDB

654
00:34:19.476 --> 00:34:21.726
to improve the way
your data is shown,

655
00:34:22.136 --> 00:34:24.886
to hide implementation
details and only focus

656
00:34:24.886 --> 00:34:27.386
on the core things that matter
to you when you're debugging.

657
00:34:28.565 --> 00:34:32.146
Much like we do for
C++ and Objective-C,

658
00:34:32.146 --> 00:34:34.976
we automatically format
types in the Swift library.

659
00:34:35.576 --> 00:34:36.696
You don't have to
worry about that.

660
00:34:37.056 --> 00:34:39.176
That will happen
automatically for you.

661
00:34:39.746 --> 00:34:42.525
But the good news is that
the mechanism is pluggable.

662
00:34:43.116 --> 00:34:46.735
This is covered in great
detail in last year's session,

663
00:34:47.206 --> 00:34:50.545
which you're welcome to watch
online or on the LLDB website.

664
00:34:51.456 --> 00:34:54.106
We'll just quickly go
through an example to show

665
00:34:54.106 --> 00:34:57.606
that you can roll your own Swift
formatters much like you could

666
00:34:57.606 --> 00:34:59.156
in C++ and Objective-C.

667
00:35:00.446 --> 00:35:03.166
Let's say we have a struct that
represents a person's address

668
00:35:03.896 --> 00:35:09.286
and we try to PO my address
card represented in the struct.

669
00:35:10.636 --> 00:35:14.096
That's not a horrible
display but it looks nothing

670
00:35:14.096 --> 00:35:15.736
like an address would
look, right?

671
00:35:16.526 --> 00:35:19.666
I want to make this
more envelope-like.

672
00:35:19.996 --> 00:35:21.666
I want this to look
a little bit more

673
00:35:21.666 --> 00:35:24.476
like I was writing my
address on an envelope.

674
00:35:24.886 --> 00:35:28.396
I can do that with the
LLDB-type summary add command.

675
00:35:28.946 --> 00:35:32.376
The "type summary add" command
is that LLDB's command to say,

676
00:35:32.746 --> 00:35:34.706
"When you're showing me
a variable of this type,

677
00:35:35.116 --> 00:35:37.206
here's the at-a-glance
information I'd

678
00:35:37.206 --> 00:35:38.696
like to see represented."

679
00:35:39.216 --> 00:35:44.166
And so we can tell LLDB, "You
should use the variable's name.

680
00:35:44.796 --> 00:35:46.806
You should use the
name of the person.

681
00:35:47.206 --> 00:35:50.106
You should use the city
and separate those two

682
00:35:50.106 --> 00:35:51.656
by new lines since you're at it.

683
00:35:52.496 --> 00:35:55.036
Now, put another new line
in there for me, will you?

684
00:35:55.226 --> 00:35:56.516
And write a zip code.

685
00:35:56.946 --> 00:35:59.526
And then after a
comma and a space,

686
00:35:59.926 --> 00:36:01.166
could you please put the state."

687
00:35:59.926 --> 00:36:01.166
could you please put the state."

688
00:36:01.796 --> 00:36:03.766
This is the U.S. address
format, basically.

689
00:36:04.106 --> 00:36:07.176
And we're saying, "Use that
for the address object."

690
00:36:08.166 --> 00:36:13.406
Now, when you PO me
again, we get something

691
00:36:13.406 --> 00:36:16.026
that looks a lot more
like an actual address.

692
00:36:17.376 --> 00:36:19.056
Data formatter's
mission accomplished.

693
00:36:19.336 --> 00:36:23.616
I told you there's
always caveats.

694
00:36:23.966 --> 00:36:24.626
There's a few more.

695
00:36:26.216 --> 00:36:30.236
When you actually tell LLDB bind
this formatter to this type,

696
00:36:30.236 --> 00:36:33.276
you have to use the
fully qualified name.

697
00:36:33.746 --> 00:36:35.976
That includes the
name of the module.

698
00:36:36.136 --> 00:36:37.476
We'll talk about
that in a little bit.

699
00:36:37.716 --> 00:36:40.746
If you're writing
Python formatters,

700
00:36:41.426 --> 00:36:43.666
you want to use
SBValue.GetSummary().

701
00:36:43.666 --> 00:36:45.576
You want to ask objects
for a summary.

702
00:36:46.516 --> 00:36:49.796
Even for things that in
C or Objective-C look

703
00:36:49.796 --> 00:36:52.936
like basic types that have a
value, like an int or a float,

704
00:36:53.386 --> 00:36:56.036
in Swift there's a little
more intricacy going

705
00:36:56.036 --> 00:36:56.896
on under the hood.

706
00:36:57.346 --> 00:36:59.026
So, what you want to
show, what you want

707
00:36:59.436 --> 00:37:00.736
to ask is the object summary.

708
00:36:59.436 --> 00:37:00.736
to ask is the object summary.

709
00:37:01.106 --> 00:37:04.976
Caveat to the caveat:
except for enums.

710
00:37:05.766 --> 00:37:07.956
When you have a Swift enum
and you want to figure

711
00:37:07.956 --> 00:37:10.976
out which case is
selected, you ask the value.

712
00:37:14.936 --> 00:37:18.236
Let's talk about
name uniqueness.

713
00:37:18.726 --> 00:37:22.916
Let's say you, you guys are
writing an awesome Objective-C

714
00:37:23.156 --> 00:37:24.956
app and there's a
really good framework

715
00:37:24.956 --> 00:37:27.526
that would help make you
so much more productive.

716
00:37:28.336 --> 00:37:30.226
It's Foo.framework, of course.

717
00:37:31.016 --> 00:37:33.026
Foo.framework has developers

718
00:37:33.026 --> 00:37:35.276
who have really good
taste in class naming.

719
00:37:35.806 --> 00:37:37.956
Their taste in class naming
is so good that they came

720
00:37:37.956 --> 00:37:40.526
up with a really
nice class name.

721
00:37:41.816 --> 00:37:44.156
Unfortunately, these
guys have too good

722
00:37:44.156 --> 00:37:45.486
of a taste of their own good.

723
00:37:46.186 --> 00:37:48.106
A little while later,
the developers

724
00:37:48.106 --> 00:37:50.616
of another great
framework, Bar.framework,

725
00:37:51.106 --> 00:37:54.076
came up with the same
super-nice class name.

726
00:37:55.386 --> 00:37:59.556
Now, the result of this
is not nice at all.

727
00:37:59.846 --> 00:38:01.716
The result of this is undefined.

728
00:37:59.846 --> 00:38:01.716
The result of this is undefined.

729
00:38:02.006 --> 00:38:05.336
There's two frameworks with the
same class with the same name,

730
00:38:05.336 --> 00:38:07.966
trying to coexist in the
same app at the same time.

731
00:38:08.286 --> 00:38:08.876
That's not nice.

732
00:38:09.036 --> 00:38:09.716
That's undefined.

733
00:38:09.816 --> 00:38:12.836
You don't get to choose which
class gets actually loaded.

734
00:38:13.406 --> 00:38:15.646
In Swift, that's
gone [applause].

735
00:38:16.996 --> 00:38:21.946
Thank you.

736
00:38:23.946 --> 00:38:27.126
Swift provides uniqueness
among function overloads

737
00:38:27.326 --> 00:38:29.216
and among classes in
different frameworks.

738
00:38:30.206 --> 00:38:34.926
The way to access all this
goodness is a feature called

739
00:38:35.076 --> 00:38:35.966
mangled names.

740
00:38:36.596 --> 00:38:38.206
Some of you may come from C++

741
00:38:38.476 --> 00:38:40.066
and may be familiar
with that already.

742
00:38:40.606 --> 00:38:41.546
Let's talk about it.

743
00:38:43.066 --> 00:38:45.736
There's two guys and they're
both writing Swift code.

744
00:38:45.926 --> 00:38:48.536
They don't know about each
other but they both think

745
00:38:48.536 --> 00:38:51.196
that MyClass is the best
name ever for a class.

746
00:38:51.586 --> 00:38:55.076
I don't agree with that
but that's their choice.

747
00:38:56.146 --> 00:38:59.416
They want to submit their
code to the Swift Compiler.

748
00:38:59.606 --> 00:39:02.966
The first guy goes
on and does it.

749
00:38:59.606 --> 00:39:02.966
The first guy goes
on and does it.

750
00:39:02.966 --> 00:39:05.936
As a result, he gets a
compiled version of his code

751
00:39:06.486 --> 00:39:09.076
where his class is
actually called something my

752
00:39:09.076 --> 00:39:10.066
module MyClass.

753
00:39:10.206 --> 00:39:11.556
We'll get back to
that in a second.

754
00:39:12.246 --> 00:39:13.556
When the second guy does that,

755
00:39:14.536 --> 00:39:16.606
it does that same thing,
it tries to compile.

756
00:39:17.976 --> 00:39:21.246
His class actually gets called
something module 2 MyClass.

757
00:39:22.166 --> 00:39:25.986
Now they don't clash anymore,
Module1MyClass, Module2MyClass.

758
00:39:27.236 --> 00:39:28.466
There's a little price to pay.

759
00:39:29.216 --> 00:39:33.246
Now, if I actually look at the
screen and see what the name

760
00:39:33.246 --> 00:39:37.236
of the class became
at linkage time,

761
00:39:37.236 --> 00:39:44.076
it's called
-TtC7Module17MyClass.

762
00:39:44.586 --> 00:39:48.506
And that's just for
declaring a class.

763
00:39:49.536 --> 00:39:53.406
Now, the world is actually
a scary place sometimes.

764
00:39:53.926 --> 00:39:56.506
What if you were out
there in the wild roaming

765
00:39:56.506 --> 00:39:58.156
through dark streets and out

766
00:39:58.226 --> 00:40:01.966
of a little alley a mangled
name came right at you.

767
00:39:58.226 --> 00:40:01.966
of a little alley a mangled
name came right at you.

768
00:40:03.086 --> 00:40:04.546
That could happen
while you're, you know,

769
00:40:04.666 --> 00:40:06.966
you're just sitting there in
interface builder doing things

770
00:40:06.966 --> 00:40:08.796
and oh, there's a
mangled name there.

771
00:40:09.556 --> 00:40:12.756
Or, worse even, your
app just crashed.

772
00:40:13.176 --> 00:40:15.386
Not all of you are going to
get crash reporter window.

773
00:40:15.616 --> 00:40:17.486
You're also getting
mangled names in there.

774
00:40:17.866 --> 00:40:19.216
It doesn't get much
worse than that,

775
00:40:19.896 --> 00:40:23.716
except swift-demangle
comes to the rescue.

776
00:40:24.506 --> 00:40:27.736
swift-demangle is a little
tool that ships with Xcode

777
00:40:28.476 --> 00:40:31.836
that lets you pass as input
on the command line one

778
00:40:31.836 --> 00:40:33.306
or more Swift mangled names,

779
00:40:34.026 --> 00:40:38.436
and it magically provides
you the demangled version.

780
00:40:39.026 --> 00:40:42.586
So, fear no more encounters with
mangled names in dark alleys.

781
00:40:43.366 --> 00:40:47.746
This is the magic of modules.

782
00:40:48.746 --> 00:40:51.586
This is the magic of
modules in the context

783
00:40:51.586 --> 00:40:54.656
of name uniqueness,
of avoiding clashes.

784
00:40:55.906 --> 00:40:58.326
Modules can do a
lot more for us.

785
00:40:58.866 --> 00:41:02.376
Modules actually make
debugging a lot more awesome.

786
00:40:58.866 --> 00:41:02.376
Modules actually make
debugging a lot more awesome.

787
00:41:03.396 --> 00:41:05.976
Why? How? Let's look at it.

788
00:41:06.686 --> 00:41:11.436
I have source code for my app
written in Swift and I gave it

789
00:41:11.436 --> 00:41:12.556
to the Swift Compiler.

790
00:41:14.316 --> 00:41:19.646
The output of that process is
an app and module information.

791
00:41:20.686 --> 00:41:22.926
Why is that so important,
the module information?

792
00:41:24.916 --> 00:41:29.446
Well, it turns out that
much like it contains a copy

793
00:41:29.446 --> 00:41:33.596
of Clang, LLDB contains a copy
of the Swift Compiler inside,

794
00:41:34.076 --> 00:41:35.436
and that's used, of course,

795
00:41:35.646 --> 00:41:38.116
as part of expression
evaluation for Swift.

796
00:41:38.856 --> 00:41:41.146
But, there's a little
more to the story.

797
00:41:41.936 --> 00:41:44.686
Now, when I try to
debug that app,

798
00:41:45.776 --> 00:41:49.356
the copy of the compiler will
actually be able to infer,

799
00:41:49.706 --> 00:41:52.356
to ingest the module information
for the compiled app.

800
00:41:52.356 --> 00:41:55.206
Why is that so important?

801
00:41:55.696 --> 00:41:59.616
Let me give you a little
perspective on what happens

802
00:42:00.086 --> 00:42:01.996
when you compile an
app for debugging

803
00:42:01.996 --> 00:42:03.966
and then you try to debug it.

804
00:42:04.556 --> 00:42:07.266
When you tell the
compiler, any compiler,

805
00:42:07.326 --> 00:42:09.096
let's go with Clang
in this example.

806
00:42:09.586 --> 00:42:12.686
When you tell Clang, "Please
compile my app for debugging",

807
00:42:13.386 --> 00:42:16.856
what Clang does is it
ingests your code as usual.

808
00:42:17.016 --> 00:42:18.346
It understands your code

809
00:42:18.346 --> 00:42:21.256
and gets a mental model
of it in some sense.

810
00:42:22.536 --> 00:42:25.396
Then you tell Clang,
"Give me information

811
00:42:25.396 --> 00:42:27.576
to help me debug my app."

812
00:42:27.576 --> 00:42:31.146
What that process does
is it generates DWARF.

813
00:42:31.566 --> 00:42:34.276
DWARF is a format
used specifically

814
00:42:34.446 --> 00:42:36.306
for containing debug
information.

815
00:42:36.786 --> 00:42:39.966
So, Clang has an understanding
of the type system of your app.

816
00:42:40.646 --> 00:42:43.466
It takes that understanding,
it translates it

817
00:42:43.756 --> 00:42:46.186
into a different format, DWARF.

818
00:42:46.736 --> 00:42:52.116
The debugger, LLDB, then
ingests that DWARF information

819
00:42:52.396 --> 00:42:55.246
and it has to recreate
an understanding

820
00:42:55.406 --> 00:42:57.486
of the type system of your app.

821
00:42:57.756 --> 00:43:01.596
The way LLDB does that is
it generates Clang types

822
00:42:57.756 --> 00:43:01.596
The way LLDB does that is
it generates Clang types

823
00:43:01.876 --> 00:43:02.716
out of DWARF.

824
00:43:04.006 --> 00:43:05.116
Hold on a second.

825
00:43:05.656 --> 00:43:07.956
So what you're telling
me here is basically

826
00:43:08.306 --> 00:43:10.586
that Clang generates Clang types

827
00:43:11.016 --> 00:43:15.066
out of my source code then it
translates that into DWARF.

828
00:43:15.646 --> 00:43:21.366
Then, LLDB consumes the DWARF
and generates Clang types back.

829
00:43:22.556 --> 00:43:25.456
Why? Wouldn't it be really nice

830
00:43:25.856 --> 00:43:29.366
if LLDB could directly
understand the compiler's notion

831
00:43:29.366 --> 00:43:29.926
of types?

832
00:43:30.506 --> 00:43:31.456
Wouldn't it be great

833
00:43:31.456 --> 00:43:33.416
if we didn't have the
intermediate steps,

834
00:43:33.736 --> 00:43:37.036
and the compiler parses your
source code, understands it.

835
00:43:37.416 --> 00:43:39.906
It creates a representation
of the types,

836
00:43:40.006 --> 00:43:42.786
it's own representation
of the types in your app,

837
00:43:42.786 --> 00:43:45.366
and the debugger gets to use
that same representation?

838
00:43:46.496 --> 00:43:48.186
That certainly seems nice.

839
00:43:48.806 --> 00:43:50.936
It certainly seems
nice for us that have

840
00:43:50.936 --> 00:43:52.286
to actually write the debugger.

841
00:43:52.626 --> 00:43:53.576
We skip one step.

842
00:43:53.636 --> 00:43:55.916
We can directly use the
compiler's notion of the truth.

843
00:43:56.756 --> 00:43:59.806
It's also really nice for you,
the users of the debugger.

844
00:44:00.286 --> 00:44:03.476
The reason, well, there's
a couple of reasons.

845
00:44:04.476 --> 00:44:07.706
The obvious one is that
if we could do that,

846
00:44:08.196 --> 00:44:11.176
there would be no potential
for loss of information

847
00:44:11.176 --> 00:44:12.526
in the translation process.

848
00:44:13.086 --> 00:44:16.316
We went, we would go
from source, Clang types,

849
00:44:16.356 --> 00:44:23.266
DWARF Clang types, to source
types, types, one less step

850
00:44:23.306 --> 00:44:24.546
where information can get lost.

851
00:44:26.476 --> 00:44:29.096
That is what happens in Swift.

852
00:44:29.976 --> 00:44:32.176
The Swift Compiler
generates a model

853
00:44:32.436 --> 00:44:36.336
which is the compiler's
understanding of the truth

854
00:44:36.336 --> 00:44:39.586
of your program at the
time it was being compiled.

855
00:44:40.086 --> 00:44:43.926
LLDB's copy of the
Swift Compiler ingests

856
00:44:44.116 --> 00:44:47.136
that model information
and can use it

857
00:44:47.136 --> 00:44:50.296
to reproduce the type system
that the compiler was seeing

858
00:44:50.296 --> 00:44:52.356
at the time your program
was being compiled.

859
00:44:52.806 --> 00:44:55.596
There's no loss of
information and there's no need

860
00:44:55.666 --> 00:44:56.796
for the intermediate step

861
00:44:57.196 --> 00:45:00.216
of re-creating the types
from, back from DWARF.

862
00:44:57.196 --> 00:45:00.216
of re-creating the types
from, back from DWARF.

863
00:45:01.856 --> 00:45:03.366
There's one more advantage.

864
00:45:03.916 --> 00:45:07.656
Some of you have
written C++ code

865
00:45:08.086 --> 00:45:09.926
and you've probably
used generics.

866
00:45:11.346 --> 00:45:14.526
For that situation, I'm
sure you will run into it.

867
00:45:14.706 --> 00:45:16.726
You try to use some
generic function

868
00:45:17.336 --> 00:45:21.036
and you actually didn't use
that in your source program

869
00:45:21.436 --> 00:45:24.266
and now LLDB's complaining,
"You're trying

870
00:45:24.266 --> 00:45:26.486
to use this function with
this really weird name

871
00:45:26.486 --> 00:45:28.316
that is not present
in the target."

872
00:45:29.196 --> 00:45:33.536
It turns out that that
won't happen in Swift.

873
00:45:34.036 --> 00:45:36.306
Since generics are
actually types

874
00:45:36.366 --> 00:45:38.256
that the compiler
understands natively

875
00:45:38.716 --> 00:45:42.076
and since we have the compiler's
very own understanding

876
00:45:42.076 --> 00:45:46.456
of the truth, now we get
every type and every function

877
00:45:46.456 --> 00:45:49.316
through module information,
even those you did not use

878
00:45:49.316 --> 00:45:52.296
in your source code,
and even generic ones.

879
00:45:53.086 --> 00:45:57.346
That was a lot of
ground covered today.

880
00:45:58.316 --> 00:46:02.736
If you remember one thing
from this session, well,

881
00:45:58.316 --> 00:46:02.736
If you remember one thing
from this session, well,

882
00:46:02.736 --> 00:46:03.556
there's always caveats.

883
00:46:03.596 --> 00:46:05.976
But no, that's not the thing
I want you to remember.

884
00:46:07.836 --> 00:46:12.136
You can choose your language and
LLDB will be there every step

885
00:46:12.136 --> 00:46:15.236
of the way with helpful
investigation tools.

886
00:46:16.326 --> 00:46:19.866
Whether you're, whether
you're using Use With Features

887
00:46:19.866 --> 00:46:21.606
or you're debugging
your existing code base,

888
00:46:22.036 --> 00:46:24.106
the helpful features in
the debugger will be there

889
00:46:24.156 --> 00:46:26.326
to help you make
your app awesome.

890
00:46:27.616 --> 00:46:29.346
We talked about a
bunch of topics.

891
00:46:30.066 --> 00:46:33.336
We talked about Swift types,
stepping, data formatters

892
00:46:33.366 --> 00:46:36.466
and modules, and probably
even more than that.

893
00:46:36.796 --> 00:46:42.236
The important thing is your
feedback matters a lot to us.

894
00:46:42.786 --> 00:46:44.736
I've been in the labs
the last couple of days.

895
00:46:45.146 --> 00:46:47.556
I've read the blogosphere
the last couple of days

896
00:46:48.006 --> 00:46:50.096
and I've gotten from, I've seen

897
00:46:50.096 --> 00:46:52.576
from you guys some
amazing feedback.

898
00:46:52.576 --> 00:46:55.696
I've seen the great things
you've started doing in Swift,

899
00:46:55.966 --> 00:46:59.586
including the Flappy Birds
app in Swift, I've seen that.

900
00:47:00.826 --> 00:47:04.696
We've gotten emails where
people tell us amazing things

901
00:47:04.696 --> 00:47:07.826
about how they expect these new
tools to change their lives,

902
00:47:07.866 --> 00:47:09.176
to make their programming
better.

903
00:47:09.956 --> 00:47:10.896
Keep that coming.

904
00:47:10.996 --> 00:47:13.106
Your feedback matters
a lot to us.

905
00:47:13.426 --> 00:47:14.706
Let us know what
we're doing great,

906
00:47:14.746 --> 00:47:16.676
let us know what
we can do better,

907
00:47:16.676 --> 00:47:19.036
and of course, thank
you everyone.

908
00:47:19.406 --> 00:47:19.826
Thank you.

909
00:47:23.516 --> 00:47:34.520
[ Applause ]
