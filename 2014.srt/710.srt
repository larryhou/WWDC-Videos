
1
00:00:12.356 --> 00:00:13.036
>> Good morning.

2
00:00:13.806 --> 00:00:16.166
Welcome to Writing Energy
Efficient Code, Part 1.

3
00:00:16.436 --> 00:00:19.806
I'm Anthony Chivetta from the
OS X Power & Performance team.

4
00:00:20.726 --> 00:00:22.646
And hopefully, everyone
is feeling awake

5
00:00:22.646 --> 00:00:25.266
and recharged this morning now
that you've had your first cup

6
00:00:25.266 --> 00:00:26.866
of coffee, your iDevices

7
00:00:26.866 --> 00:00:28.926
and Macs have a full
charge from overnight.

8
00:00:29.476 --> 00:00:32.735
But unfortunately, as we all
know, as the day wears on,

9
00:00:33.616 --> 00:00:36.196
sometimes our energy
can begin to drain,

10
00:00:36.946 --> 00:00:38.846
we find our batteries
just aren't as full.

11
00:00:39.576 --> 00:00:40.636
And I want to talk to you today

12
00:00:40.636 --> 00:00:44.896
about how you can help make sure
your applications contribute

13
00:00:44.896 --> 00:00:47.516
to extending users' battery
life for as long as possible,

14
00:00:47.706 --> 00:00:49.386
and improving the
user experience

15
00:00:50.576 --> 00:00:52.136
by making sure users
can continue

16
00:00:52.136 --> 00:00:53.556
to use your app all day long.

17
00:00:53.556 --> 00:00:55.546
And of course, you know running

18
00:00:55.546 --> 00:00:57.066
out of battery life is
something we all hate.

19
00:00:57.416 --> 00:00:59.546
So, hopefully, that in
itself is motivation to try

20
00:00:59.546 --> 00:01:01.866
to help improve the energy
efficiency of your application.

21
00:00:59.546 --> 00:01:01.866
to help improve the energy
efficiency of your application.

22
00:01:02.346 --> 00:01:06.676
But if not, in OS X
Mavericks and iOS 8,

23
00:01:07.016 --> 00:01:09.916
we've been helping
provide users better tools

24
00:01:10.256 --> 00:01:12.716
to understand what
applications are contributing

25
00:01:12.716 --> 00:01:14.566
to battery life on their system.

26
00:01:15.016 --> 00:01:17.606
So, on the left in
OS X Mavericks,

27
00:01:17.636 --> 00:01:20.546
we added to the Battery
menu a list of applications

28
00:01:20.546 --> 00:01:22.156
that are using significant
amounts of energy.

29
00:01:22.706 --> 00:01:25.606
And on the right, you can see
the new Battery Usage screen

30
00:01:25.606 --> 00:01:26.906
in iOS 8 settings.

31
00:01:27.346 --> 00:01:30.756
And with these tools, users
can make smart decisions

32
00:01:30.756 --> 00:01:32.116
about what apps they use,

33
00:01:32.396 --> 00:01:35.156
understanding how those apps
impact their battery life.

34
00:01:35.216 --> 00:01:36.886
So, if your app is
energy inefficient,

35
00:01:36.886 --> 00:01:38.876
you might find users
stop using your apps

36
00:01:39.616 --> 00:01:41.176
or give them poor
App Store ratings.

37
00:01:41.496 --> 00:01:43.576
And so, it's in everyone's
interest

38
00:01:43.656 --> 00:01:46.096
to make sure your apps are as
energy efficient as possible.

39
00:01:46.386 --> 00:01:49.616
So, with that, what are we
going to talk about today?

40
00:01:50.736 --> 00:01:52.896
We'll start by going
through some general power

41
00:01:52.896 --> 00:01:53.906
energy concepts.

42
00:01:53.906 --> 00:01:55.676
So, you have kind of a
high level understanding

43
00:01:55.676 --> 00:01:56.986
of what it is we're discussing.

44
00:01:57.176 --> 00:02:00.466
And then, we'll go
through some specific ways

45
00:01:57.176 --> 00:02:00.466
And then, we'll go
through some specific ways

46
00:02:00.466 --> 00:02:01.996
that you can improve
your energy use.

47
00:02:02.456 --> 00:02:04.886
We'll start with the technique
of doing something never,

48
00:02:05.856 --> 00:02:07.496
progress to doing
it at a better time,

49
00:02:08.545 --> 00:02:10.096
discuss how to do
it more efficiently,

50
00:02:11.396 --> 00:02:13.356
and finally, how to do less.

51
00:02:13.356 --> 00:02:17.066
And then, for Part 2, in
the same room immediately

52
00:02:17.066 --> 00:02:20.296
after this talk, Albert will
come up and talk specifically

53
00:02:20.296 --> 00:02:22.516
about networking, location,

54
00:02:22.966 --> 00:02:25.736
and sleep/wake issues
in much more depth.

55
00:02:26.316 --> 00:02:27.896
And so with that,
let's get started.

56
00:02:28.706 --> 00:02:30.376
So, first, what uses energy?

57
00:02:30.376 --> 00:02:31.876
Well, the short answer
is everything

58
00:02:31.876 --> 00:02:33.046
on the system uses energy.

59
00:02:33.046 --> 00:02:35.866
Any resource you
might use as part

60
00:02:35.866 --> 00:02:38.126
of your code's execution is
going to consume some energy.

61
00:02:38.806 --> 00:02:41.406
And a few things you want to
keep particularly in mind,

62
00:02:41.406 --> 00:02:43.026
the first is your
CPU consumption.

63
00:02:43.406 --> 00:02:45.776
And CPU has a huge dynamic
range, using a little

64
00:02:45.776 --> 00:02:47.506
versus using a lot
makes a big difference.

65
00:02:48.796 --> 00:02:50.856
How you use Flash
storage in particular.

66
00:02:50.856 --> 00:02:53.416
Flash also has a
big dynamic range.

67
00:02:53.816 --> 00:02:56.496
So, any time you read or
write to a storage device,

68
00:02:56.496 --> 00:02:58.376
you're going to incur
more energy consumption.

69
00:02:59.456 --> 00:03:01.636
Networking, especially
on iOS devices

70
00:02:59.456 --> 00:03:01.636
Networking, especially
on iOS devices

71
00:03:01.636 --> 00:03:04.006
with so many different types
of networking, can play,

72
00:03:04.166 --> 00:03:07.706
can be a large factor in
your energy consumption.

73
00:03:07.706 --> 00:03:11.836
And then Graphics, you might
do a little bit of drawing

74
00:03:11.836 --> 00:03:13.476
in your app but this
can cause a lot of work

75
00:03:13.476 --> 00:03:15.266
to happen downstream
the Graphics pipeline.

76
00:03:15.736 --> 00:03:17.416
This is obviously not
an exhaustive list,

77
00:03:17.856 --> 00:03:19.846
but just some areas of your
application you should kind

78
00:03:19.846 --> 00:03:22.116
of keep in the back of your
head as we talk about some

79
00:03:22.116 --> 00:03:23.376
of these power fundamentals.

80
00:03:24.936 --> 00:03:26.336
So, let's look at
the graph here.

81
00:03:26.676 --> 00:03:28.686
And we're going to see a number
of graphs like this today.

82
00:03:28.686 --> 00:03:30.906
So, just to kind of orient
you, on the bottom here,

83
00:03:30.906 --> 00:03:34.136
we have time going
across from left to right.

84
00:03:34.136 --> 00:03:36.436
And on the vertical
axis, we have power.

85
00:03:36.436 --> 00:03:37.746
So, you can imagine,
we took a device

86
00:03:37.746 --> 00:03:38.816
and attached the power meter.

87
00:03:39.286 --> 00:03:40.856
And we would like
to see a reading

88
00:03:40.856 --> 00:03:42.266
that looks something like this.

89
00:03:42.716 --> 00:03:47.586
There's a couple of features of
this graph I want to point out.

90
00:03:48.066 --> 00:03:50.726
The first is this very low
idle power at the beginning.

91
00:03:50.876 --> 00:03:52.416
Our devices are really
good at getting

92
00:03:52.416 --> 00:03:54.536
into low-power states
when not being used.

93
00:03:54.806 --> 00:03:57.876
And so, the idle power of
a device is very, very low.

94
00:03:58.546 --> 00:04:01.116
We then have these portions
where the system is active.

95
00:03:58.546 --> 00:04:01.116
We then have these portions
where the system is active.

96
00:04:01.116 --> 00:04:02.956
Your code might have been
running, doing something,

97
00:04:03.296 --> 00:04:05.416
were actively consuming
resources

98
00:04:05.416 --> 00:04:06.466
and accomplishing work.

99
00:04:06.916 --> 00:04:09.436
And then we also have
these intermediate states.

100
00:04:09.696 --> 00:04:11.426
And these are places
where the system is idle,

101
00:04:11.526 --> 00:04:13.386
but we haven't been able
to get all the way back

102
00:04:13.386 --> 00:04:14.956
down to our lowest idle power.

103
00:04:15.886 --> 00:04:17.546
We need some time to
achieve that state

104
00:04:17.546 --> 00:04:18.805
and you can see at
the end, we do.

105
00:04:19.315 --> 00:04:20.546
But if you have sporadic work,

106
00:04:20.546 --> 00:04:22.436
we can stay in these
intermediate states

107
00:04:22.436 --> 00:04:23.316
for a very long time.

108
00:04:24.486 --> 00:04:26.456
So, ultimately, what we can
do is we can divide this graph

109
00:04:26.456 --> 00:04:26.966
in half.

110
00:04:27.196 --> 00:04:30.256
We can say everything in the
top half is the dynamic cost.

111
00:04:30.496 --> 00:04:32.936
This is the cost associated
with actually accomplishing more

112
00:04:32.936 --> 00:04:35.976
and more work, whereas the
bottom part is the fixed cost.

113
00:04:35.976 --> 00:04:38.126
This is what we pay just
to have accomplished any

114
00:04:38.126 --> 00:04:38.956
work whatsoever.

115
00:04:39.396 --> 00:04:42.116
And this fixed-cost
concept can come

116
00:04:42.116 --> 00:04:43.996
into play whenever you
have sporadic work.

117
00:04:43.996 --> 00:04:45.656
So, you can imagine here,

118
00:04:45.966 --> 00:04:47.326
we have a workload
that's doing a bunch

119
00:04:47.326 --> 00:04:48.706
of little tasks sporadically.

120
00:04:49.576 --> 00:04:53.096
Well, all of this blue area at
the bottom is the fixed cost.

121
00:04:53.496 --> 00:04:55.166
That's a lot of energy
we're consuming

122
00:04:55.166 --> 00:04:58.156
to get a very small
actual amount of work done.

123
00:04:59.096 --> 00:05:02.566
So, any time you can help
avoid small sporadic work units

124
00:04:59.096 --> 00:05:02.566
So, any time you can help
avoid small sporadic work units

125
00:05:02.776 --> 00:05:04.076
by aggregating them together,

126
00:05:04.616 --> 00:05:08.706
you can dramatically reduce
the fixed cost of your work.

127
00:05:09.386 --> 00:05:11.846
And this is an easy way
to get energy savings.

128
00:05:12.116 --> 00:05:13.586
And it's also important
to keep in mind

129
00:05:13.586 --> 00:05:15.246
because your app
probably does lots

130
00:05:15.246 --> 00:05:16.676
of things exponentially
concurrently.

131
00:05:16.956 --> 00:05:19.016
And you have to think
holistically about the behavior

132
00:05:19.016 --> 00:05:21.216
of your application to make
sure you're grouping work

133
00:05:21.216 --> 00:05:22.276
together appropriately.

134
00:05:24.576 --> 00:05:26.156
So, we've also mentioned
these terms,

135
00:05:26.156 --> 00:05:27.836
energy and power, a few times.

136
00:05:28.106 --> 00:05:30.256
Let's put some more
specific definitions to them.

137
00:05:30.676 --> 00:05:32.176
So, first, power.

138
00:05:32.636 --> 00:05:34.246
Power is an instantaneous
measurement.

139
00:05:34.326 --> 00:05:36.236
So, as we're looking at
these graphs it's the value

140
00:05:36.236 --> 00:05:37.236
at one point in time.

141
00:05:37.786 --> 00:05:41.146
On the other hand, energy is
the area under that graph.

142
00:05:41.446 --> 00:05:44.266
So, we might say that something
consumes a certain number

143
00:05:44.266 --> 00:05:46.436
of watts as an instantaneous
power measurement.

144
00:05:46.746 --> 00:05:49.106
But to accomplish a task,
we want to talk about joules

145
00:05:49.106 --> 00:05:50.486
and the total energy it uses.

146
00:05:51.266 --> 00:05:53.456
And it's important to keep
these concepts separate

147
00:05:53.456 --> 00:05:55.576
because we can actually
trade power for energy.

148
00:05:55.866 --> 00:05:58.466
So, let's imagine we have
a single-threaded workload.

149
00:05:59.006 --> 00:06:01.856
The actual dynamic cost of
that work is just this top part

150
00:05:59.006 --> 00:06:01.856
The actual dynamic cost of
that work is just this top part

151
00:06:01.856 --> 00:06:02.276
in blue.

152
00:06:02.276 --> 00:06:03.866
And if we were to make

153
00:06:03.866 --> 00:06:05.546
that single-threaded
workload multi-threaded,

154
00:06:06.456 --> 00:06:09.486
we can have the same dynamic
cost but reduce our fixed cost

155
00:06:09.486 --> 00:06:10.746
by getting the work done faster.

156
00:06:11.116 --> 00:06:13.806
In this way, our
instantaneous power is increased

157
00:06:14.236 --> 00:06:16.556
but our overall energy
consumption is decreased.

158
00:06:16.606 --> 00:06:18.866
In essence, by getting
better performance,

159
00:06:18.866 --> 00:06:20.726
we've also achieved
better energy use.

160
00:06:21.126 --> 00:06:22.556
And that's a common
theme we'll talk about,

161
00:06:22.556 --> 00:06:24.436
is that any time you
can improve performance,

162
00:06:24.716 --> 00:06:26.306
it's also likely going
to improve energy,

163
00:06:26.486 --> 00:06:27.666
and these things
go hand in hand.

164
00:06:28.176 --> 00:06:31.216
So, that's our power
fundamentals.

165
00:06:31.286 --> 00:06:33.426
Things to remember is
that work is a fixed cost.

166
00:06:33.426 --> 00:06:36.686
For small workloads, that
fixed cost will often dominate.

167
00:06:37.106 --> 00:06:38.256
For intensive workloads,

168
00:06:38.256 --> 00:06:39.856
the dynamic cost will
usually dominate.

169
00:06:40.316 --> 00:06:42.496
And better performance
often means better energy.

170
00:06:43.096 --> 00:06:48.086
OK, so, let's dive into
techniques you can use

171
00:06:48.086 --> 00:06:50.016
to improve the energy
consumption of your app.

172
00:06:50.666 --> 00:06:52.436
The first we want to talk
about is Do It Never.

173
00:06:52.746 --> 00:06:56.116
So, this might seem simple-if
you can avoid doing work,

174
00:06:56.276 --> 00:06:57.016
avoid doing it.

175
00:06:57.556 --> 00:07:00.086
That's certainly going to have
better energy consumption.

176
00:06:57.556 --> 00:07:00.086
That's certainly going to have
better energy consumption.

177
00:07:00.176 --> 00:07:01.966
So, let's imagine we
have an application

178
00:07:01.996 --> 00:07:04.906
and some ad that's animating,
maybe it's a scrolling marquee

179
00:07:04.906 --> 00:07:07.096
like in our iTunes
or App Stores.

180
00:07:07.596 --> 00:07:10.916
And this is fine, you know,
that's a nice user interface.

181
00:07:11.256 --> 00:07:16.776
But what happens if another app
comes along and they're sitting

182
00:07:16.776 --> 00:07:17.996
in front of your application?

183
00:07:18.766 --> 00:07:22.306
Are you still doing the work
necessary for that, for your ad

184
00:07:22.306 --> 00:07:24.946
or marquee or what it might be
to draw it up into the screen?

185
00:07:25.486 --> 00:07:26.796
Are your timers still firing?

186
00:07:27.026 --> 00:07:29.216
Are you still consuming energy
even though the user can't see

187
00:07:29.216 --> 00:07:29.716
your app?

188
00:07:30.606 --> 00:07:32.836
It's very important to make
sure that we're not doing work

189
00:07:33.136 --> 00:07:35.676
to power user interface features
that the user isn't aware of.

190
00:07:36.176 --> 00:07:40.536
So, on iOS, hopefully, most of
you are familiar with these.

191
00:07:40.536 --> 00:07:43.026
There's two
UIApplicationDelegate methods

192
00:07:43.026 --> 00:07:45.666
you can implement,
applicationDidResignActive

193
00:07:45.666 --> 00:07:47.176
and applicationDidBecomeActive.

194
00:07:47.306 --> 00:07:49.106
And you'll get didResignActive

195
00:07:49.106 --> 00:07:50.466
when your app enters
the background

196
00:07:50.736 --> 00:07:53.006
or becomes not visible on
screen due to, let's say,

197
00:07:53.006 --> 00:07:54.046
the user gets a phone call.

198
00:07:54.126 --> 00:07:56.286
And then of course,
you'll get didBecomeActive

199
00:07:56.286 --> 00:07:57.906
when you are now visible again.

200
00:07:58.366 --> 00:07:59.996
It's important to
use the pair of these

201
00:07:59.996 --> 00:08:02.946
to pause any animations,
UI updating timers

202
00:07:59.996 --> 00:08:02.946
to pause any animations,
UI updating timers

203
00:08:02.946 --> 00:08:06.096
that might be firing and make
sure your app gets as quiesced

204
00:08:06.096 --> 00:08:08.456
and energy efficient
as possible,

205
00:08:08.456 --> 00:08:10.556
because the user can't see any

206
00:08:10.556 --> 00:08:11.886
of the work you're
doing to update the UI.

207
00:08:12.596 --> 00:08:15.896
You can also listen to
the UIApplicationWill

208
00:08:15.896 --> 00:08:18.616
ResignActiveNotification as well
in other parts of your code.

209
00:08:19.046 --> 00:08:24.466
Now, in OS X, it's similar,
same application didResignActive

210
00:08:24.466 --> 00:08:26.626
and becomeActive on your
NSApplication Delegate.

211
00:08:28.286 --> 00:08:30.506
But OS X makes things a
little more complicated

212
00:08:30.506 --> 00:08:32.616
because there are multiple
applications on the screen.

213
00:08:33.986 --> 00:08:35.476
And so, on OS X, we
have something called

214
00:08:35.476 --> 00:08:36.676
Occlusion Notifications.

215
00:08:36.676 --> 00:08:39.275
So, this is a new feature
that was new in OS X Mavericks

216
00:08:39.515 --> 00:08:41.746
and it lets you determine
the visibility

217
00:08:41.746 --> 00:08:43.836
of a particular window
or application.

218
00:08:45.016 --> 00:08:48.326
For application, you have the
delegate method application

219
00:08:48.326 --> 00:08:49.446
DidChangeOcclusionState.

220
00:08:50.356 --> 00:08:51.726
And for a window, you can check,

221
00:08:51.726 --> 00:08:53.736
get
windowDidChangeOcclusionState

222
00:08:53.736 --> 00:08:55.076
to know when a particular window

223
00:08:55.076 --> 00:08:57.296
or the whole application
becomes visible

224
00:08:57.296 --> 00:08:58.506
or becomes fully occluded.

225
00:08:58.966 --> 00:09:04.316
And with the use of these and
the applicationDidBecomeActive

226
00:08:58.966 --> 00:09:04.316
And with the use of these and
the applicationDidBecomeActive

227
00:09:04.316 --> 00:09:06.406
and resignActive,
which changes based

228
00:09:06.406 --> 00:09:08.406
on what the frontmost
app on the system is.

229
00:09:08.456 --> 00:09:11.196
So, you are active on OS X when
you're in the menu at the top

230
00:09:11.196 --> 00:09:12.996
of the screen and
you resignActive

231
00:09:12.996 --> 00:09:14.536
when another app
becomes frontmost.

232
00:09:14.536 --> 00:09:16.586
So, between that and
occlusion notifications,

233
00:09:16.586 --> 00:09:18.886
you can determine the full
state of your app on the system

234
00:09:19.146 --> 00:09:20.056
and make smart decisions

235
00:09:20.056 --> 00:09:21.676
about whether it's
appropriate to do work.

236
00:09:22.146 --> 00:09:23.696
And some of you might want

237
00:09:23.696 --> 00:09:25.996
to know how App Nap
factors into all this.

238
00:09:25.996 --> 00:09:28.526
So, App Nap is the feature
reintroduced in OS X Mavericks

239
00:09:28.886 --> 00:09:31.566
that can reduce an inactive
application's energy use

240
00:09:31.726 --> 00:09:33.146
by constraining its resources.

241
00:09:33.896 --> 00:09:36.826
But, the problem is that App
Nap relies on heuristics.

242
00:09:36.826 --> 00:09:39.816
We have to make guesses
as to whether a user cares

243
00:09:39.816 --> 00:09:42.106
about a particular application
at a particular time.

244
00:09:42.536 --> 00:09:46.286
And so, there are cases where
we cannot put an app in App Nap,

245
00:09:46.286 --> 00:09:49.336
because we're not certain
the app isn't in use.

246
00:09:49.656 --> 00:09:52.336
But as a developer, you are the
authoritative source for this.

247
00:09:52.666 --> 00:09:54.236
Once you've taken
into account things

248
00:09:54.236 --> 00:09:55.466
like occlusion notifications,

249
00:09:55.466 --> 00:09:57.826
you know whether a particular
piece of work is necessary.

250
00:09:58.576 --> 00:10:00.966
And so, ultimately,
in a well-behaved app,

251
00:09:58.576 --> 00:10:00.966
And so, ultimately,
in a well-behaved app,

252
00:10:00.966 --> 00:10:02.706
App Nap should never
have an effect.

253
00:10:03.136 --> 00:10:05.526
If the user isn't using the app,
you shouldn't be doing any work.

254
00:10:05.846 --> 00:10:08.646
And if you are doing work
on behalf of the user,

255
00:10:09.096 --> 00:10:11.606
you should be using
the NSProcessInfo

256
00:10:11.686 --> 00:10:15.006
PerformActivityWithOptions
API to let the system know

257
00:10:15.006 --> 00:10:17.206
that you're doing work and
now is not an appropriate time

258
00:10:17.526 --> 00:10:18.096
to nap you.

259
00:10:18.786 --> 00:10:20.946
So, ultimately, App
Nap is a fallback

260
00:10:20.946 --> 00:10:23.016
and in a well-behaved
application you really shouldn't

261
00:10:23.016 --> 00:10:25.366
have any effects from App Nap.

262
00:10:27.516 --> 00:10:30.046
So, remember, try to
avoid unnecessary work.

263
00:10:30.256 --> 00:10:32.126
Monitor the app, your
application's state to know

264
00:10:32.126 --> 00:10:32.936
when it's not visible.

265
00:10:33.336 --> 00:10:36.296
Avoid updating the UI until
the user can see the results

266
00:10:36.516 --> 00:10:39.806
and make sure to be efficient in
napping yourself when not in use

267
00:10:39.806 --> 00:10:41.406
so App Nap doesn't
have to take effect.

268
00:10:41.876 --> 00:10:46.816
So, with that, let's talk about
doing it at a better time.

269
00:10:47.186 --> 00:10:49.976
So, user devices have lots
of different power states.

270
00:10:49.976 --> 00:10:51.026
Sometimes, they're plugged in.

271
00:10:51.026 --> 00:10:52.026
Sometimes, they're on battery.

272
00:10:52.916 --> 00:10:54.706
And when you do work, in effect,

273
00:10:55.366 --> 00:10:57.686
what the user's overall
experience over a long period

274
00:10:57.686 --> 00:10:59.526
of time is with respect
to their battery life.

275
00:11:00.576 --> 00:11:03.966
So, if we imagine here,
your typical user day, oh,

276
00:11:03.966 --> 00:11:06.676
maybe not typical, but
the user forgets to plug

277
00:11:06.676 --> 00:11:08.636
in their device overnight,
they get a little bit of charge

278
00:11:08.636 --> 00:11:11.166
in the morning and then
they have this big window

279
00:11:11.166 --> 00:11:13.386
until noon before they can
plug in their device again.

280
00:11:13.846 --> 00:11:15.396
And our goal here is
obviously to make it

281
00:11:15.396 --> 00:11:16.826
so the user never
runs out of battery.

282
00:11:17.096 --> 00:11:18.386
So, let's take a
look at what happens.

283
00:11:19.496 --> 00:11:21.996
We start out, user is doing OK.

284
00:11:21.996 --> 00:11:23.226
They get a little
charge in the morning.

285
00:11:23.476 --> 00:11:25.206
And now, they're
sitting around at 10 a.m.

286
00:11:25.336 --> 00:11:26.496
and they run your application.

287
00:11:27.996 --> 00:11:29.956
Well, your application
decides it wants

288
00:11:29.956 --> 00:11:31.676
to do something very
power intensive,

289
00:11:31.726 --> 00:11:33.786
wants to download new
content, do some update,

290
00:11:34.186 --> 00:11:35.576
and that uses a lot of energy.

291
00:11:36.576 --> 00:11:39.076
Well, now, we've dramatically
reduced the user's battery life

292
00:11:39.146 --> 00:11:39.816
and they're going to run

293
00:11:39.816 --> 00:11:41.586
out of energy before they
have a chance to plug in.

294
00:11:41.736 --> 00:11:44.736
And the user is now very sad,
we're sad, everyone is sad,

295
00:11:44.736 --> 00:11:45.956
this isn't a good experience.

296
00:11:46.566 --> 00:11:48.936
But what if instead of
running that work immediately,

297
00:11:49.436 --> 00:11:51.396
you knew this just needs
to happen sometimes soon.

298
00:11:51.396 --> 00:11:52.866
It doesn't need to
happen right now.

299
00:11:52.866 --> 00:11:54.326
And you were to tell the system,

300
00:11:54.326 --> 00:11:56.356
please let me know
when a good time is.

301
00:11:56.766 --> 00:11:58.406
Give the system a
window to schedule in

302
00:11:59.326 --> 00:12:02.386
and then let the system
automatically move

303
00:11:59.326 --> 00:12:02.386
and then let the system
automatically move

304
00:12:02.386 --> 00:12:04.706
that work out to a better time.

305
00:12:05.426 --> 00:12:09.626
And now, rather than running out
of battery, our user makes it

306
00:12:09.626 --> 00:12:10.886
to a time when they can plug in.

307
00:12:11.256 --> 00:12:11.896
They're happy.

308
00:12:12.226 --> 00:12:14.816
Your app isn't blamed for
causing their poor battery life,

309
00:12:15.556 --> 00:12:18.256
and we have a general
improvement in user experience.

310
00:12:19.646 --> 00:12:24.316
So, on OS X Yosemite, we have
a new foundation API called

311
00:12:24.356 --> 00:12:27.896
NSBackgroundActivityScheduler
that you can use

312
00:12:27.896 --> 00:12:29.246
to accomplish exactly this.

313
00:12:29.616 --> 00:12:32.006
It allows you to
schedule an arbitrary task

314
00:12:32.006 --> 00:12:33.336
for some good time
in the future.

315
00:12:34.186 --> 00:12:36.776
It supports repeating or
non-repeating activities.

316
00:12:36.776 --> 00:12:39.526
So, it's great for any periodic
updating you might need to do.

317
00:12:39.526 --> 00:12:42.476
And you can use it
to schedule things

318
00:12:42.476 --> 00:12:45.956
like periodic content
fetches, update installs,

319
00:12:45.956 --> 00:12:47.906
garbage collection or
data maintenance tasks,

320
00:12:48.186 --> 00:12:50.346
automatic saves or
backups-really anything you do

321
00:12:50.346 --> 00:12:52.086
in the background that
doesn't need to happen

322
00:12:52.086 --> 00:12:54.136
at a particular time,
you can sort of do

323
00:12:54.136 --> 00:12:55.836
when the system conditions
are right.

324
00:12:56.896 --> 00:12:58.756
So, let's take a look
at how to use this API.

325
00:13:00.146 --> 00:13:01.516
The first thing you'll
do is create an

326
00:13:01.516 --> 00:13:03.336
NSBackgroundActivityScheduler
object.

327
00:13:03.556 --> 00:13:05.396
And you'll use the
initWithIdentifier method

328
00:13:05.876 --> 00:13:08.616
to pass in an identifier for
that particular activity.

329
00:13:09.326 --> 00:13:11.536
This is something that you
should put in reverse-DNS style

330
00:13:11.896 --> 00:13:13.936
and use it to identify the
particular action you're

331
00:13:13.936 --> 00:13:14.826
doing uniquely.

332
00:13:15.096 --> 00:13:17.696
But you also want to try
to reuse these identifiers

333
00:13:17.696 --> 00:13:21.336
over multiple invocations
of that activity or launches

334
00:13:21.336 --> 00:13:24.586
of your app because the system
will use identifiers as a way

335
00:13:24.586 --> 00:13:26.266
to learn about the
activity you're doing

336
00:13:26.266 --> 00:13:27.846
and make better scheduling
decisions.

337
00:13:28.866 --> 00:13:31.196
So, once you've created
a scheduler,

338
00:13:31.196 --> 00:13:33.156
you can now specify
scheduling properties.

339
00:13:33.526 --> 00:13:36.006
So, and let's say we want
to have something fire

340
00:13:36.006 --> 00:13:37.106
in the next 10 minutes.

341
00:13:37.306 --> 00:13:40.576
What we can do is specify the
tolerance to be 600 seconds.

342
00:13:40.976 --> 00:13:43.406
And then, when we
run the activity,

343
00:13:43.446 --> 00:13:46.016
we'll try to schedule it within
that 10-minute tolerance period.

344
00:13:46.556 --> 00:13:49.096
On the other hand, if we
want to schedule something

345
00:13:49.096 --> 00:13:52.306
out for the future, let's say
we want it to happen between 15

346
00:13:52.306 --> 00:13:55.596
and 45 minutes from now,
we can specify an interval

347
00:13:55.996 --> 00:13:58.726
of 30 minutes and a
tolerance of 15 minutes.

348
00:13:59.246 --> 00:14:01.196
And what this means is
that we want this work

349
00:13:59.246 --> 00:14:01.196
And what this means is
that we want this work

350
00:14:01.196 --> 00:14:04.596
to happen 30 minutes plus or
minus 15 minutes in the future.

351
00:14:05.646 --> 00:14:08.646
And finally, if we want
the activity to repeat,

352
00:14:09.046 --> 00:14:11.276
let's say we want to check
for new content every hour,

353
00:14:11.786 --> 00:14:15.466
you can set repeats equals YES
and then interval to 60 minutes.

354
00:14:15.666 --> 00:14:18.416
And now, we'll try to have the
activity run once each hour.

355
00:14:18.806 --> 00:14:21.256
It's actually once each hour
in the sense that if you were

356
00:14:21.256 --> 00:14:23.686
to break up time into one-hour
periods, we'll make sure

357
00:14:23.686 --> 00:14:25.516
to run it once in each period.

358
00:14:25.516 --> 00:14:27.746
So, your average time
will be once every hour.

359
00:14:27.746 --> 00:14:30.796
But within a period, it
might happen sooner or later.

360
00:14:31.246 --> 00:14:32.016
But the benefit of this is

361
00:14:32.016 --> 00:14:33.876
that you won't experience
drift over time.

362
00:14:34.216 --> 00:14:34.546
All right.

363
00:14:35.576 --> 00:14:38.246
So, once you've specified
scheduling properties,

364
00:14:38.246 --> 00:14:39.976
now it's time to actually go
ahead and schedule the work.

365
00:14:40.376 --> 00:14:41.286
This is pretty simple.

366
00:14:41.886 --> 00:14:44.166
You'll call the
scheduleWithBlock method

367
00:14:44.296 --> 00:14:45.326
on the activity object.

368
00:14:45.846 --> 00:14:48.296
And you'll pass in a block that
takes a completion handler.

369
00:14:48.366 --> 00:14:51.336
In that block, you can do
whatever work you might need

370
00:14:51.336 --> 00:14:54.336
to do and it's perfectly OK
to do that work asynchronously

371
00:14:54.336 --> 00:14:55.716
and save off the
completion handler.

372
00:14:56.186 --> 00:14:57.116
But then when you're done,

373
00:14:57.436 --> 00:14:58.656
you'll call the completion
handler

374
00:14:58.656 --> 00:15:00.046
with NSBackgroundActivity

375
00:14:58.656 --> 00:15:00.046
with NSBackgroundActivity

376
00:15:00.046 --> 00:15:02.406
ResultFinished to
indicate that to the system

377
00:15:02.406 --> 00:15:05.546
that now this activity is done,
you've completed the work.

378
00:15:06.046 --> 00:15:10.146
Of course, if the work is really
long running, maybe, you know,

379
00:15:10.146 --> 00:15:13.066
multiple minutes, it's possible
the system power state will

380
00:15:13.176 --> 00:15:15.746
change during the
execution of that work.

381
00:15:16.056 --> 00:15:18.786
In this case, you want to
give the system the ability

382
00:15:18.786 --> 00:15:21.606
to tell you to pause and
later resume that work.

383
00:15:22.006 --> 00:15:25.246
And you can do this by checking
the shouldDefer property

384
00:15:25.246 --> 00:15:25.906
of the activity.

385
00:15:26.346 --> 00:15:27.346
This returns YES.

386
00:15:27.646 --> 00:15:30.016
The state of the system has
changed and we would like you

387
00:15:30.016 --> 00:15:32.526
to defer the remaining
work until a better time.

388
00:15:32.786 --> 00:15:34.266
So, you can check that property

389
00:15:34.636 --> 00:15:36.146
and then call the
completion handler

390
00:15:36.146 --> 00:15:37.636
with NSBackgroundActivity

391
00:15:37.636 --> 00:15:40.586
ResultDeferred to indicate
to the system that it should,

392
00:15:40.976 --> 00:15:42.296
that you're going
to pause the work

393
00:15:42.296 --> 00:15:43.776
and that it should
call you back later.

394
00:15:45.326 --> 00:15:47.956
We're using the same scheduling
parameters as you started with.

395
00:15:48.606 --> 00:15:52.416
So, that's
NSBackgroundActivityScheduler.

396
00:15:52.886 --> 00:15:55.386
You specify the scheduling
requirements for the work.

397
00:15:55.966 --> 00:15:58.096
The system selects the best
time to perform that work.

398
00:15:58.976 --> 00:16:01.696
We have support for
repeating tasks without drift,

399
00:15:58.976 --> 00:16:01.696
We have support for
repeating tasks without drift,

400
00:16:02.086 --> 00:16:05.736
and it's available in OS
X Yosemite, or if you want

401
00:16:05.886 --> 00:16:07.836
to use a C API, it was available

402
00:16:07.896 --> 00:16:10.926
as XPC activity in
10.9 Mavericks.

403
00:16:11.496 --> 00:16:14.996
Now, this works really
well for CPU or I/O or kind

404
00:16:14.996 --> 00:16:16.746
of other local intensive tasks.

405
00:16:17.256 --> 00:16:20.976
But if you want to do large
transfers to or from a server

406
00:16:20.976 --> 00:16:23.176
on the network, we actually
have an even better solution

407
00:16:23.176 --> 00:16:25.556
and that comes in the
form of the NSURLSession

408
00:16:25.826 --> 00:16:27.056
with the Background Session.

409
00:16:28.336 --> 00:16:30.116
So, let's imagine we
have an application,

410
00:16:30.706 --> 00:16:32.296
and your app has a number

411
00:16:32.296 --> 00:16:34.626
of NSURLRequests it
would like to issue.

412
00:16:35.656 --> 00:16:37.586
What the Background Session
lets you do is create an

413
00:16:37.586 --> 00:16:41.836
NSURLSession, pass it
those NSURLRequests.

414
00:16:42.296 --> 00:16:44.586
But then, instead of
creating in-process tasks,

415
00:16:44.896 --> 00:16:46.956
those go out of process
to a system daemon

416
00:16:47.356 --> 00:16:49.316
that can then handle
executing those tasks for you.

417
00:16:49.726 --> 00:16:51.586
And if your app sticks around,

418
00:16:51.586 --> 00:16:53.946
then you'll get delegate methods
called on your delegate just

419
00:16:53.946 --> 00:16:55.846
like you normally would
with NSURLSession.

420
00:16:56.366 --> 00:17:00.086
But the really cool thing is
if your app happens to go away,

421
00:16:56.366 --> 00:17:00.086
But the really cool thing is
if your app happens to go away,

422
00:17:00.556 --> 00:17:03.506
let's say the user quits it,
maybe the system reboots,

423
00:17:04.056 --> 00:17:07.156
those tasks will stick around
in that out-of-process session

424
00:17:07.665 --> 00:17:10.445
and get processed while
your app isn't running.

425
00:17:11.016 --> 00:17:13.006
So, that means if you need to
do, you know, many hundreds

426
00:17:13.006 --> 00:17:15.596
of megabyte download, your app
doesn't have to stay running

427
00:17:15.596 --> 00:17:16.656
for that download to continue.

428
00:17:17.566 --> 00:17:19.336
Then, when your app
gets relaunched,

429
00:17:20.136 --> 00:17:23.195
you'll use the same
backgroundSession

430
00:17:23.195 --> 00:17:26.346
ConfigurationWithIdentifier
call and make sure you pass

431
00:17:26.346 --> 00:17:27.925
in the same identifier
as before,

432
00:17:28.236 --> 00:17:30.556
and you'll get reconnected
with that existing session

433
00:17:30.826 --> 00:17:33.906
and then get your delegate
methods called for those tasks

434
00:17:34.236 --> 00:17:35.766
for whatever progress
has happened

435
00:17:35.766 --> 00:17:37.446
on those tasks while
your app isn't running.

436
00:17:38.316 --> 00:17:41.536
This is already great
features in an iOS.

437
00:17:41.706 --> 00:17:44.596
It supports multitasking, so
your app can get re-awoken

438
00:17:44.596 --> 00:17:46.256
to receive these
delegate methods.

439
00:17:46.726 --> 00:17:50.366
But the really cool part
for power comes into play

440
00:17:50.366 --> 00:17:53.286
when we talk about the
concepts of discretionary tasks.

441
00:17:54.086 --> 00:17:55.306
So, there's a configuration

442
00:17:55.586 --> 00:17:57.856
on the NSURLSession
configuration object.

443
00:17:58.226 --> 00:18:00.186
You can set the discretionary
property to TRUE.

444
00:17:58.226 --> 00:18:00.186
You can set the discretionary
property to TRUE.

445
00:18:00.496 --> 00:18:03.496
And it's something
that's available in iOS 7

446
00:18:03.496 --> 00:18:04.976
or now in OS X Yosemite.

447
00:18:05.676 --> 00:18:08.666
And what this tells the system
to do is to pick the best time

448
00:18:08.666 --> 00:18:11.076
to do the work based on
a variety of factors,

449
00:18:11.186 --> 00:18:14.686
including system power state,
network state and more.

450
00:18:14.846 --> 00:18:18.316
And it will automatically
provide things

451
00:18:18.316 --> 00:18:20.456
like bandwidth monitoring
and automatic retry.

452
00:18:20.596 --> 00:18:22.376
So, bandwidth monitoring
is important

453
00:18:22.376 --> 00:18:24.836
because it's very energy
inefficient to do work

454
00:18:24.836 --> 00:18:26.546
over super-slow connections.

455
00:18:26.756 --> 00:18:28.856
And so, when you're using
the Background Session

456
00:18:28.856 --> 00:18:32.456
with a discretionary task, we'll
monitor the effective bandwidth.

457
00:18:32.456 --> 00:18:35.156
And if it falls below certain
levels, automatically stop

458
00:18:35.156 --> 00:18:36.646
and later retry that task

459
00:18:36.646 --> 00:18:38.556
to make sure we can download
it quickly and efficiently.

460
00:18:39.246 --> 00:18:41.906
We can also, because of
this, do automatic retry.

461
00:18:42.216 --> 00:18:43.636
So, if the network
gets disconnected,

462
00:18:43.926 --> 00:18:45.846
we'll then automatically
retry the task later

463
00:18:45.846 --> 00:18:48.616
when the network becomes
available, handling a variety

464
00:18:48.646 --> 00:18:51.886
of edge cases in uploads and
downloads automatically for you.

465
00:18:53.386 --> 00:18:56.516
Now, you can adjust this way
we schedule discretionary tasks

466
00:18:56.636 --> 00:18:58.756
by changing the
timeoutIntervalForResource

467
00:18:58.756 --> 00:19:00.496
property on the configuration
object.

468
00:18:58.756 --> 00:19:00.496
property on the configuration
object.

469
00:19:00.856 --> 00:19:02.726
So, in this case, we
specified one day.

470
00:19:02.726 --> 00:19:05.646
So then, we want this to happen
sometime within 24 hours.

471
00:19:06.206 --> 00:19:09.336
Now, if this timeout elapses,
you'll get an error thrown.

472
00:19:09.676 --> 00:19:11.556
So, generally, you want to
make sure this is long enough

473
00:19:11.556 --> 00:19:13.366
that we can reasonably
do the download,

474
00:19:13.886 --> 00:19:16.056
taking into account the fact
there might not always be

475
00:19:16.056 --> 00:19:17.436
appropriate networking
available.

476
00:19:18.206 --> 00:19:20.826
It's why anything less than
12 hours is probably going

477
00:19:20.826 --> 00:19:22.446
to put stress in
the system's ability

478
00:19:22.446 --> 00:19:23.706
to effectively do the work.

479
00:19:24.786 --> 00:19:28.096
This was a very high level
overview to NSURLSession,

480
00:19:28.096 --> 00:19:30.616
just enough to kind
of whet your appetite.

481
00:19:30.616 --> 00:19:33.396
If you want to learn more,
check out yesterday's What's New

482
00:19:33.396 --> 00:19:35.676
in Foundation Networking
talk, where they go

483
00:19:35.676 --> 00:19:36.566
into much more detail

484
00:19:36.566 --> 00:19:38.766
on the Background
Session and how to use it.

485
00:19:40.356 --> 00:19:42.756
So that was Do It
at a Better Time.

486
00:19:42.756 --> 00:19:45.346
We talked about how you can let
the system schedule your work

487
00:19:45.346 --> 00:19:46.716
for power optimum execution.

488
00:19:47.086 --> 00:19:48.566
But let's say you're
already executing,

489
00:19:49.086 --> 00:19:50.286
maybe at the better time.

490
00:19:51.106 --> 00:19:52.376
I want to talk now about ways

491
00:19:52.376 --> 00:19:54.076
that you can do your
work more efficiently.

492
00:19:55.316 --> 00:19:58.036
So, our system has a variety of
resource management properties.

493
00:19:58.426 --> 00:20:00.726
Some of these affect the
responsiveness of the system

494
00:19:58.426 --> 00:20:00.726
Some of these affect the
responsiveness of the system

495
00:20:00.726 --> 00:20:01.976
when a particular
task is going on.

496
00:20:02.656 --> 00:20:05.566
This includes things like
the CPU Scheduler Priority

497
00:20:05.646 --> 00:20:08.126
and the I/O Priority
for a particular task.

498
00:20:08.376 --> 00:20:11.446
We also have properties that
affect the efficiency of work.

499
00:20:11.826 --> 00:20:13.876
This includes the amount of
time we're coalescing or willing

500
00:20:13.876 --> 00:20:17.046
to apply, or hence, as to
whether we should run the CPU

501
00:20:17.046 --> 00:20:20.236
in a throughput or
efficiency-oriented mode.

502
00:20:21.316 --> 00:20:23.456
Now, these properties
are very difficult

503
00:20:23.456 --> 00:20:25.136
to specify individually.

504
00:20:25.226 --> 00:20:26.956
It's complicated
to get it right.

505
00:20:27.276 --> 00:20:29.976
And so, most developers are
simply left the whens they could

506
00:20:29.976 --> 00:20:31.556
get by using these
properties on the table.

507
00:20:32.226 --> 00:20:34.096
So, we want to make
this easy to be able

508
00:20:34.096 --> 00:20:37.016
to use the correct values
for all these properties.

509
00:20:37.406 --> 00:20:39.366
And in OS X Yosemite and iOS 8,

510
00:20:39.786 --> 00:20:41.326
we're introducing
something called Quality

511
00:20:41.326 --> 00:20:43.726
of Service Classes that
can help you do this.

512
00:20:44.316 --> 00:20:46.026
So, there are four Quality

513
00:20:46.026 --> 00:20:47.716
of Service Classes we have
defined on the system.

514
00:20:48.276 --> 00:20:50.306
The first is User
Interactive, which indicates

515
00:20:50.306 --> 00:20:51.736
that this work is involved

516
00:20:51.736 --> 00:20:53.836
in creating a smooth,
buttery user UI.

517
00:20:54.366 --> 00:20:56.676
It's these things like the
main thread, animations,

518
00:20:56.846 --> 00:20:59.386
event processing, whether
that's touch events or meeting

519
00:20:59.386 --> 00:21:02.176
or some other kind
of event processing

520
00:20:59.386 --> 00:21:02.176
or some other kind
of event processing

521
00:21:02.176 --> 00:21:04.516
where we need very,
very short latencies.

522
00:21:05.366 --> 00:21:08.836
User Initiated is
for doing request,

523
00:21:08.836 --> 00:21:11.426
making servicing requests
that the user has made in ways

524
00:21:11.426 --> 00:21:14.446
that we need to provide
immediate results.

525
00:21:14.596 --> 00:21:17.086
So, these are clicks on an
object to get more information

526
00:21:17.086 --> 00:21:18.406
about it in your user interface.

527
00:21:18.796 --> 00:21:20.596
The task of getting the
details of that object

528
00:21:20.596 --> 00:21:23.456
and populating them onscreen
would fall into User Initiated.

529
00:21:24.476 --> 00:21:26.736
Utility, for longer
running tasks.

530
00:21:26.736 --> 00:21:29.946
So User Initiated and User
Interactive are designed to be

531
00:21:29.946 --> 00:21:31.836
as performant as possible.

532
00:21:32.456 --> 00:21:35.216
Utility, we try to achieve a
good balance between throughput

533
00:21:35.216 --> 00:21:36.116
and energy efficiency.

534
00:21:36.306 --> 00:21:38.116
So, we want to put
longer-running tasks

535
00:21:38.456 --> 00:21:42.306
where we don't want to
have an over, we don't want

536
00:21:43.286 --> 00:21:45.416
to put a large power
drain on the system.

537
00:21:45.946 --> 00:21:47.526
And then Background, for things

538
00:21:47.526 --> 00:21:49.146
that are not visible
to the user.

539
00:21:49.986 --> 00:21:52.086
So, with all these
classes, how do you pick?

540
00:21:52.186 --> 00:21:55.486
So, the question you
want to ask yourself,

541
00:21:55.486 --> 00:21:58.396
or User Interactive is, Is
this work actively involved

542
00:21:58.396 --> 00:21:59.156
in updating the UI?

543
00:22:00.106 --> 00:22:02.796
If this doesn't happen, will
the UI appear to be frozen?

544
00:22:03.416 --> 00:22:05.106
This includes things
like the main thread,

545
00:22:05.106 --> 00:22:08.036
which we handle automatically
for you, animations

546
00:22:08.036 --> 00:22:09.736
or input event processing.

547
00:22:10.616 --> 00:22:12.536
If the answer is no,
then you want to think

548
00:22:12.536 --> 00:22:14.436
about User Initiated and
ask yourself the question,

549
00:22:14.676 --> 00:22:17.526
Is this work required to
continue user interaction?

550
00:22:18.296 --> 00:22:20.686
So, for example, is
this actively involved

551
00:22:20.686 --> 00:22:22.176
in loading content
that the user needs

552
00:22:22.176 --> 00:22:25.636
to see before they can make
the next user interaction

553
00:22:25.636 --> 00:22:26.466
in your application?

554
00:22:27.686 --> 00:22:29.186
If this isn't the
case, for example,

555
00:22:29.186 --> 00:22:31.936
the user initiates a task
and it's long running

556
00:22:31.936 --> 00:22:33.076
and displays a progress bar.

557
00:22:33.416 --> 00:22:35.266
So, either they can
continue interacting

558
00:22:35.266 --> 00:22:37.066
with your application
or you might expect them

559
00:22:37.066 --> 00:22:40.806
to take a break or go switch
to another app on OS X.

560
00:22:40.806 --> 00:22:42.916
You want to think about Utility.

561
00:22:42.976 --> 00:22:45.156
In which case, the question
you can ask yourself is,

562
00:22:45.926 --> 00:22:47.966
Is the user aware of the
progress of this work?

563
00:22:48.436 --> 00:22:50.656
If it's a longer-running job
with a progress indicator,

564
00:22:50.656 --> 00:22:52.416
that's perfectly
suited to Utility.

565
00:22:53.496 --> 00:22:55.606
And then finally,
for Background,

566
00:22:56.106 --> 00:22:56.966
that's the remaining work

567
00:22:56.966 --> 00:22:58.746
that the user isn't
aware of the progress of.

568
00:22:59.006 --> 00:23:00.706
And for Background work,
you want to ask yourself,

569
00:22:59.006 --> 00:23:00.706
And for Background work,
you want to ask yourself,

570
00:23:00.996 --> 00:23:03.896
Can this work be
deferred to a better time?

571
00:23:04.346 --> 00:23:07.016
If so, use the
NSBackgroundActivityScheduler

572
00:23:07.016 --> 00:23:09.206
object in addition to
running in Background.

573
00:23:10.506 --> 00:23:13.186
So, let's say you've gone
through, you've thought

574
00:23:13.186 --> 00:23:15.586
about a piece of work in your
application and you decide

575
00:23:15.586 --> 00:23:18.066
that User Initiated is
probably the right Quality

576
00:23:18.066 --> 00:23:18.926
of Service Class.

577
00:23:19.386 --> 00:23:21.516
Well, the next thing you want

578
00:23:21.516 --> 00:23:23.166
to do is ask yourself
a few more questions.

579
00:23:23.566 --> 00:23:27.396
The first is, Is it OK if User
Interactive work happens before

580
00:23:28.016 --> 00:23:29.076
my User Initiated work?

581
00:23:30.126 --> 00:23:31.986
Is it OK for this
work to compete

582
00:23:31.986 --> 00:23:33.336
with other User Initiated work?

583
00:23:34.086 --> 00:23:36.546
And is it OK for my
work to take precedence

584
00:23:36.546 --> 00:23:38.196
over Utility and
Background work?

585
00:23:38.866 --> 00:23:41.476
Ultimately, these Quality of
Service Classes form a hierarchy

586
00:23:41.906 --> 00:23:44.736
and the system will prefer
things higher up in this list.

587
00:23:44.736 --> 00:23:47.246
So, you want to make sure
that within your application,

588
00:23:47.656 --> 00:23:49.556
you've picked a set of
Quality of Service Classes

589
00:23:49.816 --> 00:23:51.736
that let the system
appropriately prioritize

590
00:23:51.736 --> 00:23:55.316
resources, which brings
us to what exactly happens

591
00:23:55.316 --> 00:23:57.116
when you specify a
Quality of Service Class.

592
00:23:57.116 --> 00:23:59.986
So, let's imagine we
have a Background Quality

593
00:23:59.986 --> 00:24:03.226
of Service operation running,
and it's using a lot of CPU

594
00:23:59.986 --> 00:24:03.226
of Service operation running,
and it's using a lot of CPU

595
00:24:03.226 --> 00:24:05.386
and has a lot of I/O going on.

596
00:24:06.006 --> 00:24:08.736
And then, a User
Initiated task comes around.

597
00:24:09.706 --> 00:24:11.626
Well, what the system is
going to do is it's going

598
00:24:11.626 --> 00:24:15.006
to prioritize resources to
the User Initiated task,

599
00:24:15.496 --> 00:24:18.126
letting that get the majority
of the throughput on the system

600
00:24:18.376 --> 00:24:20.086
and letting that
work happen quickly.

601
00:24:21.936 --> 00:24:26.656
Similarly, if we were to look at
power graphs for User Initiated

602
00:24:26.656 --> 00:24:29.806
and Background work, in User
Initiated, we run the work

603
00:24:29.806 --> 00:24:32.156
as quickly as possible,
but potentially

604
00:24:32.156 --> 00:24:33.576
in power-inefficient ways.

605
00:24:34.116 --> 00:24:36.896
Whereas, for Background work,
we will try to run the system

606
00:24:36.896 --> 00:24:38.306
in power-efficient ways.

607
00:24:38.346 --> 00:24:39.916
It might take slightly longer,

608
00:24:40.366 --> 00:24:42.726
but your overall energy
consumption will be reduced.

609
00:24:43.656 --> 00:24:46.526
And, of course, Utility falls
on the middle of the spectrum.

610
00:24:47.016 --> 00:24:48.066
And so in this way,

611
00:24:48.236 --> 00:24:50.346
by appropriately
classifying your Utility

612
00:24:50.346 --> 00:24:53.426
and Background work, you can
both improve the responsiveness

613
00:24:53.786 --> 00:24:55.816
of User Initiated and
User Interactive work

614
00:24:56.176 --> 00:24:58.286
and improve your overall
energy efficiency.

615
00:24:59.496 --> 00:25:00.356
All right.

616
00:24:59.496 --> 00:25:00.356
All right.

617
00:25:00.356 --> 00:25:02.266
So, let's take a look at
an example application

618
00:25:02.266 --> 00:25:05.626
and how we might apply
Quality of Service to it.

619
00:25:05.866 --> 00:25:07.906
So, we have PhotoMeister 3000.

620
00:25:07.906 --> 00:25:09.956
It's our kind of generic
photos application.

621
00:25:10.396 --> 00:25:13.236
You connect the camera
containing a bunch of RAW images

622
00:25:13.556 --> 00:25:15.516
and we pull off some
JPEG previews

623
00:25:15.726 --> 00:25:17.036
and display a bunch
of thumbnails.

624
00:25:17.036 --> 00:25:18.466
And then in the background,

625
00:25:18.676 --> 00:25:20.506
load the full-size
images and convert them.

626
00:25:21.296 --> 00:25:23.026
They, of course also
have search functionality

627
00:25:23.026 --> 00:25:24.816
because every app needs
search functionality.

628
00:25:24.816 --> 00:25:28.096
So, how do we apply
Quality of Service?

629
00:25:28.386 --> 00:25:30.326
Well, User Interactive
is just going to be used

630
00:25:30.326 --> 00:25:32.026
for the main thread
in our application.

631
00:25:32.246 --> 00:25:33.866
And that happens automatically

632
00:25:33.866 --> 00:25:35.546
without you having
to do any work.

633
00:25:37.566 --> 00:25:40.156
User Initiated, we're going to
use for thumbnail generation.

634
00:25:40.156 --> 00:25:43.746
And this is because the
user plugs in their camera,

635
00:25:43.746 --> 00:25:44.666
and the next thing they want

636
00:25:44.666 --> 00:25:46.136
to do is start browsing
the thumbnails.

637
00:25:46.406 --> 00:25:48.596
And so, their ability to
make the next interaction

638
00:25:48.596 --> 00:25:51.326
with their application is
dependent upon those thumbnails

639
00:25:51.326 --> 00:25:51.986
being available.

640
00:25:52.136 --> 00:25:53.916
So, it's going to run
at User Initiated.

641
00:25:53.916 --> 00:25:56.776
Now, imagine that the user
is browsing these thumbnails

642
00:25:56.776 --> 00:25:59.326
and they click on one to try
to view the photo full size.

643
00:25:59.736 --> 00:26:02.126
Their next interaction, which
might be looking at the photos,

644
00:25:59.736 --> 00:26:02.126
Their next interaction, which
might be looking at the photos,

645
00:26:02.126 --> 00:26:04.196
scrolling through it,
depends on the ability

646
00:26:04.196 --> 00:26:05.566
to load that full-size image.

647
00:26:05.976 --> 00:26:08.486
So, we're going to load
just that particular image

648
00:26:08.486 --> 00:26:09.996
in that case at User Initiated.

649
00:26:11.116 --> 00:26:13.666
But all the other images we're
going to load off the camera

650
00:26:13.666 --> 00:26:15.686
and convert should
happen at Utility.

651
00:26:15.776 --> 00:26:17.876
The user might be able to
see the progress of it,

652
00:26:18.056 --> 00:26:21.486
but you want this work to
happen in deference to the work

653
00:26:21.486 --> 00:26:23.706
of updating the UI, scrolling,

654
00:26:23.706 --> 00:26:25.196
displaying the thumbnails
and so on.

655
00:26:25.726 --> 00:26:28.576
And finally, any
work we have to do

656
00:26:28.576 --> 00:26:30.566
to update our search index
would happen at Background.

657
00:26:31.186 --> 00:26:33.296
This isn't something the user
is aware of the progress of.

658
00:26:33.496 --> 00:26:35.846
And so, we want it to happen
in deference to things

659
00:26:35.846 --> 00:26:37.186
like loading the
images off the camera.

660
00:26:37.846 --> 00:26:42.166
So, let's imagine that our
app, we're trying to figure

661
00:26:42.166 --> 00:26:43.096
out how to build this thing.

662
00:26:43.456 --> 00:26:47.206
Let's kind of create a simple
NSOperation-based approach

663
00:26:47.206 --> 00:26:49.316
to writing this application.

664
00:26:50.086 --> 00:26:53.066
We might create an
NSOperationQueue

665
00:26:53.066 --> 00:26:55.416
for thumbnail generation
and create an NSOperation

666
00:26:55.416 --> 00:26:56.716
for each thumbnail
we want to generate.

667
00:26:57.246 --> 00:27:00.456
And we might create another
queue for image conversion

668
00:26:57.246 --> 00:27:00.456
And we might create another
queue for image conversion

669
00:27:00.906 --> 00:27:03.066
and an operation for each
image we want to convert.

670
00:27:04.046 --> 00:27:06.606
So, how does this play into QOS?

671
00:27:07.436 --> 00:27:12.516
So, in OS X Yosemite
and iOS 8, NSOperation,

672
00:27:12.616 --> 00:27:15.606
NSOperationQueue now have
a qualityOfService property

673
00:27:15.836 --> 00:27:17.836
that you can use
to set what Quality

674
00:27:17.836 --> 00:27:19.296
of Service particular
work should run at.

675
00:27:19.896 --> 00:27:22.476
So, if we want to run an
NSOperation at Utility,

676
00:27:22.856 --> 00:27:25.146
we can simply say
operation.qualityOfService

677
00:27:25.146 --> 00:27:27.056
equals
NSQualityOfServiceUtility.

678
00:27:27.496 --> 00:27:31.486
If you set a Quality of
Service on both an operation

679
00:27:31.606 --> 00:27:33.956
and the queue, we'll use
the higher of the two.

680
00:27:35.106 --> 00:27:37.776
And if you don't set
NSOperation, for example,

681
00:27:37.776 --> 00:27:39.976
in the code you're shipping
today, we will attempt

682
00:27:39.976 --> 00:27:43.116
to infer an NSOperation from the
environment whenever possible.

683
00:27:43.476 --> 00:27:45.846
So, what this means is that
if you have code executing

684
00:27:45.846 --> 00:27:47.276
at Utility Quality of Service

685
00:27:47.656 --> 00:27:50.576
and you create a new
NSOperation inside of that code,

686
00:27:51.086 --> 00:27:53.746
that new NSOperation will
automatically use Utility

687
00:27:54.136 --> 00:27:56.466
if there isn't a Quality
of Service set later

688
00:27:56.466 --> 00:27:58.016
on that operation
or on the queue.

689
00:27:58.626 --> 00:28:03.386
So, if we go back to
our application example,

690
00:27:58.626 --> 00:28:03.386
So, if we go back to
our application example,

691
00:28:03.456 --> 00:28:05.746
if we want to apply
Quality of Service to this,

692
00:28:05.746 --> 00:28:07.676
the first thing we'll
do is set User Initiated

693
00:28:07.676 --> 00:28:10.906
on our thumbnail generation
queue, and then Utility

694
00:28:11.216 --> 00:28:12.386
on our image conversion queue.

695
00:28:12.826 --> 00:28:14.426
And now, those pieces
of work will happen

696
00:28:14.426 --> 00:28:16.126
at the appropriate
Quality of Service.

697
00:28:17.196 --> 00:28:19.596
But Quality of Service
isn't static.

698
00:28:19.966 --> 00:28:21.406
And the logical Quality
of Service

699
00:28:21.406 --> 00:28:23.186
of an operation might
change over time.

700
00:28:23.646 --> 00:28:26.466
So, for example, you start
doing a conversion of an image

701
00:28:26.706 --> 00:28:28.986
at Utility but the user
wants to view the result.

702
00:28:29.646 --> 00:28:32.466
Well now, that work needs to
happen at User Initiated Quality

703
00:28:32.466 --> 00:28:33.716
of Service instead of Utility.

704
00:28:35.316 --> 00:28:36.996
With NSOperation,
we have three ways

705
00:28:36.996 --> 00:28:40.046
that we can promote the Quality
of Service of existing work.

706
00:28:40.646 --> 00:28:43.836
The first is enqueueing a higher
Quality of Service operation

707
00:28:43.836 --> 00:28:45.256
on the same queue as that work.

708
00:28:46.176 --> 00:28:49.006
If you have a queue full
of utility operations

709
00:28:49.376 --> 00:28:51.166
and you enqueue something
that's User Initiated,

710
00:28:51.606 --> 00:28:54.656
we will then promote everything
in front of that operation.

711
00:28:54.796 --> 00:28:55.936
Also, to User Initiated.

712
00:28:56.256 --> 00:28:58.796
So, that operation gets to the
front of the queue and runs

713
00:28:58.796 --> 00:29:00.546
at an appropriate time.

714
00:28:58.796 --> 00:29:00.546
at an appropriate time.

715
00:29:01.566 --> 00:29:05.196
If you use addDependency and
make a, let's for example,

716
00:29:05.326 --> 00:29:07.226
User Initiated operation
dependent

717
00:29:07.356 --> 00:29:09.616
on a Background operation,
we'll promote

718
00:29:09.616 --> 00:29:11.526
that Background operation
to User Initiated.

719
00:29:11.986 --> 00:29:14.486
And finally, if you
use waitUntilFinished

720
00:29:14.516 --> 00:29:16.376
or waitUntilAllOperations

721
00:29:16.376 --> 00:29:18.686
AreFinished from a higher
Quality of Service thread,

722
00:29:18.686 --> 00:29:20.996
we will promote the
operations you're waiting on.

723
00:29:21.546 --> 00:29:24.026
So, if we go back
to our example,

724
00:29:24.196 --> 00:29:27.206
and let's say you get an event
that indicates the user tapped

725
00:29:27.206 --> 00:29:29.326
on a particular image
to view it full size,

726
00:29:30.136 --> 00:29:32.696
the first thing you'll do is
find the operation associated

727
00:29:32.696 --> 00:29:33.826
with converting that image.

728
00:29:34.956 --> 00:29:36.506
You'll then adjust
this queuePriority

729
00:29:36.656 --> 00:29:39.766
to set queuePriority very
high, and after that,

730
00:29:40.126 --> 00:29:42.226
adjust its Quality of
Service to set its Quality

731
00:29:42.226 --> 00:29:43.446
of Service to User Initiated.

732
00:29:44.006 --> 00:29:45.286
And now, if this is our queue,

733
00:29:46.276 --> 00:29:48.606
we've now promoted the operation
we care about to the front

734
00:29:48.606 --> 00:29:51.836
of that queue by adjusting the
queuePriority, and then cause it

735
00:29:51.836 --> 00:29:52.796
to run at User Initiated

736
00:29:52.966 --> 00:29:54.446
by adjusting the
Quality of Service.

737
00:29:56.986 --> 00:29:58.676
All right.

738
00:29:58.676 --> 00:29:59.336
So, quiz time.

739
00:29:59.496 --> 00:29:59.976
This is your turn.

740
00:30:00.326 --> 00:30:02.096
We have another example
app and I'm going to walk

741
00:30:02.096 --> 00:30:04.336
through the different features
of this app, and I want you

742
00:30:04.336 --> 00:30:06.186
to think about what
Quality of Service each

743
00:30:06.186 --> 00:30:07.326
of these features should run at.

744
00:30:07.676 --> 00:30:08.696
Then, I'll let you
know the answer.

745
00:30:09.556 --> 00:30:11.546
So, it's Feed Reader 9000.

746
00:30:11.546 --> 00:30:15.326
It's a kind of typical RSS
or newsreader application.

747
00:30:15.776 --> 00:30:19.326
So, if the user clicks on a
particular item in the feed

748
00:30:19.466 --> 00:30:21.676
and we need to display
the content of that item,

749
00:30:22.386 --> 00:30:26.716
the work to read the item on
our database, render the HTML,

750
00:30:26.766 --> 00:30:28.006
generally get it onscreen.

751
00:30:28.416 --> 00:30:30.276
What do you think
that might run at?

752
00:30:30.756 --> 00:30:35.096
So, that's going to
run at User Initiated.

753
00:30:35.336 --> 00:30:38.126
The user asked for it,
and so we need to display

754
00:30:38.126 --> 00:30:40.116
that content before the
user can interact with it.

755
00:30:40.616 --> 00:30:43.726
But it's not actively
involved scrolling

756
00:30:43.726 --> 00:30:47.016
or otherwise be creating
a buttery user experience.

757
00:30:47.236 --> 00:30:49.606
It's certainly longer
running work than that.

758
00:30:50.336 --> 00:30:52.886
Now, imagine all the
users reading this item,

759
00:30:52.886 --> 00:30:55.656
at the same time, we're
pre-fetching images

760
00:30:55.906 --> 00:30:58.396
that happen later on
in this stream of news.

761
00:30:58.906 --> 00:31:02.046
What Quality of Service
might that run at?

762
00:30:58.906 --> 00:31:02.046
What Quality of Service
might that run at?

763
00:31:04.696 --> 00:31:06.556
So, we're going to want
to run that at Background.

764
00:31:06.556 --> 00:31:08.686
The user is not aware of
the progress of this work.

765
00:31:09.026 --> 00:31:12.426
And so, we don't need to
give it quite the performance

766
00:31:12.426 --> 00:31:12.986
of Utility.

767
00:31:13.636 --> 00:31:15.356
The Background work
will certainly happen

768
00:31:15.616 --> 00:31:18.046
and we'll be able to
catch those images.

769
00:31:18.296 --> 00:31:20.656
Of course, if the user then
goes to that post or wants

770
00:31:20.656 --> 00:31:21.726
to promote that operation.

771
00:31:23.196 --> 00:31:26.796
What about fetching
new content, new feeds?

772
00:31:27.406 --> 00:31:32.526
So, this one is kind
of a trick question.

773
00:31:33.056 --> 00:31:34.976
If the user requested
the content,

774
00:31:34.976 --> 00:31:38.156
so they click Get New Items
or Get New Feeds button,

775
00:31:38.676 --> 00:31:41.316
the expectation is that now
they're going to be watching

776
00:31:41.316 --> 00:31:43.946
that list of items and be
unable to interact with it

777
00:31:43.946 --> 00:31:46.146
until we've populated
it with new entries.

778
00:31:46.466 --> 00:31:49.446
In that case, doing just the
minimum amount of work possible,

779
00:31:49.636 --> 00:31:51.956
to get the list of items
that they can browse through,

780
00:31:52.176 --> 00:31:53.266
should be User Initiated.

781
00:31:53.956 --> 00:31:56.486
On the other hand, this
happens automatically.

782
00:31:56.486 --> 00:31:57.906
Let's say we have a timer,

783
00:31:58.146 --> 00:32:00.906
hopefully using
NSBackgroundActivityScheduler

784
00:31:58.146 --> 00:32:00.906
hopefully using
NSBackgroundActivityScheduler

785
00:32:01.326 --> 00:32:04.376
that causes us to fetch
new content every hour.

786
00:32:04.796 --> 00:32:06.296
That work should
happen at Utility.

787
00:32:07.376 --> 00:32:09.576
This is something the user
is aware of the progress of.

788
00:32:09.576 --> 00:32:11.186
If it doesn't happen
then, obviously,

789
00:32:11.186 --> 00:32:13.106
they won't see their new items.

790
00:32:13.446 --> 00:32:14.566
But they're not watching for it

791
00:32:14.566 --> 00:32:16.286
and it's not preventing
their further interaction.

792
00:32:16.796 --> 00:32:19.246
And finally, search indexing.

793
00:32:22.516 --> 00:32:24.866
This would happen at Background
because the user isn't aware

794
00:32:24.866 --> 00:32:26.016
of the progress of this work.

795
00:32:26.596 --> 00:32:30.306
So, you've taken
your application.

796
00:32:30.306 --> 00:32:32.526
You've diligently gone
through and adopted Quality

797
00:32:32.526 --> 00:32:33.416
of Service everywhere.

798
00:32:33.496 --> 00:32:34.606
All your work is classified.

799
00:32:34.836 --> 00:32:36.186
How do you actually validate

800
00:32:36.186 --> 00:32:37.506
that this is working
and debug it?

801
00:32:37.796 --> 00:32:39.786
So, there are three things
that you'll want to do.

802
00:32:40.216 --> 00:32:42.256
The first is after
adopting Quality of Service,

803
00:32:42.256 --> 00:32:44.976
set breakpoints to confirm
that your work is running

804
00:32:44.976 --> 00:32:46.576
with the Quality of
Service you adopted.

805
00:32:47.026 --> 00:32:50.386
Use the powermetrics
tool to confirm

806
00:32:50.386 --> 00:32:53.916
for a longer running task which
Quality of Services are in use.

807
00:32:54.426 --> 00:32:58.216
And then you can use the
spindump tool to determine

808
00:32:58.216 --> 00:32:59.726
which Quality of Service
a particular piece

809
00:32:59.726 --> 00:33:02.446
of code is executing with
if what you find using one

810
00:32:59.726 --> 00:33:02.446
of code is executing with
if what you find using one

811
00:33:02.446 --> 00:33:03.746
of these other methods
is unexpected.

812
00:33:05.386 --> 00:33:07.956
So, let's start with
the first of these.

813
00:33:08.286 --> 00:33:12.306
In Xcode 6, if you first pause
your application, whether using,

814
00:33:12.306 --> 00:33:15.826
just pausing it or setting a
breakpoint, and then you go

815
00:33:15.826 --> 00:33:18.396
to the CPU debug gauge, which
is part of the debug navigator.

816
00:33:18.596 --> 00:33:20.736
Most of you are probably
familiar with this.

817
00:33:21.086 --> 00:33:23.796
The top, you see a graph
of CPU use over time.

818
00:33:24.246 --> 00:33:25.246
And so, we can see
in our example,

819
00:33:25.246 --> 00:33:27.126
we have something burning CPU.

820
00:33:27.816 --> 00:33:29.516
If you then go down
through the threads list,

821
00:33:30.086 --> 00:33:32.936
underneath each thread will
tell you what Quality of Service

822
00:33:32.936 --> 00:33:34.136
that thread currently has.

823
00:33:34.136 --> 00:33:36.396
So, in this case, this
thread has Utility.

824
00:33:36.436 --> 00:33:38.796
And so, we know that that CPU
time is happening at Utility.

825
00:33:39.606 --> 00:33:41.746
Now, this is the
Quality of Service

826
00:33:41.746 --> 00:33:42.806
that your code requested.

827
00:33:43.256 --> 00:33:45.566
So, if you start an operation at
a particular Quality of Service,

828
00:33:45.566 --> 00:33:46.786
that's what will
be displayed here.

829
00:33:47.326 --> 00:33:49.016
If another part of
your application tries

830
00:33:49.016 --> 00:33:51.666
to change the Quality of Service
of that thread, for example,

831
00:33:51.666 --> 00:33:53.566
using the override
API that you'll learn

832
00:33:53.566 --> 00:33:57.026
about in a session later
today, that won't appear here.

833
00:33:59.016 --> 00:34:00.386
So, let's say you've
gone through,

834
00:33:59.016 --> 00:34:00.386
So, let's say you've
gone through,

835
00:34:00.516 --> 00:34:03.846
validated your initial adoption,
and now you want to know, OK,

836
00:34:04.066 --> 00:34:06.656
what is my code actually
using in practice?

837
00:34:06.656 --> 00:34:09.726
You can use the powermetrics
command line tool

838
00:34:09.726 --> 00:34:12.226
with the show-process-QOS to see

839
00:34:12.226 --> 00:34:13.746
where your code is
spending time.

840
00:34:14.606 --> 00:34:16.946
So, in this case,
we'll run powermetrics

841
00:34:17.065 --> 00:34:18.436
and we'll get a list
of running tasks

842
00:34:18.436 --> 00:34:20.085
and we can see MyApplication
is here.

843
00:34:20.606 --> 00:34:23.536
And I'm spending 80
milliseconds per second

844
00:34:23.536 --> 00:34:26.446
on the CPU, or about 8 percent.

845
00:34:26.446 --> 00:34:29.985
I can see some information
about timers, which we'll talk

846
00:34:29.985 --> 00:34:30.846
about later in the talk.

847
00:34:31.286 --> 00:34:34.106
But then, what's important to
us here is I get a breakdown

848
00:34:34.106 --> 00:34:36.085
of what Quality of Service
Classes I was using.

849
00:34:36.226 --> 00:34:39.755
So, I can see that I'm spending
88 milliseconds at Utility,

850
00:34:39.976 --> 00:34:41.446
so almost all of
my time is there.

851
00:34:41.686 --> 00:34:42.626
And if that's what I wanted,

852
00:34:42.626 --> 00:34:44.775
then I've done a good job
adopting Quality of Service.

853
00:34:45.556 --> 00:34:47.996
Now, if you find that what
you see here isn't expected,

854
00:34:49.436 --> 00:34:50.746
you can use the spindump tool

855
00:34:50.746 --> 00:34:52.606
to get a more detailed
understanding

856
00:34:52.606 --> 00:34:54.596
of where your code is
executing with respect

857
00:34:54.596 --> 00:34:55.636
to Quality of Service.

858
00:34:56.295 --> 00:34:57.526
So, if you're not
familiar with spindump,

859
00:34:57.526 --> 00:34:59.466
it's kind of like
sample or time profile.

860
00:34:59.466 --> 00:35:01.186
It's a sampling-based profiler.

861
00:34:59.466 --> 00:35:01.186
It's a sampling-based profiler.

862
00:35:01.946 --> 00:35:05.956
But in OS X Yosemite, we added a
new option, the timeline option

863
00:35:06.636 --> 00:35:11.436
that can show your stacks
chronologically instead

864
00:35:11.436 --> 00:35:12.856
of by heaviest first.

865
00:35:14.026 --> 00:35:15.646
So, in this case,
we've run spindump

866
00:35:15.646 --> 00:35:16.476
against our application.

867
00:35:17.156 --> 00:35:19.706
And you can see that we
have a particular thread

868
00:35:19.706 --> 00:35:21.326
and it starts at
executing Utility.

869
00:35:21.956 --> 00:35:25.676
And then, if later that thread
happens to change to executing

870
00:35:25.676 --> 00:35:29.056
at Background, we'll see another
indication of our Quality

871
00:35:29.056 --> 00:35:29.986
of Service of that thread.

872
00:35:29.986 --> 00:35:31.706
In this way, you
can kind of walk

873
00:35:31.706 --> 00:35:33.576
through what code
you're executed during,

874
00:35:34.526 --> 00:35:36.806
what code your app executed
during the spindump,

875
00:35:37.356 --> 00:35:39.596
and see what Quality of
Services that code was using.

876
00:35:40.146 --> 00:35:43.846
So, that's Quality of Service.

877
00:35:44.186 --> 00:35:46.156
It lets you specify
the responsiveness

878
00:35:46.156 --> 00:35:47.456
and energy requirements of work.

879
00:35:47.886 --> 00:35:49.466
We expose it as both
a foundation

880
00:35:49.466 --> 00:35:51.896
and C-level APIs
including dispatch.

881
00:35:52.586 --> 00:35:56.146
It lets you, your goal just
kind of immediately walking

882
00:35:56.146 --> 00:35:58.656
out of the session, should be
to try to classify long running

883
00:35:58.656 --> 00:36:01.186
or resource intensive
parts of your application.

884
00:35:58.656 --> 00:36:01.186
or resource intensive
parts of your application.

885
00:36:01.746 --> 00:36:04.176
And this can get you the biggest
bang for the buck both in terms

886
00:36:04.176 --> 00:36:07.016
of responsiveness benefits
and energy improvement.

887
00:36:08.056 --> 00:36:09.876
And you want to try
to aim for 90 percent

888
00:36:09.876 --> 00:36:13.116
of your application's execution
to be at Utility or below

889
00:36:13.116 --> 00:36:15.656
when the user isn't
actively interacting

890
00:36:15.656 --> 00:36:16.396
with your application.

891
00:36:17.056 --> 00:36:19.936
This is kind of a
high-level overview.

892
00:36:20.056 --> 00:36:22.466
There's a lot more details
including discussion

893
00:36:22.466 --> 00:36:24.936
of the dispatch-based APIs
that you can use for this

894
00:36:25.136 --> 00:36:26.186
at the Power Performance

895
00:36:26.186 --> 00:36:28.936
and Diagnostic session
tomorrow afternoon.

896
00:36:29.306 --> 00:36:31.446
I highly encourage
you to attend that.

897
00:36:33.716 --> 00:36:36.006
So, that was Do It
More Efficiently.

898
00:36:36.756 --> 00:36:38.426
So, let's talk about Do It Less.

899
00:36:39.376 --> 00:36:41.436
So, you're running your
code at the right time.

900
00:36:42.036 --> 00:36:42.816
You're not doing work.

901
00:36:42.816 --> 00:36:43.476
You don't need to.

902
00:36:43.476 --> 00:36:45.486
You're doing it with
Quality of Service specified.

903
00:36:46.336 --> 00:36:49.126
Now, how do you just simply
make your code do less work?

904
00:36:50.166 --> 00:36:51.726
So, we're going to talk
about three things.

905
00:36:52.226 --> 00:36:55.986
CPU, Graphics, and Storage,
and techniques you can use

906
00:36:55.986 --> 00:36:57.836
to improve your efficiency
in each of these areas.

907
00:36:58.966 --> 00:37:01.036
But before we talk
about a specific topic,

908
00:36:58.966 --> 00:37:01.036
But before we talk
about a specific topic,

909
00:37:01.036 --> 00:37:03.446
how do you just generally
monitor your energy consumption?

910
00:37:04.306 --> 00:37:08.456
Well, if you are debugging your
application in Xcode and you go

911
00:37:08.456 --> 00:37:12.336
to Debug Navigator, there's
the energy impact gauge.

912
00:37:12.996 --> 00:37:16.226
This is an indication of how
much energy your app is using,

913
00:37:16.226 --> 00:37:17.906
taking into account
a variety of factors.

914
00:37:18.216 --> 00:37:20.126
And you can see in this case,

915
00:37:20.126 --> 00:37:24.756
our application has high energy
impact that is unexpected or bad

916
00:37:24.846 --> 00:37:26.766
if we don't think we're
doing something that's

917
00:37:26.766 --> 00:37:27.506
energy intensive.

918
00:37:27.506 --> 00:37:30.576
And so, you want to keep an
eye on the energy impact gauge,

919
00:37:30.896 --> 00:37:33.626
and what your application is
scoring on as you're developing,

920
00:37:33.966 --> 00:37:36.076
to look for things that
are unexpectedly expensive.

921
00:37:36.596 --> 00:37:39.616
So, with that, let's
dive into CPU.

922
00:37:39.986 --> 00:37:42.336
So, why is it important
to reduce CPU use?

923
00:37:43.226 --> 00:37:46.006
Well, if I have 1
percent CPU use,

924
00:37:46.266 --> 00:37:49.416
I'm going to cause 10 percent
higher power draw from the CPU.

925
00:37:49.996 --> 00:37:54.726
If I have 10 percent CPU use, I
will cause two times the amount

926
00:37:54.726 --> 00:37:56.476
of power draw compared
to an idle CPU.

927
00:37:57.076 --> 00:38:00.786
And finally, if I have
100 percent CPU use,

928
00:37:57.076 --> 00:38:00.786
And finally, if I have
100 percent CPU use,

929
00:38:00.786 --> 00:38:03.036
I will cause 10 times
the power draw.

930
00:38:03.626 --> 00:38:07.346
And so, in this way, your use of
the CPU can have a huge impact

931
00:38:07.346 --> 00:38:10.996
on the amount of power
consumed by your application.

932
00:38:11.356 --> 00:38:15.706
Now, if we go back to
our Debug Navigator,

933
00:38:15.986 --> 00:38:17.676
we can look at the CPU gauge

934
00:38:18.166 --> 00:38:20.966
to see how much CPU our
app is using over time.

935
00:38:21.316 --> 00:38:22.836
This is another thing you
want to try to monitor

936
00:38:22.836 --> 00:38:25.346
as you're developing your
app, to look for places

937
00:38:25.346 --> 00:38:27.226
where you're using
unexpected amounts of CPU.

938
00:38:28.356 --> 00:38:30.696
If you do find you're using
more CPU than you expect,

939
00:38:31.216 --> 00:38:33.486
your best friend is going to
be Instruments Time Profiler.

940
00:38:33.906 --> 00:38:36.946
There's a variety of
talks and guides online

941
00:38:36.946 --> 00:38:38.186
on how to use Time Profiler.

942
00:38:38.726 --> 00:38:40.106
But the short of it is
that it lets you see

943
00:38:40.106 --> 00:38:42.346
where your application is
spending its time to look

944
00:38:42.346 --> 00:38:44.196
for CPU-intensive
routines that you can try

945
00:38:44.196 --> 00:38:45.436
to optimize or eliminate.

946
00:38:47.356 --> 00:38:50.666
One feature that's new in Xcode
6 is Performance Unit Tests.

947
00:38:51.376 --> 00:38:53.486
This is an addition
to the XCTestCase API,

948
00:38:53.486 --> 00:38:56.286
and it helps you find
performance regressions

949
00:38:56.286 --> 00:38:58.016
in your code by measuring
the performance

950
00:38:58.016 --> 00:38:59.806
of particular parts
of your application.

951
00:39:00.066 --> 00:39:03.596
I mentioned before performance
and energy go hand in hand.

952
00:39:03.936 --> 00:39:06.096
And so, making sure you're
doing good performance testing

953
00:39:06.096 --> 00:39:09.396
of your code can help you
find energy regressions early.

954
00:39:10.546 --> 00:39:12.506
API is pretty simple.

955
00:39:12.616 --> 00:39:14.066
You simply call measureBlock

956
00:39:14.066 --> 00:39:15.646
and tell it what code
you want to measure.

957
00:39:16.166 --> 00:39:19.276
And then you'll get a
variety of performance metrics

958
00:39:19.636 --> 00:39:24.476
from that code, including, for
our purposes here, wall time.

959
00:39:24.476 --> 00:39:27.956
If you want to learn more
about this, you should check

960
00:39:27.956 --> 00:39:30.996
out Testing in Xcode 6
and Continuous Integration

961
00:39:30.996 --> 00:39:33.956
with Xcode 6 tomorrow, and
I'll have all these at the end

962
00:39:33.956 --> 00:39:34.956
of the presentation as well.

963
00:39:35.566 --> 00:39:38.986
So, that's reducing CPU use.

964
00:39:39.506 --> 00:39:42.426
And remember that CPU has a
huge dynamic range in power.

965
00:39:43.496 --> 00:39:45.566
Monitor CPU with the
Xcode debug gauge

966
00:39:45.566 --> 00:39:46.936
as you're developing
your application.

967
00:39:48.316 --> 00:39:50.396
Profile your code with
Instruments to find

968
00:39:50.396 --> 00:39:53.346
and eliminate CPU
hogging routines.

969
00:39:54.846 --> 00:39:57.756
And use performance unit
tests to prevent regressions.

970
00:40:00.066 --> 00:40:02.636
Now, reducing the amount
of CPU use is important,

971
00:40:02.636 --> 00:40:04.786
but it's also important
to consider how you use it

972
00:40:04.786 --> 00:40:07.206
in the context of fixed costs
that we discussed earlier.

973
00:40:07.496 --> 00:40:10.906
So, you want to make sure
you minimize timer use

974
00:40:10.906 --> 00:40:11.656
in your application.

975
00:40:12.126 --> 00:40:14.976
There are lots of
timer APIs in a system.

976
00:40:14.976 --> 00:40:18.496
Everything from NSTimer,
Grand Central Dispatch timers,

977
00:40:18.676 --> 00:40:23.386
CVDisplayLink, all these
APIs will cause timer wakeups

978
00:40:23.386 --> 00:40:24.536
to happen in your application.

979
00:40:24.536 --> 00:40:27.626
And so it's important to
understand how you're using them

980
00:40:27.886 --> 00:40:29.936
and make sure to minimize
your use of these sorts

981
00:40:29.936 --> 00:40:31.376
of APIs as much as possible.

982
00:40:31.726 --> 00:40:35.236
And if we go back to one of our
power graphs, if we imagine each

983
00:40:35.236 --> 00:40:37.776
of these small units of work
is actually a timer firing

984
00:40:37.776 --> 00:40:42.386
in your application, we now
pay all of this fixed cost just

985
00:40:42.576 --> 00:40:44.456
to service these
very small timers.

986
00:40:44.986 --> 00:40:48.116
Who knows whether these are
actually important or not?

987
00:40:48.556 --> 00:40:53.836
So, what you can do is use the
Energy Impact Gauge in Xcode

988
00:40:53.966 --> 00:40:56.376
and look at the wakes
in CPU area

989
00:40:56.376 --> 00:40:58.656
to see how often your
application is waking due

990
00:40:58.656 --> 00:40:59.546
to a timer firing.

991
00:41:00.606 --> 00:41:02.236
If you find this is
higher than expected,

992
00:41:03.466 --> 00:41:05.446
you can use the timerfires
command line tool.

993
00:41:05.516 --> 00:41:07.826
And in this case, we'll
want it with a dash-g option

994
00:41:08.036 --> 00:41:09.756
that gives us a summary
of the timers

995
00:41:09.756 --> 00:41:10.866
that fired in our application.

996
00:41:11.096 --> 00:41:13.516
So, you start this tool,
run your application

997
00:41:13.596 --> 00:41:16.246
for a little while, kill
the tool with Control-C,

998
00:41:17.586 --> 00:41:19.656
and then you'll get
a list of the timers

999
00:41:19.656 --> 00:41:21.786
that fired while the tool was
running in your application.

1000
00:41:21.976 --> 00:41:25.676
In this case, we can see we
had a lot of calls to sleep,

1001
00:41:26.066 --> 00:41:29.046
some dispatch timers and
what routine they called,

1002
00:41:29.046 --> 00:41:30.736
and some CF timers, what
routine they called.

1003
00:41:32.396 --> 00:41:34.206
Now, reducing timers is great.

1004
00:41:34.326 --> 00:41:36.836
Sometimes, you can't
eliminate a timer completely.

1005
00:41:37.286 --> 00:41:39.816
In that case, you want to
help the system do a good job

1006
00:41:39.816 --> 00:41:42.016
of scheduling that timer
in energy efficient time.

1007
00:41:42.676 --> 00:41:44.906
This includes just something
we call Timer Coalescing.

1008
00:41:45.106 --> 00:41:48.276
This is a feature we introduced
in last year's releases.

1009
00:41:49.156 --> 00:41:51.516
And what this does
is take timers

1010
00:41:51.516 --> 00:41:54.196
that are firing the
system and coalesce them

1011
00:41:54.196 --> 00:41:55.536
to fire at the same time.

1012
00:41:55.686 --> 00:41:57.276
In this way, we can
keep the system

1013
00:41:57.276 --> 00:41:58.536
in an idle state for longer.

1014
00:41:59.456 --> 00:42:02.226
And we will try to do this
as best we can but we have

1015
00:41:59.456 --> 00:42:02.226
And we will try to do this
as best we can but we have

1016
00:42:02.226 --> 00:42:03.816
to subject it to
some limitations

1017
00:42:03.816 --> 00:42:07.716
to make sure we don't delay a
timer more than is appropriate.

1018
00:42:08.536 --> 00:42:10.216
But you can help us
determine the amount

1019
00:42:10.216 --> 00:42:12.586
of tolerance you're willing that
time, for that timer to have

1020
00:42:13.126 --> 00:42:16.146
by specifying a timer tolerance
whenever you create a timer.

1021
00:42:16.826 --> 00:42:18.926
So, this first example
is for NSTimer.

1022
00:42:19.046 --> 00:42:20.726
You can simply call setTolerance

1023
00:42:20.986 --> 00:42:22.716
and indicate how much
tolerance you're willing

1024
00:42:22.716 --> 00:42:23.626
for that timer to have.

1025
00:42:23.886 --> 00:42:25.826
In this case, we
specified 60 seconds.

1026
00:42:26.416 --> 00:42:28.716
For a CFRunLoopTimer,
you can call

1027
00:42:28.716 --> 00:42:30.436
a CFRunLoopTimerSetTolerance.

1028
00:42:30.866 --> 00:42:32.856
And then for a dispatch
source timer,

1029
00:42:33.156 --> 00:42:34.796
when you call dispatch
source set timer,

1030
00:42:34.796 --> 00:42:36.776
that last parameter
is a tolerance value.

1031
00:42:37.276 --> 00:42:38.776
And so, in all these
cases, what we're indicating

1032
00:42:38.776 --> 00:42:41.106
in the system is that we're
willing for this timer to take

1033
00:42:41.476 --> 00:42:43.376
up to an extra 60
seconds to fire

1034
00:42:43.776 --> 00:42:45.616
if that will improve
our energy consumption.

1035
00:42:47.356 --> 00:42:49.276
So, let's minimize timers.

1036
00:42:49.746 --> 00:42:51.856
Be mindful of the
wakeup overhead timers.

1037
00:42:52.036 --> 00:42:55.066
Monitor your app for wakeups
using the Xcode Debug Gauge.

1038
00:42:56.446 --> 00:42:58.876
Debug with timerfires
if you find more wakeups

1039
00:42:58.876 --> 00:43:01.866
than you expect, and make sure
you specify a timer tolerance

1040
00:42:58.876 --> 00:43:01.866
than you expect, and make sure
you specify a timer tolerance

1041
00:43:02.446 --> 00:43:03.456
whenever you create a timer.

1042
00:43:04.066 --> 00:43:07.496
Now, this is a very brief
introduction to timers.

1043
00:43:07.546 --> 00:43:10.656
If you want a lot more details
and some examples of good

1044
00:43:10.656 --> 00:43:12.186
and bad timer-related code,

1045
00:43:12.426 --> 00:43:14.676
check out last year's
Energy Best Practices talk.

1046
00:43:14.676 --> 00:43:19.926
So, next I want to talk
about efficient Graphics.

1047
00:43:20.466 --> 00:43:22.336
Why is Graphics an
important area?

1048
00:43:22.966 --> 00:43:24.686
Well, let's say you
have an application

1049
00:43:24.946 --> 00:43:26.506
and your app does some drawing.

1050
00:43:26.826 --> 00:43:30.096
Well, that drawing now needs
to get handed to the system

1051
00:43:30.096 --> 00:43:31.906
so that it can compute how

1052
00:43:31.906 --> 00:43:35.356
that drawing affects the overall
user interface, do some work

1053
00:43:35.356 --> 00:43:36.936
in core animation
or core graphics.

1054
00:43:37.446 --> 00:43:39.446
Eventually, we'll hand
that work off to the GPU.

1055
00:43:39.446 --> 00:43:43.206
That GPU now needs to wake up
out of its low power states

1056
00:43:43.206 --> 00:43:44.196
and do some processing.

1057
00:43:44.826 --> 00:43:46.536
And then, we eventually
have to hand that off

1058
00:43:46.536 --> 00:43:48.686
to the display itself,
which might also be

1059
00:43:48.686 --> 00:43:50.186
in a low-power state
and it has to wake up

1060
00:43:50.186 --> 00:43:51.546
and do work to update the UI.

1061
00:43:51.546 --> 00:43:53.756
And so, it's very important

1062
00:43:53.756 --> 00:43:55.916
that we limit our screen
updates as much as possible.

1063
00:43:56.676 --> 00:43:58.976
This includes avoiding updating
the screen when we don't need

1064
00:43:58.976 --> 00:44:02.776
to because unnecessary drawing
can kick the graphics hardware

1065
00:43:58.976 --> 00:44:02.776
to because unnecessary drawing
can kick the graphics hardware

1066
00:44:02.776 --> 00:44:03.896
out of low-power modes.

1067
00:44:04.556 --> 00:44:07.036
It also means avoiding drawing
more content than needed.

1068
00:44:07.356 --> 00:44:09.876
So, if you get a, if
you have a custom view

1069
00:44:10.006 --> 00:44:13.006
and you get a DrawRect
call for a very small area,

1070
00:44:13.286 --> 00:44:15.726
make sure you don't draw more
than the area you're required.

1071
00:44:16.146 --> 00:44:19.606
And you can use needsToDrawRect
or getRectsBeingDrawn:count

1072
00:44:19.906 --> 00:44:22.256
to fine tune what areas
you update in your view.

1073
00:44:22.256 --> 00:44:25.686
And there's a great view drawing
guide available and we'll go

1074
00:44:25.686 --> 00:44:27.396
into that in more
detail if you're curious.

1075
00:44:28.256 --> 00:44:30.856
So, how do you determine whether
you're doing the right thing

1076
00:44:30.856 --> 00:44:31.746
with respect to drawing?

1077
00:44:32.686 --> 00:44:34.556
Well, you can use
Flash Screen Updates.

1078
00:44:34.556 --> 00:44:36.776
So, this is the Quartz
Debug utility that comes

1079
00:44:36.776 --> 00:44:38.176
with Graphics tools for Xcode.

1080
00:44:38.556 --> 00:44:41.996
If you run this and check the
Flash Screen Updates box-I'm not

1081
00:44:41.996 --> 00:44:42.896
going to demo this for you

1082
00:44:42.896 --> 00:44:44.496
because it can be a little
bit seizure inducing.

1083
00:44:45.026 --> 00:44:48.336
But, if you were to look at the
Shut Down dialog, you would,

1084
00:44:48.336 --> 00:44:51.416
on OS X Mavericks, you'd see
the Shut Down button flashing

1085
00:44:51.416 --> 00:44:52.526
at 30 frames per second.

1086
00:44:53.066 --> 00:44:55.206
And this is correct
behavior in this case,

1087
00:44:55.206 --> 00:44:56.346
because that button pulses.

1088
00:44:56.586 --> 00:44:59.086
And so, as long as you see
a flash only when we expect

1089
00:44:59.086 --> 00:45:02.016
that button to be updated
and that the region flashed,

1090
00:44:59.086 --> 00:45:02.016
that button to be updated
and that the region flashed,

1091
00:45:02.016 --> 00:45:03.316
which is indicated in yellow,

1092
00:45:03.776 --> 00:45:05.986
is only the area
immediately surrounding

1093
00:45:05.986 --> 00:45:09.076
that UI element that's changing,
then we're behaving correctly.

1094
00:45:09.256 --> 00:45:12.116
On the other hand, if you'd
seen the entire window flash,

1095
00:45:12.466 --> 00:45:13.766
that would have been
a cause for concern.

1096
00:45:14.616 --> 00:45:17.796
Now, if you were to compare
this to OS X Yosemite,

1097
00:45:18.306 --> 00:45:20.406
you'd see that the Shut Down
button doesn't pulse anymore,

1098
00:45:20.626 --> 00:45:21.986
so you wouldn't get
any flashing.

1099
00:45:22.446 --> 00:45:25.066
And we've improved
the energy consumption

1100
00:45:25.066 --> 00:45:26.146
of the Shut Down dialogue.

1101
00:45:27.126 --> 00:45:31.276
Now, for iOS, we, if you go to
the Core Animation instrument,

1102
00:45:31.456 --> 00:45:35.116
there's a debug option
for Flash Updated Regions

1103
00:45:35.116 --> 00:45:35.746
that you can check.

1104
00:45:35.746 --> 00:45:38.216
And this will produce
similar behavior

1105
00:45:38.216 --> 00:45:39.606
on your tethered iOS device.

1106
00:45:40.096 --> 00:45:43.396
And also, one other
thing you want to keep

1107
00:45:43.446 --> 00:45:44.896
in mind is visual effects.

1108
00:45:45.256 --> 00:45:49.776
So, with the new UI in OS
X Yosemite or the iOS 7 UI,

1109
00:45:50.686 --> 00:45:52.946
you might want to
place a translucency

1110
00:45:52.946 --> 00:45:54.446
or blur effect on some element.

1111
00:45:54.966 --> 00:45:56.906
But you want to make sure
you avoid placing these

1112
00:45:56.906 --> 00:45:58.406
over frequently updating
elements.

1113
00:45:58.406 --> 00:46:01.556
Because if something
underneath that effect changes,

1114
00:45:58.406 --> 00:46:01.556
Because if something
underneath that effect changes,

1115
00:46:01.806 --> 00:46:03.956
you have to update
the, and redo the work

1116
00:46:03.956 --> 00:46:05.356
to do the blur and translucency.

1117
00:46:05.686 --> 00:46:07.076
So, you can imagine, if we were

1118
00:46:07.076 --> 00:46:09.196
to put Animating
Content underneath the

1119
00:46:09.196 --> 00:46:12.626
NSVisualEffectView, we
would magnify the power cost

1120
00:46:12.626 --> 00:46:14.166
of updating that
Animating Content.

1121
00:46:14.256 --> 00:46:16.256
On the other hand, if
you move that content

1122
00:46:16.256 --> 00:46:17.626
out from underneath
the EffectView,

1123
00:46:18.476 --> 00:46:22.666
then you won't see dramatically
increased cost due to that.

1124
00:46:23.456 --> 00:46:24.986
So, that's Efficient Graphics.

1125
00:46:25.686 --> 00:46:27.236
Make sure to draw
minimally and efficiently.

1126
00:46:28.136 --> 00:46:30.846
Monitor your drawing with
Quartz Debug or Instruments

1127
00:46:31.266 --> 00:46:33.186
and avoid blurs on
updating content.

1128
00:46:33.686 --> 00:46:36.926
And finally, Flash Power.

1129
00:46:37.636 --> 00:46:41.056
So, Flash is a little
bit of a different beast

1130
00:46:41.056 --> 00:46:43.566
than the rotating hard drives
you might have been familiar

1131
00:46:43.566 --> 00:46:44.556
with in older Macs.

1132
00:46:45.026 --> 00:46:48.116
In particular, writes to Flash
are significantly more energy

1133
00:46:48.116 --> 00:46:49.076
hungry than reads.

1134
00:46:49.196 --> 00:46:51.676
So, you want to make sure
you write the minimum amount

1135
00:46:51.676 --> 00:46:55.286
of content necessary and
do writing in aggregate

1136
00:46:55.586 --> 00:46:57.796
to help amortize some
of those fixed costs.

1137
00:46:58.886 --> 00:47:02.086
Also, remember that any I/O you
do can pull the storage device

1138
00:46:58.886 --> 00:47:02.086
Also, remember that any I/O you
do can pull the storage device

1139
00:47:02.216 --> 00:47:03.396
out of a lower-power state.

1140
00:47:04.156 --> 00:47:05.276
And so, you want
to take advantage

1141
00:47:05.276 --> 00:47:06.926
of the I/O caching
available to you

1142
00:47:07.716 --> 00:47:10.266
to ensure you're not doing
lots of sporadic I/Os

1143
00:47:10.266 --> 00:47:11.726
to keep the device from idling.

1144
00:47:12.306 --> 00:47:15.816
So, that was Do It Less.

1145
00:47:16.456 --> 00:47:17.796
Things you want to
remember, profile

1146
00:47:17.796 --> 00:47:19.346
and monitor your CPU use.

1147
00:47:19.836 --> 00:47:20.806
Reduce your timers.

1148
00:47:21.286 --> 00:47:24.526
Be efficient in the use of
graphics and minimize your I/O.

1149
00:47:24.626 --> 00:47:25.206
All right.

1150
00:47:26.596 --> 00:47:29.046
So, to summarize what
we talked about today,

1151
00:47:30.116 --> 00:47:32.106
improving your app's energy
consumption improves the

1152
00:47:32.106 --> 00:47:33.016
user experience.

1153
00:47:33.536 --> 00:47:36.106
Keep in mind how you're
using the device and how,

1154
00:47:36.106 --> 00:47:37.726
what kind of impact that
will have on energy.

1155
00:47:39.826 --> 00:47:42.206
Make sure you continuously
monitor your app's energy

1156
00:47:42.206 --> 00:47:43.516
and resource consumption
as you're developing.

1157
00:47:44.316 --> 00:47:47.386
And look for ways to apply the
four techniques we talked about.

1158
00:47:47.616 --> 00:47:50.556
Do It Never, respond to
changes in your app's active

1159
00:47:50.786 --> 00:47:53.326
or occlusion state to minimize
the amount of work you do

1160
00:47:53.326 --> 00:47:55.776
when that work won't
be visible to the user.

1161
00:47:55.776 --> 00:47:59.936
Do It at a Better Time, let the
system schedule work using the

1162
00:47:59.936 --> 00:48:04.166
NSBackgroundActivityScheduler or
NSURLSessionBackground Session.

1163
00:47:59.936 --> 00:48:04.166
NSBackgroundActivityScheduler or
NSURLSessionBackground Session.

1164
00:48:04.776 --> 00:48:08.526
Do It More Efficiently, specify
Quality of Service Classes

1165
00:48:08.526 --> 00:48:11.386
on your work-and this can
provide huge benefits both

1166
00:48:11.386 --> 00:48:15.536
in energy and responsiveness-and
Do It Less.

1167
00:48:15.846 --> 00:48:17.576
Optimize and improve
your resource use.

1168
00:48:18.316 --> 00:48:20.626
For more information, you
can contact Paul Danbold,

1169
00:48:20.776 --> 00:48:22.316
the Core OS Evangelist.

1170
00:48:22.376 --> 00:48:24.466
You can also check out
these talks from last year,

1171
00:48:24.466 --> 00:48:27.076
Energy Best Practices and
Building Resource Efficient Apps

1172
00:48:27.436 --> 00:48:29.296
for more depth in some of
the things we covered today.

1173
00:48:30.426 --> 00:48:32.586
There's a variety of related
sessions I'd highly encourage

1174
00:48:32.586 --> 00:48:33.946
you to check out.

1175
00:48:33.946 --> 00:48:36.286
Yesterday's What's New in
Foundation Networking talk went

1176
00:48:36.286 --> 00:48:38.036
in more depth about
the Background Session.

1177
00:48:39.196 --> 00:48:42.056
Improving Your App with
Instruments is a great session

1178
00:48:42.056 --> 00:48:43.326
to learn more about
Instruments and some

1179
00:48:43.326 --> 00:48:44.586
of the new features available.

1180
00:48:45.376 --> 00:48:48.116
Writing Energy Efficient Code,
Part 2, right here on this stage

1181
00:48:48.116 --> 00:48:50.056
in just a few minutes.

1182
00:48:51.006 --> 00:48:54.666
Testing in Xcode 6 and
the Continuous Integration

1183
00:48:54.666 --> 00:48:56.246
with Xcode 6 will
go into more depth

1184
00:48:56.346 --> 00:48:58.226
about the performance
unit tests.

1185
00:48:58.656 --> 00:49:01.596
Fix Bugs Faster Using Activity
Tracking is a great way

1186
00:48:58.656 --> 00:49:01.596
Fix Bugs Faster Using Activity
Tracking is a great way

1187
00:49:01.596 --> 00:49:03.616
to help understand the
asynchronous work your

1188
00:49:03.616 --> 00:49:04.486
application is doing.

1189
00:49:05.036 --> 00:49:07.306
And, of course, Power,
Performance, and Diagnostics,

1190
00:49:07.626 --> 00:49:10.276
tomorrow afternoon, will go into
much more depth about Quality

1191
00:49:10.276 --> 00:49:12.416
of Service Classes and
how to specify them

1192
00:49:12.416 --> 00:49:13.926
in a variety of layers
in the API.

1193
00:49:15.416 --> 00:49:15.966
Thank you.

1194
00:49:16.516 --> 00:49:23.880
[ Applause ]
